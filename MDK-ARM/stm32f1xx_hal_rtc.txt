; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_hal_rtc.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_hal_rtc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_hal_rtc.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc.c]
                          THUMB

                          AREA ||i.HAL_RTC_AlarmAEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTC_AlarmAEventCallback PROC
;;;1436     */
;;;1437   __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;1438   {
;;;1439     /* Prevent unused argument(s) compilation warning */
;;;1440     UNUSED(hrtc);
;;;1441     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1442               the HAL_RTC_AlarmAEventCallback could be implemented in the user file
;;;1443      */
;;;1444   }
;;;1445   
                          ENDP


                          AREA ||i.HAL_RTC_AlarmIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTC_AlarmIRQHandler PROC
;;;1404     */
;;;1405   void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;1406   {
000002  4604              MOV      r4,r0
;;;1407     if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA))
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  0789              LSLS     r1,r1,#30
00000a  d50a              BPL      |L2.34|
;;;1408     {
;;;1409       /* Get the status of the Interrupt */
;;;1410       if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != (uint32_t)RESET)
00000c  6840              LDR      r0,[r0,#4]
00000e  0780              LSLS     r0,r0,#30
000010  d507              BPL      |L2.34|
;;;1411       {
;;;1412         /* AlarmA callback */
;;;1413   #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;1414         hrtc->AlarmAEventCallback(hrtc);
;;;1415   #else
;;;1416         HAL_RTC_AlarmAEventCallback(hrtc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_RTC_AlarmAEventCallback
;;;1417   #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;1418   
;;;1419         /* Clear the Alarm interrupt pending bit */
;;;1420         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
000018  6820              LDR      r0,[r4,#0]
00001a  6841              LDR      r1,[r0,#4]
00001c  f0210102          BIC      r1,r1,#2
000020  6041              STR      r1,[r0,#4]
                  |L2.34|
;;;1421       }
;;;1422     }
;;;1423   
;;;1424     /* Clear the EXTI's line Flag for RTC Alarm */
;;;1425     __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
000022  4903              LDR      r1,|L2.48|
000024  f44f3000          MOV      r0,#0x20000
000028  6008              STR      r0,[r1,#0]
;;;1426   
;;;1427     /* Change RTC state */
;;;1428     hrtc->State = HAL_RTC_STATE_READY;
00002a  2001              MOVS     r0,#1
00002c  7460              STRB     r0,[r4,#0x11]
;;;1429   }
00002e  bd10              POP      {r4,pc}
;;;1430   
                          ENDP

                  |L2.48|
                          DCD      0x40010414

                          AREA ||i.HAL_RTC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_DeInit PROC
;;;411      */
;;;412    HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;413    {
000002  4604              MOV      r4,r0
;;;414      /* Check input parameters */
;;;415      if (hrtc == NULL)
000004  2c00              CMP      r4,#0
000006  d00b              BEQ      |L3.32|
;;;416      {
;;;417        return HAL_ERROR;
;;;418      }
;;;419    
;;;420      /* Check the parameters */
;;;421      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;422    
;;;423      /* Set RTC state */
;;;424      hrtc->State = HAL_RTC_STATE_BUSY;
000008  2002              MOVS     r0,#2
00000a  7460              STRB     r0,[r4,#0x11]
;;;425    
;;;426      /* Set Initialization mode */
;;;427      if (RTC_EnterInitMode(hrtc) != HAL_OK)
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RTC_EnterInitMode
;;;428      {
;;;429        /* Set RTC state */
;;;430        hrtc->State = HAL_RTC_STATE_ERROR;
000012  2604              MOVS     r6,#4
000014  2500              MOVS     r5,#0
000016  b128              CBZ      r0,|L3.36|
000018  7466              STRB     r6,[r4,#0x11]
;;;431    
;;;432        /* Release Lock */
;;;433        __HAL_UNLOCK(hrtc);
00001a  7425              STRB     r5,[r4,#0x10]
;;;434    
;;;435        return HAL_ERROR;
00001c  2001              MOVS     r0,#1
;;;436      }
;;;437      else
;;;438      {
;;;439        CLEAR_REG(hrtc->Instance->CNTL);
;;;440        CLEAR_REG(hrtc->Instance->CNTH);
;;;441        WRITE_REG(hrtc->Instance->PRLL, 0x00008000U);
;;;442        CLEAR_REG(hrtc->Instance->PRLH);
;;;443    
;;;444        /* Reset All CRH/CRL bits */
;;;445        CLEAR_REG(hrtc->Instance->CRH);
;;;446        CLEAR_REG(hrtc->Instance->CRL);
;;;447    
;;;448        if (RTC_ExitInitMode(hrtc) != HAL_OK)
;;;449        {
;;;450          hrtc->State = HAL_RTC_STATE_ERROR;
;;;451    
;;;452          /* Process Unlocked */
;;;453          __HAL_UNLOCK(hrtc);
;;;454    
;;;455          return HAL_ERROR;
;;;456        }
;;;457      }
;;;458    
;;;459      /* Wait for synchro*/
;;;460      HAL_RTC_WaitForSynchro(hrtc);
;;;461    
;;;462      /* Clear RSF flag */
;;;463      CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
;;;464    
;;;465    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;466      if (hrtc->MspDeInitCallback == NULL)
;;;467      {
;;;468        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;469      }
;;;470    
;;;471      /* DeInit the low level hardware: CLOCK, NVIC.*/
;;;472      hrtc->MspDeInitCallback(hrtc);
;;;473    
;;;474    #else
;;;475      /* De-Initialize RTC MSP */
;;;476      HAL_RTC_MspDeInit(hrtc);
;;;477    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
;;;478    
;;;479      hrtc->State = HAL_RTC_STATE_RESET;
;;;480    
;;;481      /* Release Lock */
;;;482      __HAL_UNLOCK(hrtc);
;;;483    
;;;484      return HAL_OK;
;;;485    }
00001e  bd70              POP      {r4-r6,pc}
                  |L3.32|
000020  2001              MOVS     r0,#1                 ;417
000022  bd70              POP      {r4-r6,pc}
                  |L3.36|
000024  6820              LDR      r0,[r4,#0]            ;439
000026  61c5              STR      r5,[r0,#0x1c]         ;439
000028  6820              LDR      r0,[r4,#0]            ;440
00002a  6185              STR      r5,[r0,#0x18]         ;440
00002c  6821              LDR      r1,[r4,#0]            ;441
00002e  f44f4000          MOV      r0,#0x8000            ;441
000032  60c8              STR      r0,[r1,#0xc]          ;441
000034  6820              LDR      r0,[r4,#0]            ;442
000036  6085              STR      r5,[r0,#8]            ;442
000038  6820              LDR      r0,[r4,#0]            ;445
00003a  6005              STR      r5,[r0,#0]            ;445
00003c  6820              LDR      r0,[r4,#0]            ;446
00003e  6045              STR      r5,[r0,#4]            ;446
000040  4620              MOV      r0,r4                 ;448
000042  f7fffffe          BL       RTC_ExitInitMode
000046  b118              CBZ      r0,|L3.80|
000048  7466              STRB     r6,[r4,#0x11]         ;450
00004a  7425              STRB     r5,[r4,#0x10]         ;453
00004c  2001              MOVS     r0,#1                 ;455
00004e  bd70              POP      {r4-r6,pc}
                  |L3.80|
000050  4620              MOV      r0,r4                 ;460
000052  f7fffffe          BL       HAL_RTC_WaitForSynchro
000056  6820              LDR      r0,[r4,#0]            ;463
000058  6841              LDR      r1,[r0,#4]            ;463
00005a  f0210108          BIC      r1,r1,#8              ;463
00005e  6041              STR      r1,[r0,#4]            ;463
000060  4620              MOV      r0,r4                 ;476
000062  f7fffffe          BL       HAL_RTC_MspDeInit
000066  7465              STRB     r5,[r4,#0x11]         ;479
000068  7425              STRB     r5,[r4,#0x10]         ;482
00006a  2000              MOVS     r0,#0                 ;484
00006c  bd70              POP      {r4-r6,pc}
;;;486    
                          ENDP


                          AREA ||i.HAL_RTC_DeactivateAlarm||, CODE, READONLY, ALIGN=2

                  HAL_RTC_DeactivateAlarm PROC
;;;1334     */
;;;1335   HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1336   {
000004  4604              MOV      r4,r0
;;;1337     /* Prevent unused argument(s) compilation warning */
;;;1338     UNUSED(Alarm);
;;;1339   
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_RTC_ALARM(Alarm));
;;;1342   
;;;1343     /* Check input parameters */
;;;1344     if (hrtc == NULL)
000006  2c00              CMP      r4,#0
000008  d016              BEQ      |L4.56|
;;;1345     {
;;;1346       return HAL_ERROR;
;;;1347     }
;;;1348   
;;;1349     /* Process Locked */
;;;1350     __HAL_LOCK(hrtc);
00000a  7c20              LDRB     r0,[r4,#0x10]
00000c  2801              CMP      r0,#1
00000e  d015              BEQ      |L4.60|
000010  2601              MOVS     r6,#1
000012  7426              STRB     r6,[r4,#0x10]
;;;1351   
;;;1352     hrtc->State = HAL_RTC_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  7460              STRB     r0,[r4,#0x11]
;;;1353   
;;;1354     /* In case of interrupt mode is used, the interrupt source must disabled */
;;;1355     __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210102          BIC      r1,r1,#2
000020  6001              STR      r1,[r0,#0]
;;;1356   
;;;1357     /* Set Initialization mode */
;;;1358     if (RTC_EnterInitMode(hrtc) != HAL_OK)
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       RTC_EnterInitMode
000028  2500              MOVS     r5,#0
;;;1359     {
;;;1360       /* Set RTC state */
;;;1361       hrtc->State = HAL_RTC_STATE_ERROR;
00002a  2704              MOVS     r7,#4
00002c  b140              CBZ      r0,|L4.64|
00002e  7467              STRB     r7,[r4,#0x11]
;;;1362   
;;;1363       /* Process Unlocked */
;;;1364       __HAL_UNLOCK(hrtc);
000030  7425              STRB     r5,[r4,#0x10]
;;;1365   
;;;1366       return HAL_ERROR;
000032  2001              MOVS     r0,#1
                  |L4.52|
;;;1367     }
;;;1368     else
;;;1369     {
;;;1370       /* Clear flag alarm A */
;;;1371       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1372   
;;;1373       /* Set to default values ALRH & ALRL registers */
;;;1374       WRITE_REG(hrtc->Instance->ALRH, RTC_ALARM_RESETVALUE_REGISTER);
;;;1375       WRITE_REG(hrtc->Instance->ALRL, RTC_ALARM_RESETVALUE_REGISTER);
;;;1376   
;;;1377       /* RTC Alarm Interrupt Configuration: Disable EXTI configuration */
;;;1378       __HAL_RTC_ALARM_EXTI_DISABLE_IT();
;;;1379   
;;;1380       /* Wait for synchro */
;;;1381       if (RTC_ExitInitMode(hrtc) != HAL_OK)
;;;1382       {
;;;1383         hrtc->State = HAL_RTC_STATE_ERROR;
;;;1384   
;;;1385         /* Process Unlocked */
;;;1386         __HAL_UNLOCK(hrtc);
;;;1387   
;;;1388         return HAL_ERROR;
;;;1389       }
;;;1390     }
;;;1391     hrtc->State = HAL_RTC_STATE_READY;
;;;1392   
;;;1393     /* Process Unlocked */
;;;1394     __HAL_UNLOCK(hrtc);
;;;1395   
;;;1396     return HAL_OK;
;;;1397   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L4.56|
000038  2001              MOVS     r0,#1                 ;1346
00003a  e7fb              B        |L4.52|
                  |L4.60|
00003c  2002              MOVS     r0,#2                 ;1350
00003e  e7f9              B        |L4.52|
                  |L4.64|
000040  6820              LDR      r0,[r4,#0]            ;1371
000042  6841              LDR      r1,[r0,#4]            ;1371
000044  f0210102          BIC      r1,r1,#2              ;1371
000048  6041              STR      r1,[r0,#4]            ;1371
00004a  6821              LDR      r1,[r4,#0]            ;1374
00004c  f64f70ff          MOV      r0,#0xffff            ;1374
000050  6208              STR      r0,[r1,#0x20]         ;1374
000052  6821              LDR      r1,[r4,#0]            ;1375
000054  6248              STR      r0,[r1,#0x24]         ;1375
000056  4808              LDR      r0,|L4.120|
000058  6801              LDR      r1,[r0,#0]            ;1378
00005a  f4213100          BIC      r1,r1,#0x20000        ;1378
00005e  6001              STR      r1,[r0,#0]            ;1378
000060  4620              MOV      r0,r4                 ;1381
000062  f7fffffe          BL       RTC_ExitInitMode
000066  b118              CBZ      r0,|L4.112|
000068  7467              STRB     r7,[r4,#0x11]         ;1383
00006a  7425              STRB     r5,[r4,#0x10]         ;1386
00006c  2001              MOVS     r0,#1                 ;1388
00006e  e7e1              B        |L4.52|
                  |L4.112|
000070  7466              STRB     r6,[r4,#0x11]         ;1391
000072  7425              STRB     r5,[r4,#0x10]         ;1394
000074  2000              MOVS     r0,#0                 ;1396
000076  e7dd              B        |L4.52|
;;;1398   
                          ENDP

                  |L4.120|
                          DCD      0x40010400

                          AREA ||i.HAL_RTC_GetAlarm||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetAlarm PROC
;;;1289     */
;;;1290   HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
000000  b570              PUSH     {r4-r6,lr}
;;;1291   {
000002  460c              MOV      r4,r1
000004  461d              MOV      r5,r3
;;;1292     uint32_t counter_alarm = 0U;
;;;1293   
;;;1294     /* Prevent unused argument(s) compilation warning */
;;;1295     UNUSED(Alarm);
;;;1296   
;;;1297     /* Check input parameters */
;;;1298     if ((hrtc == NULL) || (sAlarm == NULL))
000006  2800              CMP      r0,#0
000008  d02c              BEQ      |L5.100|
00000a  b35c              CBZ      r4,|L5.100|
;;;1299     {
;;;1300       return HAL_ERROR;
;;;1301     }
;;;1302   
;;;1303     /* Check the parameters */
;;;1304     assert_param(IS_RTC_FORMAT(Format));
;;;1305     assert_param(IS_RTC_ALARM(Alarm));
;;;1306   
;;;1307     /* Read Alarm counter in RTC registers */
;;;1308     counter_alarm = RTC_ReadAlarmCounter(hrtc);
00000c  f7fffffe          BL       RTC_ReadAlarmCounter
;;;1309   
;;;1310     /* Fill the structure with the read parameters */
;;;1311     /* Set hours in a day range (between 0 to 24)*/
;;;1312     sAlarm->AlarmTime.Hours   = (uint32_t)((counter_alarm / 3600U) % 24U);
000010  f44f6161          MOV      r1,#0xe10
000014  fbb0f2f1          UDIV     r2,r0,r1
000018  2318              MOVS     r3,#0x18
00001a  fbb2f6f3          UDIV     r6,r2,r3
00001e  fb032216          MLS      r2,r3,r6,r2
000022  7022              STRB     r2,[r4,#0]
;;;1313     sAlarm->AlarmTime.Minutes = (uint32_t)((counter_alarm % 3600U) / 60U);
000024  fbb0f3f1          UDIV     r3,r0,r1
000028  fb010613          MLS      r6,r1,r3,r0
00002c  233c              MOVS     r3,#0x3c
00002e  fbb6f6f3          UDIV     r6,r6,r3
000032  7066              STRB     r6,[r4,#1]
;;;1314     sAlarm->AlarmTime.Seconds = (uint32_t)((counter_alarm % 3600U) % 60U);
000034  fbb0f6f1          UDIV     r6,r0,r1
000038  fb010016          MLS      r0,r1,r6,r0
00003c  fbb0f1f3          UDIV     r1,r0,r3
000040  fb030011          MLS      r0,r3,r1,r0
000044  70a0              STRB     r0,[r4,#2]
;;;1315   
;;;1316     if (Format != RTC_FORMAT_BIN)
000046  b15d              CBZ      r5,|L5.96|
;;;1317     {
;;;1318       sAlarm->AlarmTime.Hours   = RTC_ByteToBcd2(sAlarm->AlarmTime.Hours);
000048  4610              MOV      r0,r2
00004a  f7fffffe          BL       RTC_ByteToBcd2
00004e  7020              STRB     r0,[r4,#0]
;;;1319       sAlarm->AlarmTime.Minutes = RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes);
000050  7860              LDRB     r0,[r4,#1]
000052  f7fffffe          BL       RTC_ByteToBcd2
000056  7060              STRB     r0,[r4,#1]
;;;1320       sAlarm->AlarmTime.Seconds = RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds);
000058  78a0              LDRB     r0,[r4,#2]
00005a  f7fffffe          BL       RTC_ByteToBcd2
00005e  70a0              STRB     r0,[r4,#2]
                  |L5.96|
;;;1321     }
;;;1322   
;;;1323     return HAL_OK;
000060  2000              MOVS     r0,#0
;;;1324   }
000062  bd70              POP      {r4-r6,pc}
                  |L5.100|
000064  2001              MOVS     r0,#1                 ;1300
000066  bd70              POP      {r4-r6,pc}
;;;1325   
                          ENDP


                          AREA ||i.HAL_RTC_GetDate||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetDate PROC
;;;1027     */
;;;1028   HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1029   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;1030     RTC_TimeTypeDef stime = {0U};
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1031   
;;;1032     /* Check input parameters */
;;;1033     if ((hrtc == NULL) || (sDate == NULL))
00000c  2d00              CMP      r5,#0
00000e  d008              BEQ      |L6.34|
000010  b13c              CBZ      r4,|L6.34|
;;;1034     {
;;;1035       return HAL_ERROR;
;;;1036     }
;;;1037   
;;;1038     /* Check the parameters */
;;;1039     assert_param(IS_RTC_FORMAT(Format));
;;;1040   
;;;1041     /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;1042     if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
000012  2200              MOVS     r2,#0
000014  4669              MOV      r1,sp
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       HAL_RTC_GetTime
00001c  b118              CBZ      r0,|L6.38|
;;;1043     {
;;;1044       return HAL_ERROR;
00001e  2001              MOVS     r0,#1
;;;1045     }
;;;1046   
;;;1047     /* Fill the structure fields with the read parameters */
;;;1048     sDate->WeekDay  = hrtc->DateToUpdate.WeekDay;
;;;1049     sDate->Year     = hrtc->DateToUpdate.Year;
;;;1050     sDate->Month    = hrtc->DateToUpdate.Month;
;;;1051     sDate->Date     = hrtc->DateToUpdate.Date;
;;;1052   
;;;1053     /* Check the input parameters format */
;;;1054     if (Format != RTC_FORMAT_BIN)
;;;1055     {
;;;1056       /* Convert the date structure parameters to BCD format */
;;;1057       sDate->Year   = (uint8_t)RTC_ByteToBcd2(sDate->Year);
;;;1058       sDate->Month  = (uint8_t)RTC_ByteToBcd2(sDate->Month);
;;;1059       sDate->Date   = (uint8_t)RTC_ByteToBcd2(sDate->Date);
;;;1060     }
;;;1061     return HAL_OK;
;;;1062   }
000020  bdf8              POP      {r3-r7,pc}
                  |L6.34|
000022  2001              MOVS     r0,#1                 ;1035
000024  bdf8              POP      {r3-r7,pc}
                  |L6.38|
000026  7b28              LDRB     r0,[r5,#0xc]          ;1048
000028  7020              STRB     r0,[r4,#0]            ;1048
00002a  7be8              LDRB     r0,[r5,#0xf]          ;1049
00002c  70e0              STRB     r0,[r4,#3]            ;1049
00002e  7b69              LDRB     r1,[r5,#0xd]          ;1050
000030  7061              STRB     r1,[r4,#1]            ;1050
000032  7ba9              LDRB     r1,[r5,#0xe]          ;1051
000034  70a1              STRB     r1,[r4,#2]            ;1051
000036  b156              CBZ      r6,|L6.78|
000038  f7fffffe          BL       RTC_ByteToBcd2
00003c  70e0              STRB     r0,[r4,#3]            ;1057
00003e  7860              LDRB     r0,[r4,#1]            ;1058
000040  f7fffffe          BL       RTC_ByteToBcd2
000044  7060              STRB     r0,[r4,#1]            ;1058
000046  78a0              LDRB     r0,[r4,#2]            ;1059
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  70a0              STRB     r0,[r4,#2]            ;1059
                  |L6.78|
00004e  2000              MOVS     r0,#0                 ;1061
000050  bdf8              POP      {r3-r7,pc}
;;;1063   
                          ENDP


                          AREA ||i.HAL_RTC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetState PROC
;;;1507     */
;;;1508   HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc)
000000  7c40              LDRB     r0,[r0,#0x11]
;;;1509   {
;;;1510     return hrtc->State;
;;;1511   }
000002  4770              BX       lr
;;;1512   
                          ENDP


                          AREA ||i.HAL_RTC_GetTime||, CODE, READONLY, ALIGN=1

                  HAL_RTC_GetTime PROC
;;;802      */
;;;803    HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;804    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;805      uint32_t counter_time = 0U, counter_alarm = 0U, days_elapsed = 0U, hours = 0U;
;;;806    
;;;807      /* Check input parameters */
;;;808      if ((hrtc == NULL) || (sTime == NULL))
00000a  2f00              CMP      r7,#0
00000c  d007              BEQ      |L8.30|
00000e  b134              CBZ      r4,|L8.30|
;;;809      {
;;;810        return HAL_ERROR;
;;;811      }
;;;812    
;;;813      /* Check the parameters */
;;;814      assert_param(IS_RTC_FORMAT(Format));
;;;815    
;;;816      /* Check if counter overflow occurred */
;;;817      if (__HAL_RTC_OVERFLOW_GET_FLAG(hrtc, RTC_FLAG_OW))
000010  6838              LDR      r0,[r7,#0]
000012  6840              LDR      r0,[r0,#4]
000014  0740              LSLS     r0,r0,#29
000016  d504              BPL      |L8.34|
;;;818      {
;;;819        return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L8.26|
;;;820      }
;;;821    
;;;822      /* Read the time counter*/
;;;823      counter_time = RTC_ReadTimeCounter(hrtc);
;;;824    
;;;825      /* Fill the structure fields with the read parameters */
;;;826      hours = counter_time / 3600U;
;;;827      sTime->Minutes  = (uint8_t)((counter_time % 3600U) / 60U);
;;;828      sTime->Seconds  = (uint8_t)((counter_time % 3600U) % 60U);
;;;829    
;;;830      if (hours >= 24U)
;;;831      {
;;;832        /* Get number of days elapsed from last calculation */
;;;833        days_elapsed = (hours / 24U);
;;;834    
;;;835        /* Set Hours in RTC_TimeTypeDef structure*/
;;;836        sTime->Hours = (hours % 24U);
;;;837    
;;;838        /* Read Alarm counter in RTC registers */
;;;839        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;840    
;;;841        /* Calculate remaining time to reach alarm (only if set and not yet expired)*/
;;;842        if ((counter_alarm != RTC_ALARM_RESETVALUE) && (counter_alarm > counter_time))
;;;843        {
;;;844          counter_alarm -= counter_time;
;;;845        }
;;;846        else
;;;847        {
;;;848          /* In case of counter_alarm < counter_time */
;;;849          /* Alarm expiration already occurred but alarm not deactivated */
;;;850          counter_alarm = RTC_ALARM_RESETVALUE;
;;;851        }
;;;852    
;;;853        /* Set updated time in decreasing counter by number of days elapsed */
;;;854        counter_time -= (days_elapsed * 24U * 3600U);
;;;855    
;;;856        /* Write time counter in RTC registers */
;;;857        if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
;;;858        {
;;;859          return HAL_ERROR;
;;;860        }
;;;861    
;;;862        /* Set updated alarm to be set */
;;;863        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;864        {
;;;865          counter_alarm += counter_time;
;;;866    
;;;867          /* Write time counter in RTC registers */
;;;868          if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;869          {
;;;870            return HAL_ERROR;
;;;871          }
;;;872        }
;;;873        else
;;;874        {
;;;875          /* Alarm already occurred. Set it to reset values to avoid unexpected expiration */
;;;876          if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;877          {
;;;878            return HAL_ERROR;
;;;879          }
;;;880        }
;;;881    
;;;882        /* Update date */
;;;883        RTC_DateUpdate(hrtc, days_elapsed);
;;;884      }
;;;885      else
;;;886      {
;;;887        sTime->Hours = hours;
;;;888      }
;;;889    
;;;890      /* Check the input parameters format */
;;;891      if (Format != RTC_FORMAT_BIN)
;;;892      {
;;;893        /* Convert the time structure parameters to BCD format */
;;;894        sTime->Hours    = (uint8_t)RTC_ByteToBcd2(sTime->Hours);
;;;895        sTime->Minutes  = (uint8_t)RTC_ByteToBcd2(sTime->Minutes);
;;;896        sTime->Seconds  = (uint8_t)RTC_ByteToBcd2(sTime->Seconds);
;;;897      }
;;;898    
;;;899      return HAL_OK;
;;;900    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L8.30|
00001e  2001              MOVS     r0,#1                 ;810
000020  e7fb              B        |L8.26|
                  |L8.34|
000022  4638              MOV      r0,r7                 ;823
000024  f7fffffe          BL       RTC_ReadTimeCounter
000028  4605              MOV      r5,r0                 ;823
00002a  f44f6061          MOV      r0,#0xe10             ;826
00002e  fbb5f1f0          UDIV     r1,r5,r0              ;826
000032  fbb5f2f0          UDIV     r2,r5,r0              ;827
000036  fb005312          MLS      r3,r0,r2,r5           ;827
00003a  223c              MOVS     r2,#0x3c              ;827
00003c  fbb3f3f2          UDIV     r3,r3,r2              ;827
000040  7063              STRB     r3,[r4,#1]            ;827
000042  fbb5f3f0          UDIV     r3,r5,r0              ;828
000046  fb005013          MLS      r0,r0,r3,r5           ;828
00004a  fbb0f3f2          UDIV     r3,r0,r2              ;828
00004e  fb020013          MLS      r0,r2,r3,r0           ;828
000052  70a0              STRB     r0,[r4,#2]            ;828
000054  2918              CMP      r1,#0x18              ;830
000056  d336              BCC      |L8.198|
000058  2018              MOVS     r0,#0x18              ;833
00005a  fbb1f9f0          UDIV     r9,r1,r0              ;833
00005e  fbb1f2f0          UDIV     r2,r1,r0              ;836
000062  fb001012          MLS      r0,r0,r2,r1           ;836
000066  7020              STRB     r0,[r4,#0]            ;836
000068  4638              MOV      r0,r7                 ;839
00006a  f7fffffe          BL       RTC_ReadAlarmCounter
00006e  1c41              ADDS     r1,r0,#1              ;842
000070  d003              BEQ      |L8.122|
000072  42a8              CMP      r0,r5                 ;842
000074  d901              BLS      |L8.122|
000076  1b46              SUBS     r6,r0,r5              ;844
000078  e001              B        |L8.126|
                  |L8.122|
00007a  f04f36ff          MOV      r6,#0xffffffff        ;850
                  |L8.126|
00007e  eba91009          SUB      r0,r9,r9,LSL #4       ;854
000082  eb000040          ADD      r0,r0,r0,LSL #1       ;854
000086  ebc01000          RSB      r0,r0,r0,LSL #4       ;854
00008a  eb0515c0          ADD      r5,r5,r0,LSL #7       ;854
00008e  4629              MOV      r1,r5                 ;857
000090  4638              MOV      r0,r7                 ;857
000092  f7fffffe          BL       RTC_WriteTimeCounter
000096  b108              CBZ      r0,|L8.156|
000098  2001              MOVS     r0,#1                 ;859
00009a  e7be              B        |L8.26|
                  |L8.156|
00009c  1c70              ADDS     r0,r6,#1              ;863
00009e  d006              BEQ      |L8.174|
0000a0  1971              ADDS     r1,r6,r5              ;865
0000a2  4638              MOV      r0,r7                 ;868
0000a4  f7fffffe          BL       RTC_WriteAlarmCounter
0000a8  b140              CBZ      r0,|L8.188|
0000aa  2001              MOVS     r0,#1                 ;870
0000ac  e7b5              B        |L8.26|
                  |L8.174|
0000ae  4631              MOV      r1,r6                 ;876
0000b0  4638              MOV      r0,r7                 ;876
0000b2  f7fffffe          BL       RTC_WriteAlarmCounter
0000b6  b108              CBZ      r0,|L8.188|
0000b8  2001              MOVS     r0,#1                 ;878
0000ba  e7ae              B        |L8.26|
                  |L8.188|
0000bc  4649              MOV      r1,r9                 ;883
0000be  4638              MOV      r0,r7                 ;883
0000c0  f7fffffe          BL       RTC_DateUpdate
0000c4  e000              B        |L8.200|
                  |L8.198|
0000c6  7021              STRB     r1,[r4,#0]            ;887
                  |L8.200|
0000c8  f1b80f00          CMP      r8,#0                 ;891
0000cc  d00b              BEQ      |L8.230|
0000ce  7820              LDRB     r0,[r4,#0]            ;894
0000d0  f7fffffe          BL       RTC_ByteToBcd2
0000d4  7020              STRB     r0,[r4,#0]            ;894
0000d6  7860              LDRB     r0,[r4,#1]            ;895
0000d8  f7fffffe          BL       RTC_ByteToBcd2
0000dc  7060              STRB     r0,[r4,#1]            ;895
0000de  78a0              LDRB     r0,[r4,#2]            ;896
0000e0  f7fffffe          BL       RTC_ByteToBcd2
0000e4  70a0              STRB     r0,[r4,#2]            ;896
                  |L8.230|
0000e6  2000              MOVS     r0,#0                 ;899
0000e8  e797              B        |L8.26|
;;;901    
                          ENDP


                          AREA ||i.HAL_RTC_Init||, CODE, READONLY, ALIGN=2

                  HAL_RTC_Init PROC
;;;275      */
;;;276    HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;277    {
000002  4604              MOV      r4,r0
;;;278      uint32_t prescaler = 0U;
;;;279      /* Check input parameters */
;;;280      if (hrtc == NULL)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L9.16|
;;;281      {
;;;282        return HAL_ERROR;
;;;283      }
;;;284    
;;;285      /* Check the parameters */
;;;286      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;287      assert_param(IS_RTC_CALIB_OUTPUT(hrtc->Init.OutPut));
;;;288      assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
;;;289    
;;;290    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;291      if (hrtc->State == HAL_RTC_STATE_RESET)
;;;292      {
;;;293        /* Allocate lock resource and initialize it */
;;;294        hrtc->Lock = HAL_UNLOCKED;
;;;295    
;;;296        hrtc->AlarmAEventCallback          =  HAL_RTC_AlarmAEventCallback;        /* Legacy weak AlarmAEventCallback      */
;;;297        hrtc->Tamper1EventCallback         =  HAL_RTCEx_Tamper1EventCallback;     /* Legacy weak Tamper1EventCallback     */
;;;298    
;;;299        if (hrtc->MspInitCallback == NULL)
;;;300        {
;;;301          hrtc->MspInitCallback = HAL_RTC_MspInit;
;;;302        }
;;;303        /* Init the low level hardware */
;;;304        hrtc->MspInitCallback(hrtc);
;;;305    
;;;306        if (hrtc->MspDeInitCallback == NULL)
;;;307        {
;;;308          hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
;;;309        }
;;;310      }
;;;311    #else
;;;312      if (hrtc->State == HAL_RTC_STATE_RESET)
000008  7c60              LDRB     r0,[r4,#0x11]
00000a  2600              MOVS     r6,#0
00000c  b110              CBZ      r0,|L9.20|
00000e  e005              B        |L9.28|
                  |L9.16|
000010  2001              MOVS     r0,#1                 ;282
;;;313      {
;;;314        /* Allocate lock resource and initialize it */
;;;315        hrtc->Lock = HAL_UNLOCKED;
;;;316    
;;;317        /* Initialize RTC MSP */
;;;318        HAL_RTC_MspInit(hrtc);
;;;319      }
;;;320    #endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */
;;;321    
;;;322      /* Set RTC state */
;;;323      hrtc->State = HAL_RTC_STATE_BUSY;
;;;324    
;;;325      /* Waiting for synchro */
;;;326      if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;327      {
;;;328        /* Set RTC state */
;;;329        hrtc->State = HAL_RTC_STATE_ERROR;
;;;330    
;;;331        return HAL_ERROR;
;;;332      }
;;;333    
;;;334      /* Set Initialization mode */
;;;335      if (RTC_EnterInitMode(hrtc) != HAL_OK)
;;;336      {
;;;337        /* Set RTC state */
;;;338        hrtc->State = HAL_RTC_STATE_ERROR;
;;;339    
;;;340        return HAL_ERROR;
;;;341      }
;;;342      else
;;;343      {
;;;344        /* Clear Flags Bits */
;;;345        CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_OW | RTC_FLAG_ALRAF | RTC_FLAG_SEC));
;;;346    
;;;347        if (hrtc->Init.OutPut != RTC_OUTPUTSOURCE_NONE)
;;;348        {
;;;349          /* Disable the selected Tamper pin */
;;;350          CLEAR_BIT(BKP->CR, BKP_CR_TPE);
;;;351        }
;;;352    
;;;353        /* Set the signal which will be routed to RTC Tamper pin*/
;;;354        MODIFY_REG(BKP->RTCCR, (BKP_RTCCR_CCO | BKP_RTCCR_ASOE | BKP_RTCCR_ASOS), hrtc->Init.OutPut);
;;;355    
;;;356        if (hrtc->Init.AsynchPrediv != RTC_AUTO_1_SECOND)
;;;357        {
;;;358          /* RTC Prescaler provided directly by end-user*/
;;;359          prescaler = hrtc->Init.AsynchPrediv;
;;;360        }
;;;361        else
;;;362        {
;;;363          /* RTC Prescaler will be automatically calculated to get 1 second timebase */
;;;364          /* Get the RTCCLK frequency */
;;;365          prescaler = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_RTC);
;;;366    
;;;367          /* Check that RTC clock is enabled*/
;;;368          if (prescaler == 0U)
;;;369          {
;;;370            /* Should not happen. Frequency is not available*/
;;;371            hrtc->State = HAL_RTC_STATE_ERROR;
;;;372            return HAL_ERROR;
;;;373          }
;;;374          else
;;;375          {
;;;376            /* RTC period = RTCCLK/(RTC_PR + 1) */
;;;377            prescaler = prescaler - 1U;
;;;378          }
;;;379        }
;;;380    
;;;381        /* Configure the RTC_PRLH / RTC_PRLL */
;;;382        WRITE_REG(hrtc->Instance->PRLH, ((prescaler >> 16U) & RTC_PRLH_PRL));
;;;383        WRITE_REG(hrtc->Instance->PRLL, (prescaler & RTC_PRLL_PRL));
;;;384    
;;;385        /* Wait for synchro */
;;;386        if (RTC_ExitInitMode(hrtc) != HAL_OK)
;;;387        {
;;;388          hrtc->State = HAL_RTC_STATE_ERROR;
;;;389    
;;;390          return HAL_ERROR;
;;;391        }
;;;392    
;;;393        /* Initialize date to 1st of January 2000 */
;;;394        hrtc->DateToUpdate.Year = 0x00U;
;;;395        hrtc->DateToUpdate.Month = RTC_MONTH_JANUARY;
;;;396        hrtc->DateToUpdate.Date = 0x01U;
;;;397    
;;;398        /* Set RTC state */
;;;399        hrtc->State = HAL_RTC_STATE_READY;
;;;400    
;;;401        return HAL_OK;
;;;402      }
;;;403    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  7426              STRB     r6,[r4,#0x10]         ;315
000016  4620              MOV      r0,r4                 ;318
000018  f7fffffe          BL       HAL_RTC_MspInit
                  |L9.28|
00001c  2002              MOVS     r0,#2                 ;323
00001e  7460              STRB     r0,[r4,#0x11]         ;323
000020  4620              MOV      r0,r4                 ;326
000022  f7fffffe          BL       HAL_RTC_WaitForSynchro
000026  2504              MOVS     r5,#4                 ;329
000028  b110              CBZ      r0,|L9.48|
00002a  7465              STRB     r5,[r4,#0x11]         ;329
00002c  2001              MOVS     r0,#1                 ;331
00002e  bd70              POP      {r4-r6,pc}
                  |L9.48|
000030  4620              MOV      r0,r4                 ;335
000032  f7fffffe          BL       RTC_EnterInitMode
000036  b110              CBZ      r0,|L9.62|
000038  7465              STRB     r5,[r4,#0x11]         ;338
00003a  2001              MOVS     r0,#1                 ;340
00003c  bd70              POP      {r4-r6,pc}
                  |L9.62|
00003e  6820              LDR      r0,[r4,#0]            ;345
000040  6841              LDR      r1,[r0,#4]            ;345
000042  f0210107          BIC      r1,r1,#7              ;345
000046  6041              STR      r1,[r0,#4]            ;345
000048  68a0              LDR      r0,[r4,#8]            ;347
00004a  b120              CBZ      r0,|L9.86|
00004c  4816              LDR      r0,|L9.168|
00004e  6801              LDR      r1,[r0,#0]            ;350
000050  f0210101          BIC      r1,r1,#1              ;350
000054  6001              STR      r1,[r0,#0]            ;350
                  |L9.86|
000056  4814              LDR      r0,|L9.168|
000058  1f00              SUBS     r0,r0,#4              ;354
00005a  6801              LDR      r1,[r0,#0]            ;354
00005c  68a2              LDR      r2,[r4,#8]            ;354
00005e  f4217160          BIC      r1,r1,#0x380          ;354
000062  4311              ORRS     r1,r1,r2              ;354
000064  6001              STR      r1,[r0,#0]            ;354
000066  6860              LDR      r0,[r4,#4]            ;356
000068  1c41              ADDS     r1,r0,#1              ;356
00006a  d104              BNE      |L9.118|
00006c  2001              MOVS     r0,#1                 ;365
00006e  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000072  b170              CBZ      r0,|L9.146|
000074  1e40              SUBS     r0,r0,#1              ;377
                  |L9.118|
000076  6822              LDR      r2,[r4,#0]            ;382
000078  f3c04103          UBFX     r1,r0,#16,#4          ;382
00007c  6091              STR      r1,[r2,#8]            ;382
00007e  6821              LDR      r1,[r4,#0]            ;383
000080  b280              UXTH     r0,r0                 ;383
000082  60c8              STR      r0,[r1,#0xc]          ;383
000084  4620              MOV      r0,r4                 ;386
000086  f7fffffe          BL       RTC_ExitInitMode
00008a  b128              CBZ      r0,|L9.152|
00008c  7465              STRB     r5,[r4,#0x11]         ;388
00008e  2001              MOVS     r0,#1                 ;390
000090  bd70              POP      {r4-r6,pc}
                  |L9.146|
000092  7465              STRB     r5,[r4,#0x11]         ;371
000094  2001              MOVS     r0,#1                 ;372
000096  bd70              POP      {r4-r6,pc}
                  |L9.152|
000098  73e6              STRB     r6,[r4,#0xf]          ;394
00009a  2001              MOVS     r0,#1                 ;395
00009c  7360              STRB     r0,[r4,#0xd]          ;395
00009e  73a0              STRB     r0,[r4,#0xe]          ;396
0000a0  7460              STRB     r0,[r4,#0x11]         ;399
0000a2  2000              MOVS     r0,#0                 ;401
0000a4  bd70              POP      {r4-r6,pc}
;;;404    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L9.168|
                          DCD      0x40006c30

                          AREA ||i.HAL_RTC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspDeInit PROC
;;;665      */
;;;666    __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;667    {
;;;668      /* Prevent unused argument(s) compilation warning */
;;;669      UNUSED(hrtc);
;;;670      /* NOTE : This function Should not be modified, when the callback is needed,
;;;671                the HAL_RTC_MspDeInit could be implemented in the user file
;;;672       */
;;;673    }
;;;674    
                          ENDP


                          AREA ||i.HAL_RTC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_RTC_MspInit PROC
;;;650      */
;;;651    __weak void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;652    {
;;;653      /* Prevent unused argument(s) compilation warning */
;;;654      UNUSED(hrtc);
;;;655      /* NOTE : This function Should not be modified, when the callback is needed,
;;;656                the HAL_RTC_MspInit could be implemented in the user file
;;;657       */
;;;658    }
;;;659    
                          ENDP


                          AREA ||i.HAL_RTC_PollForAlarmAEvent||, CODE, READONLY, ALIGN=1

                  HAL_RTC_PollForAlarmAEvent PROC
;;;1452     */
;;;1453   HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;1454   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1455     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;1456   
;;;1457     /* Check input parameters */
;;;1458     if (hrtc == NULL)
00000c  b964              CBNZ     r4,|L12.40|
;;;1459     {
;;;1460       return HAL_ERROR;
00000e  2001              MOVS     r0,#1
;;;1461     }
;;;1462   
;;;1463     while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
;;;1464     {
;;;1465       if (Timeout != HAL_MAX_DELAY)
;;;1466       {
;;;1467         if ((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
;;;1468         {
;;;1469           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1470           return HAL_TIMEOUT;
;;;1471         }
;;;1472       }
;;;1473     }
;;;1474   
;;;1475     /* Clear the Alarm interrupt pending bit */
;;;1476     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1477   
;;;1478     /* Change RTC state */
;;;1479     hrtc->State = HAL_RTC_STATE_READY;
;;;1480   
;;;1481     return HAL_OK;
;;;1482   }
000010  bd70              POP      {r4-r6,pc}
                  |L12.18|
000012  1c68              ADDS     r0,r5,#1              ;1465
000014  d008              BEQ      |L12.40|
000016  b125              CBZ      r5,|L12.34|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b80              SUBS     r0,r0,r6              ;1467
00001e  42a8              CMP      r0,r5                 ;1467
000020  d902              BLS      |L12.40|
                  |L12.34|
000022  2003              MOVS     r0,#3                 ;1469
000024  7460              STRB     r0,[r4,#0x11]         ;1469
000026  bd70              POP      {r4-r6,pc}
                  |L12.40|
000028  6820              LDR      r0,[r4,#0]            ;1463
00002a  6840              LDR      r0,[r0,#4]            ;1463
00002c  0780              LSLS     r0,r0,#30             ;1463
00002e  d5f0              BPL      |L12.18|
000030  6820              LDR      r0,[r4,#0]            ;1476
000032  6841              LDR      r1,[r0,#4]            ;1476
000034  f0210102          BIC      r1,r1,#2              ;1476
000038  6041              STR      r1,[r0,#4]            ;1476
00003a  2001              MOVS     r0,#1                 ;1479
00003c  7460              STRB     r0,[r4,#0x11]         ;1479
00003e  2000              MOVS     r0,#0                 ;1481
000040  bd70              POP      {r4-r6,pc}
;;;1483   
                          ENDP


                          AREA ||i.HAL_RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm PROC
;;;1092     */
;;;1093   HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1094   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;1095     uint32_t counter_alarm = 0U, counter_time;
;;;1096     RTC_TimeTypeDef stime = {0U};
00000a  2600              MOVS     r6,#0
00000c  9600              STR      r6,[sp,#0]
;;;1097   
;;;1098     /* Check input parameters */
;;;1099     if ((hrtc == NULL) || (sAlarm == NULL))
00000e  2c00              CMP      r4,#0
000010  d010              BEQ      |L13.52|
000012  b17d              CBZ      r5,|L13.52|
;;;1100     {
;;;1101       return HAL_ERROR;
;;;1102     }
;;;1103   
;;;1104     /* Check the parameters */
;;;1105     assert_param(IS_RTC_FORMAT(Format));
;;;1106     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1107   
;;;1108     /* Process Locked */
;;;1109     __HAL_LOCK(hrtc);
000014  7c20              LDRB     r0,[r4,#0x10]
000016  2801              CMP      r0,#1
000018  d00e              BEQ      |L13.56|
00001a  2701              MOVS     r7,#1
00001c  7427              STRB     r7,[r4,#0x10]
;;;1110   
;;;1111     hrtc->State = HAL_RTC_STATE_BUSY;
00001e  2002              MOVS     r0,#2
000020  7460              STRB     r0,[r4,#0x11]
;;;1112   
;;;1113     /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;1114     if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
000022  2200              MOVS     r2,#0
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_RTC_GetTime
00002c  b130              CBZ      r0,|L13.60|
;;;1115     {
;;;1116       return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L13.48|
;;;1117     }
;;;1118   
;;;1119     /* Convert time in seconds */
;;;1120     counter_time = (uint32_t)(((uint32_t)stime.Hours * 3600U) + \
;;;1121                               ((uint32_t)stime.Minutes * 60U) + \
;;;1122                               ((uint32_t)stime.Seconds));
;;;1123   
;;;1124     if (Format == RTC_FORMAT_BIN)
;;;1125     {
;;;1126       assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1127       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1128       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1129   
;;;1130       counter_alarm = (uint32_t)(((uint32_t)sAlarm->AlarmTime.Hours * 3600U) + \
;;;1131                                  ((uint32_t)sAlarm->AlarmTime.Minutes * 60U) + \
;;;1132                                  ((uint32_t)sAlarm->AlarmTime.Seconds));
;;;1133     }
;;;1134     else
;;;1135     {
;;;1136       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1137       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1138       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1139   
;;;1140       counter_alarm = (((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)) * 3600U) + \
;;;1141                        ((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)) * 60U) + \
;;;1142                        ((uint32_t)RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1143     }
;;;1144   
;;;1145     /* Check that requested alarm should expire in the same day (otherwise add 1 day) */
;;;1146     if (counter_alarm < counter_time)
;;;1147     {
;;;1148       /* Add 1 day to alarm counter*/
;;;1149       counter_alarm += (uint32_t)(24U * 3600U);
;;;1150     }
;;;1151   
;;;1152     /* Write Alarm counter in RTC registers */
;;;1153     if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;1154     {
;;;1155       /* Set RTC state */
;;;1156       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1157   
;;;1158       /* Process Unlocked */
;;;1159       __HAL_UNLOCK(hrtc);
;;;1160   
;;;1161       return HAL_ERROR;
;;;1162     }
;;;1163     else
;;;1164     {
;;;1165       hrtc->State = HAL_RTC_STATE_READY;
;;;1166   
;;;1167       __HAL_UNLOCK(hrtc);
;;;1168   
;;;1169       return HAL_OK;
;;;1170     }
;;;1171   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L13.52|
000034  2001              MOVS     r0,#1                 ;1101
000036  e7fb              B        |L13.48|
                  |L13.56|
000038  2002              MOVS     r0,#2                 ;1109
00003a  e7f9              B        |L13.48|
                  |L13.60|
00003c  f89d1000          LDRB     r1,[sp,#0]            ;1120
000040  f44f6061          MOV      r0,#0xe10             ;1120
000044  4341              MULS     r1,r0,r1              ;1120
000046  f89d0001          LDRB     r0,[sp,#1]            ;1120
00004a  ebc01000          RSB      r0,r0,r0,LSL #4       ;1120
00004e  eb010080          ADD      r0,r1,r0,LSL #2       ;1120
000052  f89d1002          LDRB     r1,[sp,#2]            ;1120
000056  eb000801          ADD      r8,r0,r1              ;1120
00005a  f1b90f00          CMP      r9,#0                 ;1124
00005e  d01f              BEQ      |L13.160|
000060  7828              LDRB     r0,[r5,#0]            ;1140
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  f44f6161          MOV      r1,#0xe10             ;1140
00006a  fb00f901          MUL      r9,r0,r1              ;1140
00006e  7868              LDRB     r0,[r5,#1]            ;1140
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  ebc01000          RSB      r0,r0,r0,LSL #4       ;1140
000078  eb090980          ADD      r9,r9,r0,LSL #2       ;1140
00007c  78a8              LDRB     r0,[r5,#2]            ;1140
00007e  f7fffffe          BL       RTC_Bcd2ToByte
000082  eb090100          ADD      r1,r9,r0              ;1140
                  |L13.134|
000086  4541              CMP      r1,r8                 ;1146
000088  d201              BCS      |L13.142|
00008a  480d              LDR      r0,|L13.192|
00008c  4401              ADD      r1,r1,r0              ;1149
                  |L13.142|
00008e  4620              MOV      r0,r4                 ;1153
000090  f7fffffe          BL       RTC_WriteAlarmCounter
000094  b180              CBZ      r0,|L13.184|
000096  2004              MOVS     r0,#4                 ;1156
000098  7460              STRB     r0,[r4,#0x11]         ;1156
00009a  7426              STRB     r6,[r4,#0x10]         ;1159
00009c  2001              MOVS     r0,#1                 ;1161
00009e  e7c7              B        |L13.48|
                  |L13.160|
0000a0  7829              LDRB     r1,[r5,#0]            ;1130
0000a2  f44f6061          MOV      r0,#0xe10             ;1130
0000a6  4341              MULS     r1,r0,r1              ;1130
0000a8  7868              LDRB     r0,[r5,#1]            ;1130
0000aa  ebc01000          RSB      r0,r0,r0,LSL #4       ;1130
0000ae  eb010080          ADD      r0,r1,r0,LSL #2       ;1130
0000b2  78a9              LDRB     r1,[r5,#2]            ;1130
0000b4  4401              ADD      r1,r1,r0              ;1130
0000b6  e7e6              B        |L13.134|
                  |L13.184|
0000b8  7467              STRB     r7,[r4,#0x11]         ;1165
0000ba  7426              STRB     r6,[r4,#0x10]         ;1167
0000bc  2000              MOVS     r0,#0                 ;1169
0000be  e7b7              B        |L13.48|
;;;1172   
                          ENDP

                  |L13.192|
                          DCD      0x00015180

                          AREA ||i.HAL_RTC_SetAlarm_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetAlarm_IT PROC
;;;1184     */
;;;1185   HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1186   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;1187     uint32_t counter_alarm = 0U, counter_time;
;;;1188     RTC_TimeTypeDef stime = {0U};
00000a  2600              MOVS     r6,#0
00000c  9600              STR      r6,[sp,#0]
;;;1189   
;;;1190     /* Check input parameters */
;;;1191     if ((hrtc == NULL) || (sAlarm == NULL))
00000e  2c00              CMP      r4,#0
000010  d010              BEQ      |L14.52|
000012  b17d              CBZ      r5,|L14.52|
;;;1192     {
;;;1193       return HAL_ERROR;
;;;1194     }
;;;1195   
;;;1196     /* Check the parameters */
;;;1197     assert_param(IS_RTC_FORMAT(Format));
;;;1198     assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;1199   
;;;1200     /* Process Locked */
;;;1201     __HAL_LOCK(hrtc);
000014  7c20              LDRB     r0,[r4,#0x10]
000016  2801              CMP      r0,#1
000018  d00e              BEQ      |L14.56|
00001a  2701              MOVS     r7,#1
00001c  7427              STRB     r7,[r4,#0x10]
;;;1202   
;;;1203     hrtc->State = HAL_RTC_STATE_BUSY;
00001e  2002              MOVS     r0,#2
000020  7460              STRB     r0,[r4,#0x11]
;;;1204   
;;;1205     /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;1206     if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
000022  2200              MOVS     r2,#0
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_RTC_GetTime
00002c  b130              CBZ      r0,|L14.60|
;;;1207     {
;;;1208       return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L14.48|
;;;1209     }
;;;1210   
;;;1211     /* Convert time in seconds */
;;;1212     counter_time = (uint32_t)(((uint32_t)stime.Hours * 3600U) + \
;;;1213                               ((uint32_t)stime.Minutes * 60U) + \
;;;1214                               ((uint32_t)stime.Seconds));
;;;1215   
;;;1216     if (Format == RTC_FORMAT_BIN)
;;;1217     {
;;;1218       assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;1219       assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;1220       assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;1221   
;;;1222       counter_alarm = (uint32_t)(((uint32_t)sAlarm->AlarmTime.Hours * 3600U) + \
;;;1223                                  ((uint32_t)sAlarm->AlarmTime.Minutes * 60U) + \
;;;1224                                  ((uint32_t)sAlarm->AlarmTime.Seconds));
;;;1225     }
;;;1226     else
;;;1227     {
;;;1228       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1229       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1230       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1231   
;;;1232       counter_alarm = (((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)) * 3600U) + \
;;;1233                        ((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)) * 60U) + \
;;;1234                        ((uint32_t)RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1235     }
;;;1236   
;;;1237     /* Check that requested alarm should expire in the same day (otherwise add 1 day) */
;;;1238     if (counter_alarm < counter_time)
;;;1239     {
;;;1240       /* Add 1 day to alarm counter*/
;;;1241       counter_alarm += (uint32_t)(24U * 3600U);
;;;1242     }
;;;1243   
;;;1244     /* Write alarm counter in RTC registers */
;;;1245     if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;1246     {
;;;1247       /* Set RTC state */
;;;1248       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1249   
;;;1250       /* Process Unlocked */
;;;1251       __HAL_UNLOCK(hrtc);
;;;1252   
;;;1253       return HAL_ERROR;
;;;1254     }
;;;1255     else
;;;1256     {
;;;1257       /* Clear flag alarm A */
;;;1258       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1259   
;;;1260       /* Configure the Alarm interrupt */
;;;1261       __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
;;;1262   
;;;1263       /* RTC Alarm Interrupt Configuration: EXTI configuration */
;;;1264       __HAL_RTC_ALARM_EXTI_ENABLE_IT();
;;;1265   
;;;1266       __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
;;;1267   
;;;1268       hrtc->State = HAL_RTC_STATE_READY;
;;;1269   
;;;1270       __HAL_UNLOCK(hrtc);
;;;1271   
;;;1272       return HAL_OK;
;;;1273     }
;;;1274   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L14.52|
000034  2001              MOVS     r0,#1                 ;1193
000036  e7fb              B        |L14.48|
                  |L14.56|
000038  2002              MOVS     r0,#2                 ;1201
00003a  e7f9              B        |L14.48|
                  |L14.60|
00003c  f89d1000          LDRB     r1,[sp,#0]            ;1212
000040  f44f6061          MOV      r0,#0xe10             ;1212
000044  4341              MULS     r1,r0,r1              ;1212
000046  f89d0001          LDRB     r0,[sp,#1]            ;1212
00004a  ebc01000          RSB      r0,r0,r0,LSL #4       ;1212
00004e  eb010080          ADD      r0,r1,r0,LSL #2       ;1212
000052  f89d1002          LDRB     r1,[sp,#2]            ;1212
000056  eb000801          ADD      r8,r0,r1              ;1212
00005a  f1b90f00          CMP      r9,#0                 ;1216
00005e  d01f              BEQ      |L14.160|
000060  7828              LDRB     r0,[r5,#0]            ;1232
000062  f7fffffe          BL       RTC_Bcd2ToByte
000066  f44f6161          MOV      r1,#0xe10             ;1232
00006a  fb00f901          MUL      r9,r0,r1              ;1232
00006e  7868              LDRB     r0,[r5,#1]            ;1232
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  ebc01000          RSB      r0,r0,r0,LSL #4       ;1232
000078  eb090980          ADD      r9,r9,r0,LSL #2       ;1232
00007c  78a8              LDRB     r0,[r5,#2]            ;1232
00007e  f7fffffe          BL       RTC_Bcd2ToByte
000082  eb090100          ADD      r1,r9,r0              ;1232
                  |L14.134|
000086  4541              CMP      r1,r8                 ;1238
000088  d201              BCS      |L14.142|
00008a  4818              LDR      r0,|L14.236|
00008c  4401              ADD      r1,r1,r0              ;1241
                  |L14.142|
00008e  4620              MOV      r0,r4                 ;1245
000090  f7fffffe          BL       RTC_WriteAlarmCounter
000094  b180              CBZ      r0,|L14.184|
000096  2004              MOVS     r0,#4                 ;1248
000098  7460              STRB     r0,[r4,#0x11]         ;1248
00009a  7426              STRB     r6,[r4,#0x10]         ;1251
00009c  2001              MOVS     r0,#1                 ;1253
00009e  e7c7              B        |L14.48|
                  |L14.160|
0000a0  7829              LDRB     r1,[r5,#0]            ;1222
0000a2  f44f6061          MOV      r0,#0xe10             ;1222
0000a6  4341              MULS     r1,r0,r1              ;1222
0000a8  7868              LDRB     r0,[r5,#1]            ;1222
0000aa  ebc01000          RSB      r0,r0,r0,LSL #4       ;1222
0000ae  eb010080          ADD      r0,r1,r0,LSL #2       ;1222
0000b2  78a9              LDRB     r1,[r5,#2]            ;1222
0000b4  4401              ADD      r1,r1,r0              ;1222
0000b6  e7e6              B        |L14.134|
                  |L14.184|
0000b8  6820              LDR      r0,[r4,#0]            ;1258
0000ba  6841              LDR      r1,[r0,#4]            ;1258
0000bc  f0210102          BIC      r1,r1,#2              ;1258
0000c0  6041              STR      r1,[r0,#4]            ;1258
0000c2  6820              LDR      r0,[r4,#0]            ;1261
0000c4  6801              LDR      r1,[r0,#0]            ;1261
0000c6  f0410102          ORR      r1,r1,#2              ;1261
0000ca  6001              STR      r1,[r0,#0]            ;1261
0000cc  4808              LDR      r0,|L14.240|
0000ce  6801              LDR      r1,[r0,#0]            ;1264
0000d0  f4413100          ORR      r1,r1,#0x20000        ;1264
0000d4  6001              STR      r1,[r0,#0]            ;1264
0000d6  4806              LDR      r0,|L14.240|
0000d8  3008              ADDS     r0,r0,#8              ;1266
0000da  6801              LDR      r1,[r0,#0]            ;1266
0000dc  f4413100          ORR      r1,r1,#0x20000        ;1266
0000e0  6001              STR      r1,[r0,#0]            ;1266
0000e2  7467              STRB     r7,[r4,#0x11]         ;1268
0000e4  7426              STRB     r6,[r4,#0x10]         ;1270
0000e6  2000              MOVS     r0,#0                 ;1272
0000e8  e7a2              B        |L14.48|
;;;1275   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L14.236|
                          DCD      0x00015180
                  |L14.240|
                          DCD      0x40010400

                          AREA ||i.HAL_RTC_SetDate||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetDate PROC
;;;913      */
;;;914    HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;915    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;916      uint32_t counter_time = 0U, counter_alarm = 0U, hours = 0U;
;;;917    
;;;918      /* Check input parameters */
;;;919      if ((hrtc == NULL) || (sDate == NULL))
000008  2c00              CMP      r4,#0
00000a  d03f              BEQ      |L15.140|
00000c  b3e5              CBZ      r5,|L15.136|
;;;920      {
;;;921        return HAL_ERROR;
;;;922      }
;;;923    
;;;924      /* Check the parameters */
;;;925      assert_param(IS_RTC_FORMAT(Format));
;;;926    
;;;927      /* Process Locked */
;;;928      __HAL_LOCK(hrtc);
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  2801              CMP      r0,#1
000012  d03d              BEQ      |L15.144|
000014  2601              MOVS     r6,#1
000016  7426              STRB     r6,[r4,#0x10]
;;;929    
;;;930      hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  7460              STRB     r0,[r4,#0x11]
00001c  b3aa              CBZ      r2,|L15.138|
;;;931    
;;;932      if (Format == RTC_FORMAT_BIN)
;;;933      {
;;;934        assert_param(IS_RTC_YEAR(sDate->Year));
;;;935        assert_param(IS_RTC_MONTH(sDate->Month));
;;;936        assert_param(IS_RTC_DATE(sDate->Date));
;;;937    
;;;938        /* Change the current date */
;;;939        hrtc->DateToUpdate.Year  = sDate->Year;
;;;940        hrtc->DateToUpdate.Month = sDate->Month;
;;;941        hrtc->DateToUpdate.Date  = sDate->Date;
;;;942      }
;;;943      else
;;;944      {
;;;945        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
;;;946        assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
;;;947        assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
;;;948    
;;;949        /* Change the current date */
;;;950        hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
00001e  78e8              LDRB     r0,[r5,#3]
000020  f7fffffe          BL       RTC_Bcd2ToByte
000024  73e0              STRB     r0,[r4,#0xf]
;;;951        hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
000026  7868              LDRB     r0,[r5,#1]
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  7360              STRB     r0,[r4,#0xd]
;;;952        hrtc->DateToUpdate.Date  = RTC_Bcd2ToByte(sDate->Date);
00002e  78a8              LDRB     r0,[r5,#2]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  73a0              STRB     r0,[r4,#0xe]
                  |L15.54|
;;;953      }
;;;954    
;;;955      /* WeekDay set by user can be ignored because automatically calculated */
;;;956      hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(hrtc->DateToUpdate.Year, hrtc->DateToUpdate.Month, hrtc->DateToUpdate.Date);
000036  7ba2              LDRB     r2,[r4,#0xe]
000038  7b61              LDRB     r1,[r4,#0xd]
00003a  7be0              LDRB     r0,[r4,#0xf]
00003c  f7fffffe          BL       RTC_WeekDayNum
000040  7320              STRB     r0,[r4,#0xc]
;;;957      sDate->WeekDay = hrtc->DateToUpdate.WeekDay;
000042  7028              STRB     r0,[r5,#0]
;;;958    
;;;959      /* Reset time to be aligned on the same day */
;;;960      /* Read the time counter*/
;;;961      counter_time = RTC_ReadTimeCounter(hrtc);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RTC_ReadTimeCounter
;;;962    
;;;963      /* Fill the structure fields with the read parameters */
;;;964      hours = counter_time / 3600U;
00004a  f44f6161          MOV      r1,#0xe10
00004e  fbb0f1f1          UDIV     r1,r0,r1
;;;965      if (hours > 24U)
000052  2500              MOVS     r5,#0
000054  2918              CMP      r1,#0x18
000056  d936              BLS      |L15.198|
;;;966      {
;;;967        /* Set updated time in decreasing counter by number of days elapsed */
;;;968        counter_time -= ((hours / 24U) * 24U * 3600U);
000058  2218              MOVS     r2,#0x18
00005a  fbb1f1f2          UDIV     r1,r1,r2
00005e  eba11101          SUB      r1,r1,r1,LSL #4
000062  eb010141          ADD      r1,r1,r1,LSL #1
000066  ebc11101          RSB      r1,r1,r1,LSL #4
00006a  eb0017c1          ADD      r7,r0,r1,LSL #7
;;;969        /* Write time counter in RTC registers */
;;;970        if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
00006e  4639              MOV      r1,r7
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       RTC_WriteTimeCounter
;;;971        {
;;;972          /* Set RTC state */
;;;973          hrtc->State = HAL_RTC_STATE_ERROR;
000076  f04f0804          MOV      r8,#4
00007a  b190              CBZ      r0,|L15.162|
00007c  f8848011          STRB     r8,[r4,#0x11]
;;;974    
;;;975          /* Process Unlocked */
;;;976          __HAL_UNLOCK(hrtc);
000080  7425              STRB     r5,[r4,#0x10]
;;;977    
;;;978          return HAL_ERROR;
000082  2001              MOVS     r0,#1
                  |L15.132|
;;;979        }
;;;980    
;;;981        /* Read current Alarm counter in RTC registers */
;;;982        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;983    
;;;984        /* Set again alarm to match with new time if enabled */
;;;985        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;986        {
;;;987          if (counter_alarm < counter_time)
;;;988          {
;;;989            /* Add 1 day to alarm counter*/
;;;990            counter_alarm += (uint32_t)(24U * 3600U);
;;;991    
;;;992            /* Write new Alarm counter in RTC registers */
;;;993            if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;994            {
;;;995              /* Set RTC state */
;;;996              hrtc->State = HAL_RTC_STATE_ERROR;
;;;997    
;;;998              /* Process Unlocked */
;;;999              __HAL_UNLOCK(hrtc);
;;;1000   
;;;1001             return HAL_ERROR;
;;;1002           }
;;;1003         }
;;;1004       }
;;;1005   
;;;1006   
;;;1007     }
;;;1008   
;;;1009     hrtc->State = HAL_RTC_STATE_READY ;
;;;1010   
;;;1011     /* Process Unlocked */
;;;1012     __HAL_UNLOCK(hrtc);
;;;1013   
;;;1014     return HAL_OK;
;;;1015   }
000084  e8bd81f0          POP      {r4-r8,pc}
                  |L15.136|
000088  e000              B        |L15.140|
                  |L15.138|
00008a  e003              B        |L15.148|
                  |L15.140|
00008c  2001              MOVS     r0,#1                 ;921
00008e  e7f9              B        |L15.132|
                  |L15.144|
000090  2002              MOVS     r0,#2                 ;928
000092  e7f7              B        |L15.132|
                  |L15.148|
000094  78e8              LDRB     r0,[r5,#3]            ;939
000096  73e0              STRB     r0,[r4,#0xf]          ;939
000098  7868              LDRB     r0,[r5,#1]            ;940
00009a  7360              STRB     r0,[r4,#0xd]          ;940
00009c  78a8              LDRB     r0,[r5,#2]            ;941
00009e  73a0              STRB     r0,[r4,#0xe]          ;941
0000a0  e7c9              B        |L15.54|
                  |L15.162|
0000a2  4620              MOV      r0,r4                 ;982
0000a4  f7fffffe          BL       RTC_ReadAlarmCounter
0000a8  1c41              ADDS     r1,r0,#1              ;985
0000aa  d00c              BEQ      |L15.198|
0000ac  42b8              CMP      r0,r7                 ;987
0000ae  d20a              BCS      |L15.198|
0000b0  4907              LDR      r1,|L15.208|
0000b2  4401              ADD      r1,r1,r0              ;990
0000b4  4620              MOV      r0,r4                 ;993
0000b6  f7fffffe          BL       RTC_WriteAlarmCounter
0000ba  b120              CBZ      r0,|L15.198|
0000bc  f8848011          STRB     r8,[r4,#0x11]         ;996
0000c0  7425              STRB     r5,[r4,#0x10]         ;999
0000c2  2001              MOVS     r0,#1                 ;1001
0000c4  e7de              B        |L15.132|
                  |L15.198|
0000c6  7466              STRB     r6,[r4,#0x11]         ;1009
0000c8  7425              STRB     r5,[r4,#0x10]         ;1012
0000ca  2000              MOVS     r0,#0                 ;1014
0000cc  e7da              B        |L15.132|
;;;1016   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L15.208|
                          DCD      0x00015180

                          AREA ||i.HAL_RTC_SetTime||, CODE, READONLY, ALIGN=2

                  HAL_RTC_SetTime PROC
;;;703      */
;;;704    HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;705    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;706      uint32_t counter_time = 0U, counter_alarm = 0U;
;;;707    
;;;708      /* Check input parameters */
;;;709      if ((hrtc == NULL) || (sTime == NULL))
000008  2c00              CMP      r4,#0
00000a  d028              BEQ      |L16.94|
00000c  b33d              CBZ      r5,|L16.94|
;;;710      {
;;;711        return HAL_ERROR;
;;;712      }
;;;713    
;;;714      /* Check the parameters */
;;;715      assert_param(IS_RTC_FORMAT(Format));
;;;716    
;;;717      /* Process Locked */
;;;718      __HAL_LOCK(hrtc);
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  2801              CMP      r0,#1
000012  d026              BEQ      |L16.98|
000014  2601              MOVS     r6,#1
000016  7426              STRB     r6,[r4,#0x10]
;;;719    
;;;720      hrtc->State = HAL_RTC_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  7460              STRB     r0,[r4,#0x11]
00001c  b31a              CBZ      r2,|L16.102|
;;;721    
;;;722      if (Format == RTC_FORMAT_BIN)
;;;723      {
;;;724        assert_param(IS_RTC_HOUR24(sTime->Hours));
;;;725        assert_param(IS_RTC_MINUTES(sTime->Minutes));
;;;726        assert_param(IS_RTC_SECONDS(sTime->Seconds));
;;;727    
;;;728        counter_time = (uint32_t)(((uint32_t)sTime->Hours * 3600U) + \
;;;729                                  ((uint32_t)sTime->Minutes * 60U) + \
;;;730                                  ((uint32_t)sTime->Seconds));
;;;731      }
;;;732      else
;;;733      {
;;;734        assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
;;;735        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
;;;736        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
;;;737    
;;;738        counter_time = (((uint32_t)(RTC_Bcd2ToByte(sTime->Hours)) * 3600U) + \
00001e  7828              LDRB     r0,[r5,#0]
000020  f7fffffe          BL       RTC_Bcd2ToByte
000024  f44f6161          MOV      r1,#0xe10
000028  fb00f701          MUL      r7,r0,r1
00002c  7868              LDRB     r0,[r5,#1]
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  ebc01000          RSB      r0,r0,r0,LSL #4
000036  eb070780          ADD      r7,r7,r0,LSL #2
00003a  78a8              LDRB     r0,[r5,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  183d              ADDS     r5,r7,r0
                  |L16.66|
;;;739                        ((uint32_t)(RTC_Bcd2ToByte(sTime->Minutes)) * 60U) + \
;;;740                        ((uint32_t)(RTC_Bcd2ToByte(sTime->Seconds))));
;;;741      }
;;;742    
;;;743      /* Write time counter in RTC registers */
;;;744      if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
000042  4629              MOV      r1,r5
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RTC_WriteTimeCounter
00004a  2700              MOVS     r7,#0
;;;745      {
;;;746        /* Set RTC state */
;;;747        hrtc->State = HAL_RTC_STATE_ERROR;
00004c  f04f0804          MOV      r8,#4
000050  b1a8              CBZ      r0,|L16.126|
000052  f8848011          STRB     r8,[r4,#0x11]
;;;748    
;;;749        /* Process Unlocked */
;;;750        __HAL_UNLOCK(hrtc);
000056  7427              STRB     r7,[r4,#0x10]
;;;751    
;;;752        return HAL_ERROR;
000058  2001              MOVS     r0,#1
                  |L16.90|
;;;753      }
;;;754      else
;;;755      {
;;;756        /* Clear Second and overflow flags */
;;;757        CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_SEC | RTC_FLAG_OW));
;;;758    
;;;759        /* Read current Alarm counter in RTC registers */
;;;760        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;761    
;;;762        /* Set again alarm to match with new time if enabled */
;;;763        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;764        {
;;;765          if (counter_alarm < counter_time)
;;;766          {
;;;767            /* Add 1 day to alarm counter*/
;;;768            counter_alarm += (uint32_t)(24U * 3600U);
;;;769    
;;;770            /* Write new Alarm counter in RTC registers */
;;;771            if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;772            {
;;;773              /* Set RTC state */
;;;774              hrtc->State = HAL_RTC_STATE_ERROR;
;;;775    
;;;776              /* Process Unlocked */
;;;777              __HAL_UNLOCK(hrtc);
;;;778    
;;;779              return HAL_ERROR;
;;;780            }
;;;781          }
;;;782        }
;;;783    
;;;784        hrtc->State = HAL_RTC_STATE_READY;
;;;785    
;;;786        __HAL_UNLOCK(hrtc);
;;;787    
;;;788        return HAL_OK;
;;;789      }
;;;790    }
00005a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.94|
00005e  2001              MOVS     r0,#1                 ;711
000060  e7fb              B        |L16.90|
                  |L16.98|
000062  2002              MOVS     r0,#2                 ;718
000064  e7f9              B        |L16.90|
                  |L16.102|
000066  7829              LDRB     r1,[r5,#0]            ;728
000068  f44f6061          MOV      r0,#0xe10             ;728
00006c  4341              MULS     r1,r0,r1              ;728
00006e  7868              LDRB     r0,[r5,#1]            ;728
000070  ebc01000          RSB      r0,r0,r0,LSL #4       ;728
000074  eb010080          ADD      r0,r1,r0,LSL #2       ;728
000078  78a9              LDRB     r1,[r5,#2]            ;728
00007a  1845              ADDS     r5,r0,r1              ;728
00007c  e7e1              B        |L16.66|
                  |L16.126|
00007e  6820              LDR      r0,[r4,#0]            ;757
000080  6841              LDR      r1,[r0,#4]            ;757
000082  f0210105          BIC      r1,r1,#5              ;757
000086  6041              STR      r1,[r0,#4]            ;757
000088  4620              MOV      r0,r4                 ;760
00008a  f7fffffe          BL       RTC_ReadAlarmCounter
00008e  1c41              ADDS     r1,r0,#1              ;763
000090  d00c              BEQ      |L16.172|
000092  42a8              CMP      r0,r5                 ;765
000094  d20a              BCS      |L16.172|
000096  4907              LDR      r1,|L16.180|
000098  4401              ADD      r1,r1,r0              ;768
00009a  4620              MOV      r0,r4                 ;771
00009c  f7fffffe          BL       RTC_WriteAlarmCounter
0000a0  b120              CBZ      r0,|L16.172|
0000a2  f8848011          STRB     r8,[r4,#0x11]         ;774
0000a6  7427              STRB     r7,[r4,#0x10]         ;777
0000a8  2001              MOVS     r0,#1                 ;779
0000aa  e7d6              B        |L16.90|
                  |L16.172|
0000ac  7466              STRB     r6,[r4,#0x11]         ;784
0000ae  7427              STRB     r7,[r4,#0x10]         ;786
0000b0  2000              MOVS     r0,#0                 ;788
0000b2  e7d2              B        |L16.90|
;;;791    
                          ENDP

                  |L16.180|
                          DCD      0x00015180

                          AREA ||i.HAL_RTC_WaitForSynchro||, CODE, READONLY, ALIGN=1

                  HAL_RTC_WaitForSynchro PROC
;;;1540     */
;;;1541   HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1542   {
000002  4604              MOV      r4,r0
;;;1543     uint32_t tickstart = 0U;
;;;1544   
;;;1545     /* Check input parameters */
;;;1546     if (hrtc == NULL)
000004  2c00              CMP      r4,#0
000006  d00a              BEQ      |L17.30|
;;;1547     {
;;;1548       return HAL_ERROR;
;;;1549     }
;;;1550   
;;;1551     /* Clear RSF flag */
;;;1552     CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
000008  6820              LDR      r0,[r4,#0]
00000a  6841              LDR      r1,[r0,#4]
00000c  f0210108          BIC      r1,r1,#8
000010  6041              STR      r1,[r0,#4]
;;;1553   
;;;1554     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;1555   
;;;1556     /* Wait the registers to be synchronised */
;;;1557     while ((hrtc->Instance->CRL & RTC_FLAG_RSF) == (uint32_t)RESET)
;;;1558     {
;;;1559       if ((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
000018  f44f767a          MOV      r6,#0x3e8
00001c  e008              B        |L17.48|
                  |L17.30|
00001e  2001              MOVS     r0,#1                 ;1548
;;;1560       {
;;;1561         return HAL_TIMEOUT;
;;;1562       }
;;;1563     }
;;;1564   
;;;1565     return HAL_OK;
;;;1566   }
000020  bd70              POP      {r4-r6,pc}
                  |L17.34|
000022  f7fffffe          BL       HAL_GetTick
000026  1b40              SUBS     r0,r0,r5              ;1559
000028  42b0              CMP      r0,r6                 ;1559
00002a  d901              BLS      |L17.48|
00002c  2003              MOVS     r0,#3                 ;1561
00002e  bd70              POP      {r4-r6,pc}
                  |L17.48|
000030  6820              LDR      r0,[r4,#0]            ;1557
000032  6840              LDR      r0,[r0,#4]            ;1557
000034  0700              LSLS     r0,r0,#28             ;1557
000036  d5f4              BPL      |L17.34|
000038  2000              MOVS     r0,#0                 ;1565
00003a  bd70              POP      {r4-r6,pc}
;;;1567   
                          ENDP


                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;1770     */
;;;1771   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;1772   {
;;;1773     uint32_t tmp = 0U;
;;;1774     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10U;
000002  eb010181          ADD      r1,r1,r1,LSL #2
000006  0049              LSLS     r1,r1,#1
;;;1775     return (tmp + (Value & (uint8_t)0x0F));
000008  f000000f          AND      r0,r0,#0xf
00000c  4408              ADD      r0,r0,r1
00000e  b2c0              UXTB     r0,r0
;;;1776   }
000010  4770              BX       lr
;;;1777   
                          ENDP


                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;1752     */
;;;1753   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;1754   {
000002  e002              B        |L19.10|
                  |L19.4|
;;;1755     uint32_t bcdhigh = 0U;
;;;1756   
;;;1757     while (Value >= 10U)
;;;1758     {
;;;1759       bcdhigh++;
000004  1c49              ADDS     r1,r1,#1
;;;1760       Value -= 10U;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c0              UXTB     r0,r0
                  |L19.10|
00000a  280a              CMP      r0,#0xa               ;1757
00000c  d2fa              BCS      |L19.4|
;;;1761     }
;;;1762   
;;;1763     return ((uint8_t)(bcdhigh << 4U) | Value);
00000e  0709              LSLS     r1,r1,#28
000010  ea406011          ORR      r0,r0,r1,LSR #24
;;;1764   }
000014  4770              BX       lr
;;;1765   
                          ENDP


                          AREA ||i.RTC_DateUpdate||, CODE, READONLY, ALIGN=1

                  RTC_DateUpdate PROC
;;;1784     */
;;;1785   static void RTC_DateUpdate(RTC_HandleTypeDef *hrtc, uint32_t DayElapsed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1786   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1787     uint32_t year = 0U, month = 0U, day = 0U;
;;;1788     uint32_t loop = 0U;
000008  2700              MOVS     r7,#0
;;;1789   
;;;1790     /* Get the current year*/
;;;1791     year = hrtc->DateToUpdate.Year;
00000a  7bf5              LDRB     r5,[r6,#0xf]
;;;1792   
;;;1793     /* Get the current month and day */
;;;1794     month = hrtc->DateToUpdate.Month;
00000c  7b74              LDRB     r4,[r6,#0xd]
;;;1795     day = hrtc->DateToUpdate.Date;
00000e  7bb2              LDRB     r2,[r6,#0xe]
000010  e040              B        |L20.148|
                  |L20.18|
;;;1796   
;;;1797     for (loop = 0U; loop < DayElapsed; loop++)
;;;1798     {
;;;1799       if ((month == 1U) || (month == 3U) || (month == 5U) || (month == 7U) || \
000012  2c01              CMP      r4,#1
000014  d016              BEQ      |L20.68|
000016  2c03              CMP      r4,#3
000018  d014              BEQ      |L20.68|
00001a  2c05              CMP      r4,#5
00001c  d012              BEQ      |L20.68|
00001e  2c07              CMP      r4,#7
000020  d010              BEQ      |L20.68|
;;;1800           (month == 8U) || (month == 10U) || (month == 12U))
000022  2c08              CMP      r4,#8
000024  d00e              BEQ      |L20.68|
000026  2c0a              CMP      r4,#0xa
000028  d00c              BEQ      |L20.68|
00002a  2c0c              CMP      r4,#0xc
00002c  d00a              BEQ      |L20.68|
;;;1801       {
;;;1802         if (day < 31U)
;;;1803         {
;;;1804           day++;
;;;1805         }
;;;1806         /* Date structure member: day = 31 */
;;;1807         else
;;;1808         {
;;;1809           if (month != 12U)
;;;1810           {
;;;1811             month++;
;;;1812             day = 1U;
;;;1813           }
;;;1814           /* Date structure member: day = 31 & month =12 */
;;;1815           else
;;;1816           {
;;;1817             month = 1U;
;;;1818             day = 1U;
;;;1819             year++;
;;;1820           }
;;;1821         }
;;;1822       }
;;;1823       else if ((month == 4U) || (month == 6U) || (month == 9U) || (month == 11U))
00002e  2c04              CMP      r4,#4
000030  d015              BEQ      |L20.94|
000032  2c06              CMP      r4,#6
000034  d013              BEQ      |L20.94|
000036  2c09              CMP      r4,#9
000038  d011              BEQ      |L20.94|
00003a  2c0b              CMP      r4,#0xb
00003c  d00f              BEQ      |L20.94|
;;;1824       {
;;;1825         if (day < 30U)
;;;1826         {
;;;1827           day++;
;;;1828         }
;;;1829         /* Date structure member: day = 30 */
;;;1830         else
;;;1831         {
;;;1832           month++;
;;;1833           day = 1U;
;;;1834         }
;;;1835       }
;;;1836       else if (month == 2U)
00003e  2c02              CMP      r4,#2
000040  d014              BEQ      |L20.108|
000042  e026              B        |L20.146|
                  |L20.68|
000044  2a1f              CMP      r2,#0x1f              ;1802
000046  d201              BCS      |L20.76|
000048  1c52              ADDS     r2,r2,#1              ;1804
00004a  e022              B        |L20.146|
                  |L20.76|
00004c  2c0c              CMP      r4,#0xc               ;1809
00004e  d002              BEQ      |L20.86|
000050  1c64              ADDS     r4,r4,#1              ;1811
000052  2201              MOVS     r2,#1                 ;1812
000054  e01d              B        |L20.146|
                  |L20.86|
000056  2401              MOVS     r4,#1                 ;1817
000058  2201              MOVS     r2,#1                 ;1818
00005a  1c6d              ADDS     r5,r5,#1              ;1819
00005c  e019              B        |L20.146|
                  |L20.94|
00005e  2a1e              CMP      r2,#0x1e              ;1825
000060  d201              BCS      |L20.102|
000062  1c52              ADDS     r2,r2,#1              ;1827
000064  e015              B        |L20.146|
                  |L20.102|
000066  1c64              ADDS     r4,r4,#1              ;1832
000068  2201              MOVS     r2,#1                 ;1833
00006a  e012              B        |L20.146|
                  |L20.108|
;;;1837       {
;;;1838         if (day < 28U)
00006c  2a1c              CMP      r2,#0x1c
00006e  d202              BCS      |L20.118|
;;;1839         {
;;;1840           day++;
000070  f1020201          ADD      r2,r2,#1
000074  e00d              B        |L20.146|
                  |L20.118|
;;;1841         }
;;;1842         else if (day == 28U)
000076  d108              BNE      |L20.138|
;;;1843         {
;;;1844           /* Leap year */
;;;1845           if (RTC_IsLeapYear(year))
000078  b2a8              UXTH     r0,r5
00007a  f7fffffe          BL       RTC_IsLeapYear
00007e  b108              CBZ      r0,|L20.132|
;;;1846           {
;;;1847             day++;
000080  221d              MOVS     r2,#0x1d
000082  e006              B        |L20.146|
                  |L20.132|
;;;1848           }
;;;1849           else
;;;1850           {
;;;1851             month++;
000084  2403              MOVS     r4,#3
;;;1852             day = 1U;
000086  2201              MOVS     r2,#1
000088  e003              B        |L20.146|
                  |L20.138|
;;;1853           }
;;;1854         }
;;;1855         else if (day == 29U)
00008a  2a1d              CMP      r2,#0x1d
00008c  d101              BNE      |L20.146|
;;;1856         {
;;;1857           month++;
00008e  2403              MOVS     r4,#3
;;;1858           day = 1U;
000090  2201              MOVS     r2,#1
                  |L20.146|
000092  1c7f              ADDS     r7,r7,#1              ;1797
                  |L20.148|
000094  4547              CMP      r7,r8                 ;1797
000096  d3bc              BCC      |L20.18|
;;;1859         }
;;;1860       }
;;;1861     }
;;;1862   
;;;1863     /* Update year */
;;;1864     hrtc->DateToUpdate.Year = year;
000098  73f5              STRB     r5,[r6,#0xf]
;;;1865   
;;;1866     /* Update day and month */
;;;1867     hrtc->DateToUpdate.Month = month;
00009a  b2e1              UXTB     r1,r4
00009c  7371              STRB     r1,[r6,#0xd]
;;;1868     hrtc->DateToUpdate.Date = day;
00009e  b2d2              UXTB     r2,r2
0000a0  73b2              STRB     r2,[r6,#0xe]
;;;1869   
;;;1870     /* Update day of the week */
;;;1871     hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(year, month, day);
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       RTC_WeekDayNum
0000a8  7330              STRB     r0,[r6,#0xc]
;;;1872   }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;1873   
                          ENDP


                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=1

                  RTC_EnterInitMode PROC
;;;1700     */
;;;1701   static HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1702   {
000002  4605              MOV      r5,r0
;;;1703     uint32_t tickstart = 0U;
;;;1704   
;;;1705     tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4604              MOV      r4,r0
;;;1706     /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1707     while ((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
;;;1708     {
;;;1709       if ((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
00000a  f44f767a          MOV      r6,#0x3e8
00000e  e006              B        |L21.30|
                  |L21.16|
000010  f7fffffe          BL       HAL_GetTick
000014  1b00              SUBS     r0,r0,r4
000016  42b0              CMP      r0,r6
000018  d901              BLS      |L21.30|
;;;1710       {
;;;1711         return HAL_TIMEOUT;
00001a  2003              MOVS     r0,#3
;;;1712       }
;;;1713     }
;;;1714   
;;;1715     /* Disable the write protection for RTC registers */
;;;1716     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1717   
;;;1718   
;;;1719     return HAL_OK;
;;;1720   }
00001c  bd70              POP      {r4-r6,pc}
                  |L21.30|
00001e  6828              LDR      r0,[r5,#0]            ;1707
000020  6840              LDR      r0,[r0,#4]            ;1707
000022  0680              LSLS     r0,r0,#26             ;1707
000024  d5f4              BPL      |L21.16|
000026  6828              LDR      r0,[r5,#0]            ;1716
000028  6841              LDR      r1,[r0,#4]            ;1716
00002a  f0410110          ORR      r1,r1,#0x10           ;1716
00002e  6041              STR      r1,[r0,#4]            ;1716
000030  2000              MOVS     r0,#0                 ;1719
000032  bd70              POP      {r4-r6,pc}
;;;1721   
                          ENDP


                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=1

                  RTC_ExitInitMode PROC
;;;1727     */
;;;1728   static HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1729   {
000002  4605              MOV      r5,r0
;;;1730     uint32_t tickstart = 0U;
;;;1731   
;;;1732     /* Disable the write protection for RTC registers */
;;;1733     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000004  6828              LDR      r0,[r5,#0]
000006  6841              LDR      r1,[r0,#4]
000008  f0210110          BIC      r1,r1,#0x10
00000c  6041              STR      r1,[r0,#4]
;;;1734   
;;;1735     tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4604              MOV      r4,r0
;;;1736     /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1737     while ((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
;;;1738     {
;;;1739       if ((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
000014  f44f767a          MOV      r6,#0x3e8
000018  e006              B        |L22.40|
                  |L22.26|
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b00              SUBS     r0,r0,r4
000020  42b0              CMP      r0,r6
000022  d901              BLS      |L22.40|
;;;1740       {
;;;1741         return HAL_TIMEOUT;
000024  2003              MOVS     r0,#3
;;;1742       }
;;;1743     }
;;;1744   
;;;1745     return HAL_OK;
;;;1746   }
000026  bd70              POP      {r4-r6,pc}
                  |L22.40|
000028  6828              LDR      r0,[r5,#0]            ;1737
00002a  6840              LDR      r0,[r0,#4]            ;1737
00002c  0680              LSLS     r0,r0,#26             ;1737
00002e  d5f4              BPL      |L22.26|
000030  2000              MOVS     r0,#0                 ;1745
000032  bd70              POP      {r4-r6,pc}
;;;1747   
                          ENDP


                          AREA ||i.RTC_IsLeapYear||, CODE, READONLY, ALIGN=1

                  RTC_IsLeapYear PROC
;;;1879     */
;;;1880   static uint8_t RTC_IsLeapYear(uint16_t nYear)
000000  0781              LSLS     r1,r0,#30
;;;1881   {
000002  d001              BEQ      |L23.8|
;;;1882     if ((nYear % 4U) != 0U)
;;;1883     {
;;;1884       return 0U;
000004  2000              MOVS     r0,#0
;;;1885     }
;;;1886   
;;;1887     if ((nYear % 100U) != 0U)
;;;1888     {
;;;1889       return 1U;
;;;1890     }
;;;1891   
;;;1892     if ((nYear % 400U) == 0U)
;;;1893     {
;;;1894       return 1U;
;;;1895     }
;;;1896     else
;;;1897     {
;;;1898       return 0U;
;;;1899     }
;;;1900   }
000006  4770              BX       lr
                  |L23.8|
000008  2164              MOVS     r1,#0x64              ;1887
00000a  fbb0f2f1          UDIV     r2,r0,r1              ;1887
00000e  fb010112          MLS      r1,r1,r2,r0           ;1887
000012  b109              CBZ      r1,|L23.24|
000014  2001              MOVS     r0,#1                 ;1889
000016  4770              BX       lr
                  |L23.24|
000018  f44f71c8          MOV      r1,#0x190             ;1892
00001c  fbb0f2f1          UDIV     r2,r0,r1              ;1892
000020  fb010012          MLS      r0,r1,r2,r0           ;1892
000024  b108              CBZ      r0,|L23.42|
000026  2000              MOVS     r0,#0                 ;1898
000028  4770              BX       lr
                  |L23.42|
00002a  2001              MOVS     r0,#1                 ;1894
00002c  4770              BX       lr
;;;1901   
                          ENDP


                          AREA ||i.RTC_ReadAlarmCounter||, CODE, READONLY, ALIGN=1

                  RTC_ReadAlarmCounter PROC
;;;1651     */
;;;1652   static uint32_t RTC_ReadAlarmCounter(RTC_HandleTypeDef *hrtc)
000000  6800              LDR      r0,[r0,#0]
;;;1653   {
;;;1654     uint16_t high1 = 0U, low = 0U;
;;;1655   
;;;1656     high1 = READ_REG(hrtc->Instance->ALRH & RTC_CNTH_RTC_CNT);
000002  6a01              LDR      r1,[r0,#0x20]
;;;1657     low   = READ_REG(hrtc->Instance->ALRL & RTC_CNTL_RTC_CNT);
000004  6a40              LDR      r0,[r0,#0x24]
000006  b280              UXTH     r0,r0
;;;1658   
;;;1659     return (((uint32_t) high1 << 16U) | low);
000008  ea404001          ORR      r0,r0,r1,LSL #16
;;;1660   }
00000c  4770              BX       lr
;;;1661   
                          ENDP


                          AREA ||i.RTC_ReadTimeCounter||, CODE, READONLY, ALIGN=1

                  RTC_ReadTimeCounter PROC
;;;1587     */
;;;1588   static uint32_t RTC_ReadTimeCounter(RTC_HandleTypeDef *hrtc)
000000  6800              LDR      r0,[r0,#0]
;;;1589   {
;;;1590     uint16_t high1 = 0U, high2 = 0U, low = 0U;
;;;1591     uint32_t timecounter = 0U;
;;;1592   
;;;1593     high1 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
000002  6981              LDR      r1,[r0,#0x18]
000004  b289              UXTH     r1,r1
;;;1594     low   = READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT);
000006  69c2              LDR      r2,[r0,#0x1c]
000008  b293              UXTH     r3,r2
;;;1595     high2 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
00000a  6982              LDR      r2,[r0,#0x18]
00000c  b292              UXTH     r2,r2
;;;1596   
;;;1597     if (high1 != high2)
00000e  4291              CMP      r1,r2
000010  d003              BEQ      |L25.26|
;;;1598     {
;;;1599       /* In this case the counter roll over during reading of CNTL and CNTH registers,
;;;1600          read again CNTL register then return the counter value */
;;;1601       timecounter = (((uint32_t) high2 << 16U) | READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT));
000012  69c0              LDR      r0,[r0,#0x1c]
000014  f362401f          BFI      r0,r2,#16,#16
;;;1602     }
;;;1603     else
;;;1604     {
;;;1605       /* No counter roll over during reading of CNTL and CNTH registers, counter
;;;1606          value is equal to first value of CNTL and CNTH */
;;;1607       timecounter = (((uint32_t) high1 << 16U) | low);
;;;1608     }
;;;1609   
;;;1610     return timecounter;
;;;1611   }
000018  4770              BX       lr
                  |L25.26|
00001a  ea434001          ORR      r0,r3,r1,LSL #16      ;1607
00001e  4770              BX       lr
;;;1612   
                          ENDP


                          AREA ||i.RTC_WeekDayNum||, CODE, READONLY, ALIGN=1

                  RTC_WeekDayNum PROC
;;;1916     */
;;;1917   static uint8_t RTC_WeekDayNum(uint32_t nYear, uint8_t nMonth, uint8_t nDay)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1918   {
;;;1919     uint32_t year = 0U, weekday = 0U;
;;;1920   
;;;1921     year = 2000U + nYear;
000002  f50060fa          ADD      r0,r0,#0x7d0
;;;1922   
;;;1923     if (nMonth < 3U)
;;;1924     {
;;;1925       /*D = { [(23 x month)/9] + day + 4 + year + [(year-1)/4] - [(year-1)/100] + [(year-1)/400] } mod 7*/
;;;1926       weekday = (((23U * nMonth) / 9U) + nDay + 4U + year + ((year - 1U) / 4U) - ((year - 1U) / 100U) + ((year - 1U) / 400U)) % 7U;
000006  2764              MOVS     r7,#0x64
000008  ebc103c1          RSB      r3,r1,r1,LSL #3
00000c  2509              MOVS     r5,#9
00000e  00be              LSLS     r6,r7,#2
000010  2407              MOVS     r4,#7
000012  eb031301          ADD      r3,r3,r1,LSL #4
000016  2903              CMP      r1,#3                 ;1923
000018  d212              BCS      |L26.64|
00001a  fbb3f1f5          UDIV     r1,r3,r5
00001e  4411              ADD      r1,r1,r2
000020  4401              ADD      r1,r1,r0
000022  1e40              SUBS     r0,r0,#1
000024  fbb0f2f7          UDIV     r2,r0,r7
000028  eb010190          ADD      r1,r1,r0,LSR #2
00002c  fbb0f0f6          UDIV     r0,r0,r6
000030  1a89              SUBS     r1,r1,r2
000032  4408              ADD      r0,r0,r1
000034  1d00              ADDS     r0,r0,#4
000036  fbb0f1f4          UDIV     r1,r0,r4
00003a  fb040011          MLS      r0,r4,r1,r0
00003e  e010              B        |L26.98|
                  |L26.64|
;;;1927     }
;;;1928     else
;;;1929     {
;;;1930       /*D = { [(23 x month)/9] + day + 4 + year + [year/4] - [year/100] + [year/400] - 2 } mod 7*/
;;;1931       weekday = (((23U * nMonth) / 9U) + nDay + 4U + year + (year / 4U) - (year / 100U) + (year / 400U) - 2U) % 7U;
000040  fbb3f1f5          UDIV     r1,r3,r5
000044  4411              ADD      r1,r1,r2
000046  fbb0f2f7          UDIV     r2,r0,r7
00004a  4401              ADD      r1,r1,r0
00004c  eb010190          ADD      r1,r1,r0,LSR #2
000050  fbb0f0f6          UDIV     r0,r0,r6
000054  1a89              SUBS     r1,r1,r2
000056  4408              ADD      r0,r0,r1
000058  1c80              ADDS     r0,r0,#2
00005a  fbb0f1f4          UDIV     r1,r0,r4
00005e  fb040011          MLS      r0,r4,r1,r0
                  |L26.98|
;;;1932     }
;;;1933   
;;;1934     return (uint8_t)weekday;
000062  b2c0              UXTB     r0,r0
;;;1935   }
000064  bdf0              POP      {r4-r7,pc}
;;;1936   
                          ENDP


                          AREA ||i.RTC_WriteAlarmCounter||, CODE, READONLY, ALIGN=1

                  RTC_WriteAlarmCounter PROC
;;;1668     */
;;;1669   static HAL_StatusTypeDef RTC_WriteAlarmCounter(RTC_HandleTypeDef *hrtc, uint32_t AlarmCounter)
000000  b570              PUSH     {r4-r6,lr}
;;;1670   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1671     HAL_StatusTypeDef status = HAL_OK;
000006  2400              MOVS     r4,#0
;;;1672   
;;;1673     /* Set Initialization mode */
;;;1674     if (RTC_EnterInitMode(hrtc) != HAL_OK)
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       RTC_EnterInitMode
00000e  b108              CBZ      r0,|L27.20|
;;;1675     {
;;;1676       status = HAL_ERROR;
000010  2401              MOVS     r4,#1
000012  e00a              B        |L27.42|
                  |L27.20|
;;;1677     }
;;;1678     else
;;;1679     {
;;;1680       /* Set RTC COUNTER MSB word */
;;;1681       WRITE_REG(hrtc->Instance->ALRH, (AlarmCounter >> 16U));
000014  6829              LDR      r1,[r5,#0]
000016  0c30              LSRS     r0,r6,#16
000018  6208              STR      r0,[r1,#0x20]
;;;1682       /* Set RTC COUNTER LSB word */
;;;1683       WRITE_REG(hrtc->Instance->ALRL, (AlarmCounter & RTC_ALRL_RTC_ALR));
00001a  6829              LDR      r1,[r5,#0]
00001c  b2b0              UXTH     r0,r6
00001e  6248              STR      r0,[r1,#0x24]
;;;1684   
;;;1685       /* Wait for synchro */
;;;1686       if (RTC_ExitInitMode(hrtc) != HAL_OK)
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       RTC_ExitInitMode
000026  b100              CBZ      r0,|L27.42|
;;;1687       {
;;;1688         status = HAL_ERROR;
000028  2401              MOVS     r4,#1
                  |L27.42|
;;;1689       }
;;;1690     }
;;;1691   
;;;1692     return status;
00002a  4620              MOV      r0,r4
;;;1693   }
00002c  bd70              POP      {r4-r6,pc}
;;;1694   
                          ENDP


                          AREA ||i.RTC_WriteTimeCounter||, CODE, READONLY, ALIGN=1

                  RTC_WriteTimeCounter PROC
;;;1619     */
;;;1620   static HAL_StatusTypeDef RTC_WriteTimeCounter(RTC_HandleTypeDef *hrtc, uint32_t TimeCounter)
000000  b570              PUSH     {r4-r6,lr}
;;;1621   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1622     HAL_StatusTypeDef status = HAL_OK;
000006  2400              MOVS     r4,#0
;;;1623   
;;;1624     /* Set Initialization mode */
;;;1625     if (RTC_EnterInitMode(hrtc) != HAL_OK)
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       RTC_EnterInitMode
00000e  b108              CBZ      r0,|L28.20|
;;;1626     {
;;;1627       status = HAL_ERROR;
000010  2401              MOVS     r4,#1
000012  e00a              B        |L28.42|
                  |L28.20|
;;;1628     }
;;;1629     else
;;;1630     {
;;;1631       /* Set RTC COUNTER MSB word */
;;;1632       WRITE_REG(hrtc->Instance->CNTH, (TimeCounter >> 16U));
000014  6829              LDR      r1,[r5,#0]
000016  0c30              LSRS     r0,r6,#16
000018  6188              STR      r0,[r1,#0x18]
;;;1633       /* Set RTC COUNTER LSB word */
;;;1634       WRITE_REG(hrtc->Instance->CNTL, (TimeCounter & RTC_CNTL_RTC_CNT));
00001a  6829              LDR      r1,[r5,#0]
00001c  b2b0              UXTH     r0,r6
00001e  61c8              STR      r0,[r1,#0x1c]
;;;1635   
;;;1636       /* Wait for synchro */
;;;1637       if (RTC_ExitInitMode(hrtc) != HAL_OK)
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       RTC_ExitInitMode
000026  b100              CBZ      r0,|L28.42|
;;;1638       {
;;;1639         status = HAL_ERROR;
000028  2401              MOVS     r4,#1
                  |L28.42|
;;;1640       }
;;;1641     }
;;;1642   
;;;1643     return status;
00002a  4620              MOV      r0,r4
;;;1644   }
00002c  bd70              POP      {r4-r6,pc}
;;;1645   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____RRX|
#line 665
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
