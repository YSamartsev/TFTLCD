; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_hal_adc.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_hal_adc.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_hal_adc.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_ConversionStop_Disable||, CODE, READONLY, ALIGN=1

                  ADC_ConversionStop_Disable PROC
;;;2290     */
;;;2291   HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;2292   {
000002  4604              MOV      r4,r0
;;;2293     uint32_t tickstart = 0U;
;;;2294     
;;;2295     /* Verification if ADC is not already disabled */
;;;2296     if (ADC_IS_ENABLE(hadc) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6881              LDR      r1,[r0,#8]
000008  43c9              MVNS     r1,r1
00000a  07c9              LSLS     r1,r1,#31
00000c  d116              BNE      |L1.60|
;;;2297     {
;;;2298       /* Disable the ADC peripheral */
;;;2299       __HAL_ADC_DISABLE(hadc);
00000e  6881              LDR      r1,[r0,#8]
000010  f0210101          BIC      r1,r1,#1
000014  6081              STR      r1,[r0,#8]
;;;2300        
;;;2301       /* Get tick count */
;;;2302       tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4605              MOV      r5,r0
;;;2303       
;;;2304       /* Wait for ADC effectively disabled */
;;;2305       while(ADC_IS_ENABLE(hadc) != RESET)
00001c  e009              B        |L1.50|
                  |L1.30|
;;;2306       {
;;;2307         if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
00001e  f7fffffe          BL       HAL_GetTick
000022  1b40              SUBS     r0,r0,r5
000024  2802              CMP      r0,#2
000026  d904              BLS      |L1.50|
;;;2308         {
;;;2309           /* New check to avoid false timeout detection in case of preemption */
;;;2310           if(ADC_IS_ENABLE(hadc) != RESET)
000028  6820              LDR      r0,[r4,#0]
00002a  6880              LDR      r0,[r0,#8]
00002c  43c0              MVNS     r0,r0
00002e  07c0              LSLS     r0,r0,#31
000030  d006              BEQ      |L1.64|
                  |L1.50|
000032  6820              LDR      r0,[r4,#0]            ;2305
000034  6880              LDR      r0,[r0,#8]            ;2305
000036  43c0              MVNS     r0,r0                 ;2305
000038  07c0              LSLS     r0,r0,#31             ;2305
00003a  d0f0              BEQ      |L1.30|
                  |L1.60|
;;;2311           {
;;;2312             /* Update ADC state machine to error */
;;;2313             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;2314   
;;;2315             /* Set ADC error code to ADC IP internal error */
;;;2316             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;2317   
;;;2318             return HAL_ERROR;
;;;2319           }
;;;2320         }
;;;2321       }
;;;2322     }
;;;2323     
;;;2324     /* Return HAL status */
;;;2325     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2326   }
00003e  bd70              POP      {r4-r6,pc}
                  |L1.64|
000040  6aa0              LDR      r0,[r4,#0x28]         ;2313
000042  f0400010          ORR      r0,r0,#0x10           ;2313
000046  62a0              STR      r0,[r4,#0x28]         ;2313
000048  6ae0              LDR      r0,[r4,#0x2c]         ;2316
00004a  f0400001          ORR      r0,r0,#1              ;2316
00004e  62e0              STR      r0,[r4,#0x2c]         ;2316
000050  2001              MOVS     r0,#1                 ;2318
000052  bd70              POP      {r4-r6,pc}
;;;2327   
                          ENDP


                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;2332     */
;;;2333   void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2334   {
000002  4601              MOV      r1,r0
;;;2335     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2336     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2337    
;;;2338     /* Update state machine on conversion status if not in error state */
;;;2339     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
000006  6a82              LDR      r2,[r0,#0x28]
000008  f0120f50          TST      r2,#0x50
00000c  d005              BEQ      |L2.26|
;;;2340     {
;;;2341       /* Update ADC state machine */
;;;2342       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;2343       
;;;2344       /* Determine whether any further conversion upcoming on group regular     */
;;;2345       /* by external trigger, continuous mode or scan sequence on going.        */
;;;2346       /* Note: On STM32F1 devices, in case of sequencer enabled                 */
;;;2347       /*       (several ranks selected), end of conversion flag is raised       */
;;;2348       /*       at the end of the sequence.                                      */
;;;2349       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
;;;2350          (hadc->Init.ContinuousConvMode == DISABLE)   )
;;;2351       {
;;;2352         /* Set ADC state */
;;;2353         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;2354         
;;;2355         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;2356         {
;;;2357           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;2358         }
;;;2359       }
;;;2360       
;;;2361       /* Conversion complete callback */
;;;2362   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2363       hadc->ConvCpltCallback(hadc);
;;;2364   #else
;;;2365       HAL_ADC_ConvCpltCallback(hadc);
;;;2366   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2367     }
;;;2368     else
;;;2369     {
;;;2370       /* Call DMA error callback */
;;;2371       hadc->DMA_Handle->XferErrorCallback(hdma);
00000e  6a00              LDR      r0,[r0,#0x20]
000010  6b02              LDR      r2,[r0,#0x30]
000012  e8bd4010          POP      {r4,lr}
000016  4608              MOV      r0,r1
000018  4710              BX       r2
                  |L2.26|
00001a  6a81              LDR      r1,[r0,#0x28]         ;2342
00001c  f4417100          ORR      r1,r1,#0x200          ;2342
000020  6281              STR      r1,[r0,#0x28]         ;2342
000022  6801              LDR      r1,[r0,#0]            ;2349
000024  6889              LDR      r1,[r1,#8]            ;2349
000026  f3c14142          UBFX     r1,r1,#17,#3          ;2349
00002a  2907              CMP      r1,#7                 ;2349
00002c  d10c              BNE      |L2.72|
00002e  7b01              LDRB     r1,[r0,#0xc]          ;2350
000030  b951              CBNZ     r1,|L2.72|
000032  6a81              LDR      r1,[r0,#0x28]         ;2353
000034  f4217180          BIC      r1,r1,#0x100          ;2353
000038  6281              STR      r1,[r0,#0x28]         ;2353
00003a  6a81              LDR      r1,[r0,#0x28]         ;2355
00003c  04c9              LSLS     r1,r1,#19             ;2355
00003e  d403              BMI      |L2.72|
000040  6a81              LDR      r1,[r0,#0x28]         ;2357
000042  f0410101          ORR      r1,r1,#1              ;2357
000046  6281              STR      r1,[r0,#0x28]         ;2357
                  |L2.72|
000048  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;2372     }
;;;2373   }
00004c  bd10              POP      {r4,pc}
;;;2374   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;2397     */
;;;2398   void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;2399   {
;;;2400     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2401     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2402     
;;;2403     /* Set ADC state */
;;;2404     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
000004  6a81              LDR      r1,[r0,#0x28]
000006  f0410140          ORR      r1,r1,#0x40
00000a  6281              STR      r1,[r0,#0x28]
;;;2405     
;;;2406     /* Set ADC error code to DMA error */
;;;2407     SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
00000c  6ac1              LDR      r1,[r0,#0x2c]
00000e  f0410104          ORR      r1,r1,#4
000012  62c1              STR      r1,[r0,#0x2c]
;;;2408     
;;;2409     /* Error callback */
;;;2410   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2411     hadc->ErrorCallback(hadc);
;;;2412   #else
;;;2413     HAL_ADC_ErrorCallback(hadc);
000014  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;2414   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2415   }
000018  bd10              POP      {r4,pc}
;;;2416   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;2379     */
;;;2380   void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;2381   {
;;;2382     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2383     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2384     
;;;2385     /* Half conversion callback */
;;;2386   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;2387       hadc->ConvHalfCpltCallback(hadc);
;;;2388   #else
;;;2389     HAL_ADC_ConvHalfCpltCallback(hadc);
000004  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;2390   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;2391   }
000008  bd10              POP      {r4,pc}
;;;2392   
                          ENDP


                          AREA ||i.ADC_Enable||, CODE, READONLY, ALIGN=2

                  ADC_Enable PROC
;;;2231     */
;;;2232   HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2233   {
000002  4604              MOV      r4,r0
;;;2234     uint32_t tickstart = 0U;
;;;2235     __IO uint32_t wait_loop_index = 0U;
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;2236     
;;;2237     /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
;;;2238     /* enabling phase not yet completed: flag ADC ready not yet set).           */
;;;2239     /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
;;;2240     /* causes: ADC clock not running, ...).                                     */
;;;2241     if (ADC_IS_ENABLE(hadc) == RESET)
000008  6820              LDR      r0,[r4,#0]
00000a  6881              LDR      r1,[r0,#8]
00000c  43c9              MVNS     r1,r1
00000e  07c9              LSLS     r1,r1,#31
000010  d02f              BEQ      |L5.114|
;;;2242     {
;;;2243       /* Enable the Peripheral */
;;;2244       __HAL_ADC_ENABLE(hadc);
000012  6881              LDR      r1,[r0,#8]
000014  f0410101          ORR      r1,r1,#1
000018  6081              STR      r1,[r0,#8]
;;;2245       
;;;2246       /* Delay for ADC stabilization time */
;;;2247       /* Compute number of CPU cycles to wait for */
;;;2248       wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
00001a  4817              LDR      r0,|L5.120|
00001c  4917              LDR      r1,|L5.124|
00001e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000020  fbb0f0f1          UDIV     r0,r0,r1
000024  9000              STR      r0,[sp,#0]
;;;2249       while(wait_loop_index != 0U)
000026  e002              B        |L5.46|
                  |L5.40|
;;;2250       {
;;;2251         wait_loop_index--;
000028  9800              LDR      r0,[sp,#0]
00002a  1e40              SUBS     r0,r0,#1
00002c  9000              STR      r0,[sp,#0]
                  |L5.46|
00002e  9800              LDR      r0,[sp,#0]            ;2249
000030  2800              CMP      r0,#0                 ;2249
000032  d1f9              BNE      |L5.40|
;;;2252       }
;;;2253       
;;;2254       /* Get tick count */
;;;2255       tickstart = HAL_GetTick();
000034  f7fffffe          BL       HAL_GetTick
000038  4605              MOV      r5,r0
;;;2256   
;;;2257       /* Wait for ADC effectively enabled */
;;;2258       while(ADC_IS_ENABLE(hadc) == RESET)
00003a  e015              B        |L5.104|
                  |L5.60|
;;;2259       {
;;;2260         if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
00003c  f7fffffe          BL       HAL_GetTick
000040  1b40              SUBS     r0,r0,r5
000042  2802              CMP      r0,#2
000044  d910              BLS      |L5.104|
;;;2261         {
;;;2262           /* New check to avoid false timeout detection in case of preemption */
;;;2263           if(ADC_IS_ENABLE(hadc) == RESET)
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  43c0              MVNS     r0,r0
00004c  07c0              LSLS     r0,r0,#31
00004e  d00b              BEQ      |L5.104|
;;;2264           {
;;;2265             /* Update ADC state machine to error */
;;;2266             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000050  6aa0              LDR      r0,[r4,#0x28]
000052  f0400010          ORR      r0,r0,#0x10
000056  62a0              STR      r0,[r4,#0x28]
;;;2267   
;;;2268             /* Set ADC error code to ADC IP internal error */
;;;2269             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000058  6ae0              LDR      r0,[r4,#0x2c]
00005a  f0400001          ORR      r0,r0,#1
00005e  62e0              STR      r0,[r4,#0x2c]
;;;2270   
;;;2271             /* Process unlocked */
;;;2272             __HAL_UNLOCK(hadc);
000060  f8846024          STRB     r6,[r4,#0x24]
;;;2273   
;;;2274             return HAL_ERROR;
000064  2001              MOVS     r0,#1
;;;2275           }
;;;2276         }
;;;2277       }
;;;2278     }
;;;2279      
;;;2280     /* Return HAL status */
;;;2281     return HAL_OK;
;;;2282   }
000066  bdf8              POP      {r3-r7,pc}
                  |L5.104|
000068  6820              LDR      r0,[r4,#0]            ;2258
00006a  6880              LDR      r0,[r0,#8]            ;2258
00006c  43c0              MVNS     r0,r0                 ;2258
00006e  07c0              LSLS     r0,r0,#31             ;2258
000070  d1e4              BNE      |L5.60|
                  |L5.114|
000072  2000              MOVS     r0,#0                 ;2281
000074  bdf8              POP      {r3-r7,pc}
;;;2283   
                          ENDP

000076  0000              DCW      0x0000
                  |L5.120|
                          DCD      SystemCoreClock
                  |L5.124|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;2109     */
;;;2110   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;2111   {
;;;2112     /* Check the parameters */
;;;2113     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2114     assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
;;;2115     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;2116     assert_param(IS_ADC_RANGE(AnalogWDGConfig->HighThreshold));
;;;2117     assert_param(IS_ADC_RANGE(AnalogWDGConfig->LowThreshold));
;;;2118     
;;;2119     if((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
000002  4b19              LDR      r3,|L6.104|
000004  680a              LDR      r2,[r1,#0]
000006  429a              CMP      r2,r3
000008  d003              BEQ      |L6.18|
;;;2120        (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
00000a  4b18              LDR      r3,|L6.108|
00000c  429a              CMP      r2,r3
00000e  d000              BEQ      |L6.18|
;;;2121        (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)  )
000010  4b17              LDR      r3,|L6.112|
                  |L6.18|
;;;2122     {
;;;2123       assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
;;;2124     }
;;;2125     
;;;2126     /* Process locked */
;;;2127     __HAL_LOCK(hadc);
000012  f8902024          LDRB     r2,[r0,#0x24]
000016  2a01              CMP      r2,#1
000018  d01e              BEQ      |L6.88|
00001a  2201              MOVS     r2,#1
00001c  f8802024          STRB     r2,[r0,#0x24]
;;;2128     
;;;2129     /* Analog watchdog configuration */
;;;2130   
;;;2131     /* Configure ADC Analog watchdog interrupt */
;;;2132     if(AnalogWDGConfig->ITMode == ENABLE)
000020  7a0a              LDRB     r2,[r1,#8]
000022  2a01              CMP      r2,#1
000024  d01a              BEQ      |L6.92|
;;;2133     {
;;;2134       /* Enable the ADC Analog watchdog interrupt */
;;;2135       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;2136     }
;;;2137     else
;;;2138     {
;;;2139       /* Disable the ADC Analog watchdog interrupt */
;;;2140       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
000026  6802              LDR      r2,[r0,#0]
000028  6853              LDR      r3,[r2,#4]
00002a  f0230340          BIC      r3,r3,#0x40
00002e  6053              STR      r3,[r2,#4]
                  |L6.48|
;;;2141     }
;;;2142     
;;;2143     /* Configuration of analog watchdog:                                        */
;;;2144     /*  - Set the analog watchdog enable mode: regular and/or injected groups,  */
;;;2145     /*    one or all channels.                                                  */
;;;2146     /*  - Set the Analog watchdog channel (is not used if watchdog              */
;;;2147     /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */
;;;2148     MODIFY_REG(hadc->Instance->CR1            ,
000030  e9d13200          LDRD     r3,r2,[r1,#0]
000034  4313              ORRS     r3,r3,r2
000036  6802              LDR      r2,[r0,#0]
000038  6854              LDR      r4,[r2,#4]
00003a  4d0e              LDR      r5,|L6.116|
00003c  402c              ANDS     r4,r4,r5
00003e  4323              ORRS     r3,r3,r4
000040  6053              STR      r3,[r2,#4]
;;;2149                ADC_CR1_AWDSGL |
;;;2150                ADC_CR1_JAWDEN |
;;;2151                ADC_CR1_AWDEN  |
;;;2152                ADC_CR1_AWDCH                  ,
;;;2153                AnalogWDGConfig->WatchdogMode |
;;;2154                AnalogWDGConfig->Channel        );
;;;2155     
;;;2156     /* Set the high threshold */
;;;2157     WRITE_REG(hadc->Instance->HTR, AnalogWDGConfig->HighThreshold);
000042  6803              LDR      r3,[r0,#0]
000044  68ca              LDR      r2,[r1,#0xc]
000046  625a              STR      r2,[r3,#0x24]
;;;2158     
;;;2159     /* Set the low threshold */
;;;2160     WRITE_REG(hadc->Instance->LTR, AnalogWDGConfig->LowThreshold);
000048  6802              LDR      r2,[r0,#0]
00004a  6909              LDR      r1,[r1,#0x10]
00004c  6291              STR      r1,[r2,#0x28]
;;;2161   
;;;2162     /* Process unlocked */
;;;2163     __HAL_UNLOCK(hadc);
00004e  2100              MOVS     r1,#0
000050  f8801024          STRB     r1,[r0,#0x24]
;;;2164     
;;;2165     /* Return function status */
;;;2166     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;2167   }
000056  bd30              POP      {r4,r5,pc}
                  |L6.88|
000058  2002              MOVS     r0,#2                 ;2127
00005a  bd30              POP      {r4,r5,pc}
                  |L6.92|
00005c  6802              LDR      r2,[r0,#0]            ;2135
00005e  6853              LDR      r3,[r2,#4]            ;2135
000060  f0430340          ORR      r3,r3,#0x40           ;2135
000064  6053              STR      r3,[r2,#4]            ;2135
000066  e7e3              B        |L6.48|
;;;2168   
                          ENDP

                  |L6.104|
                          DCD      0x00800200
                  |L6.108|
                          DCD      0x00400200
                  |L6.112|
                          DCD      0x00c00200
                  |L6.116|
                          DCD      0xff3ffde0

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;1999     */
;;;2000   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2001   { 
;;;2002     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;2003     __IO uint32_t wait_loop_index = 0U;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;2004     
;;;2005     /* Check the parameters */
;;;2006     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2007     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;2008     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;2009     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;2010     
;;;2011     /* Process locked */
;;;2012     __HAL_LOCK(hadc);
000008  f8902024          LDRB     r2,[r0,#0x24]
00000c  2a01              CMP      r2,#1
00000e  d012              BEQ      |L7.54|
000010  2201              MOVS     r2,#1
000012  f8802024          STRB     r2,[r0,#0x24]
;;;2013     
;;;2014     
;;;2015     /* Regular sequence configuration */
;;;2016     /* For Rank 1 to 6 */
;;;2017     if (sConfig->Rank < 7U)
000016  684a              LDR      r2,[r1,#4]
;;;2018     {
;;;2019       MODIFY_REG(hadc->Instance->SQR3                        ,
000018  261f              MOVS     r6,#0x1f
00001a  2a07              CMP      r2,#7                 ;2017
00001c  d20d              BCS      |L7.58|
00001e  6804              LDR      r4,[r0,#0]
000020  6b67              LDR      r7,[r4,#0x34]
000022  1e52              SUBS     r2,r2,#1
000024  eb020282          ADD      r2,r2,r2,LSL #2
000028  4096              LSLS     r6,r6,r2
00002a  43b7              BICS     r7,r7,r6
00002c  680e              LDR      r6,[r1,#0]
00002e  4096              LSLS     r6,r6,r2
000030  4337              ORRS     r7,r7,r6
000032  6367              STR      r7,[r4,#0x34]
000034  e01a              B        |L7.108|
                  |L7.54|
000036  2002              MOVS     r0,#2                 ;2012
;;;2020                  ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
;;;2021                  ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
;;;2022     }
;;;2023     /* For Rank 7 to 12 */
;;;2024     else if (sConfig->Rank < 13U)
;;;2025     {
;;;2026       MODIFY_REG(hadc->Instance->SQR2                        ,
;;;2027                  ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank)    ,
;;;2028                  ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
;;;2029     }
;;;2030     /* For Rank 13 to 16 */
;;;2031     else
;;;2032     {
;;;2033       MODIFY_REG(hadc->Instance->SQR1                        ,
;;;2034                  ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank)   ,
;;;2035                  ADC_SQR1_RK(sConfig->Channel, sConfig->Rank) );
;;;2036     }
;;;2037     
;;;2038     
;;;2039     /* Channel sampling time configuration */
;;;2040     /* For channels 10 to 17 */
;;;2041     if (sConfig->Channel >= ADC_CHANNEL_10)
;;;2042     {
;;;2043       MODIFY_REG(hadc->Instance->SMPR1                             ,
;;;2044                  ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel)      ,
;;;2045                  ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
;;;2046     }
;;;2047     else /* For channels 0 to 9 */
;;;2048     {
;;;2049       MODIFY_REG(hadc->Instance->SMPR2                             ,
;;;2050                  ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel)       ,
;;;2051                  ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
;;;2052     }
;;;2053     
;;;2054     /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
;;;2055     /* and VREFINT measurement path.                                            */
;;;2056     if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
;;;2057         (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
;;;2058     {
;;;2059       /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
;;;2060       /* measurement channels (VrefInt/TempSensor). If these channels are       */
;;;2061       /* intended to be set on other ADC instances, an error is reported.       */
;;;2062       if (hadc->Instance == ADC1)
;;;2063       {
;;;2064         if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
;;;2065         {
;;;2066           SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;2067           
;;;2068           if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
;;;2069           {
;;;2070             /* Delay for temperature sensor stabilization time */
;;;2071             /* Compute number of CPU cycles to wait for */
;;;2072             wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;2073             while(wait_loop_index != 0U)
;;;2074             {
;;;2075               wait_loop_index--;
;;;2076             }
;;;2077           }
;;;2078         }
;;;2079       }
;;;2080       else
;;;2081       {
;;;2082         /* Update ADC state machine to error */
;;;2083         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;2084         
;;;2085         tmp_hal_status = HAL_ERROR;
;;;2086       }
;;;2087     }
;;;2088     
;;;2089     /* Process unlocked */
;;;2090     __HAL_UNLOCK(hadc);
;;;2091     
;;;2092     /* Return function status */
;;;2093     return tmp_hal_status;
;;;2094   }
000038  bdf8              POP      {r3-r7,pc}
                  |L7.58|
00003a  2a0d              CMP      r2,#0xd               ;2024
00003c  d20b              BCS      |L7.86|
00003e  6804              LDR      r4,[r0,#0]            ;2026
000040  6b27              LDR      r7,[r4,#0x30]         ;2026
000042  1fd2              SUBS     r2,r2,#7              ;2026
000044  eb020282          ADD      r2,r2,r2,LSL #2       ;2026
000048  4096              LSLS     r6,r6,r2              ;2026
00004a  43b7              BICS     r7,r7,r6              ;2026
00004c  680e              LDR      r6,[r1,#0]            ;2026
00004e  4096              LSLS     r6,r6,r2              ;2026
000050  4337              ORRS     r7,r7,r6              ;2026
000052  6327              STR      r7,[r4,#0x30]         ;2026
000054  e00a              B        |L7.108|
                  |L7.86|
000056  6804              LDR      r4,[r0,#0]            ;2033
000058  6ae7              LDR      r7,[r4,#0x2c]         ;2033
00005a  3a0d              SUBS     r2,r2,#0xd            ;2033
00005c  eb020282          ADD      r2,r2,r2,LSL #2       ;2033
000060  4096              LSLS     r6,r6,r2              ;2033
000062  43b7              BICS     r7,r7,r6              ;2033
000064  680e              LDR      r6,[r1,#0]            ;2033
000066  4096              LSLS     r6,r6,r2              ;2033
000068  4337              ORRS     r7,r7,r6              ;2033
00006a  62e7              STR      r7,[r4,#0x2c]         ;2033
                  |L7.108|
00006c  680a              LDR      r2,[r1,#0]            ;2041
00006e  2607              MOVS     r6,#7                 ;2043
000070  2a0a              CMP      r2,#0xa               ;2041
000072  d30b              BCC      |L7.140|
000074  6804              LDR      r4,[r0,#0]            ;2043
000076  68e7              LDR      r7,[r4,#0xc]          ;2043
000078  3a0a              SUBS     r2,r2,#0xa            ;2043
00007a  eb020242          ADD      r2,r2,r2,LSL #1       ;2043
00007e  4096              LSLS     r6,r6,r2              ;2043
000080  43b7              BICS     r7,r7,r6              ;2043
000082  688e              LDR      r6,[r1,#8]            ;2043
000084  4096              LSLS     r6,r6,r2              ;2043
000086  4337              ORRS     r7,r7,r6              ;2043
000088  60e7              STR      r7,[r4,#0xc]          ;2043
00008a  e009              B        |L7.160|
                  |L7.140|
00008c  6804              LDR      r4,[r0,#0]            ;2049
00008e  6927              LDR      r7,[r4,#0x10]         ;2049
000090  eb020242          ADD      r2,r2,r2,LSL #1       ;2049
000094  4096              LSLS     r6,r6,r2              ;2049
000096  43b7              BICS     r7,r7,r6              ;2049
000098  688e              LDR      r6,[r1,#8]            ;2049
00009a  4096              LSLS     r6,r6,r2              ;2049
00009c  4337              ORRS     r7,r7,r6              ;2049
00009e  6127              STR      r7,[r4,#0x10]         ;2049
                  |L7.160|
0000a0  680a              LDR      r2,[r1,#0]            ;2056
0000a2  2a10              CMP      r2,#0x10              ;2056
0000a4  d001              BEQ      |L7.170|
0000a6  2a11              CMP      r2,#0x11              ;2057
0000a8  d123              BNE      |L7.242|
                  |L7.170|
0000aa  4c14              LDR      r4,|L7.252|
0000ac  6802              LDR      r2,[r0,#0]            ;2062
0000ae  42a2              CMP      r2,r4                 ;2062
0000b0  d11a              BNE      |L7.232|
0000b2  6894              LDR      r4,[r2,#8]            ;2064
0000b4  0224              LSLS     r4,r4,#8              ;2064
0000b6  d41c              BMI      |L7.242|
0000b8  6894              LDR      r4,[r2,#8]            ;2066
0000ba  f4440400          ORR      r4,r4,#0x800000       ;2066
0000be  6094              STR      r4,[r2,#8]            ;2066
0000c0  6809              LDR      r1,[r1,#0]            ;2068
0000c2  2910              CMP      r1,#0x10              ;2068
0000c4  d115              BNE      |L7.242|
0000c6  490e              LDR      r1,|L7.256|
0000c8  4a0e              LDR      r2,|L7.260|
0000ca  6809              LDR      r1,[r1,#0]            ;2072  ; SystemCoreClock
0000cc  fbb1f1f2          UDIV     r1,r1,r2              ;2072
0000d0  eb010181          ADD      r1,r1,r1,LSL #2       ;2072
0000d4  0049              LSLS     r1,r1,#1              ;2072
0000d6  9100              STR      r1,[sp,#0]            ;2072
0000d8  e002              B        |L7.224|
                  |L7.218|
0000da  9900              LDR      r1,[sp,#0]            ;2075
0000dc  1e49              SUBS     r1,r1,#1              ;2075
0000de  9100              STR      r1,[sp,#0]            ;2075
                  |L7.224|
0000e0  9900              LDR      r1,[sp,#0]            ;2073
0000e2  2900              CMP      r1,#0                 ;2073
0000e4  d1f9              BNE      |L7.218|
0000e6  e004              B        |L7.242|
                  |L7.232|
0000e8  6a81              LDR      r1,[r0,#0x28]         ;2083
0000ea  f0410120          ORR      r1,r1,#0x20           ;2083
0000ee  6281              STR      r1,[r0,#0x28]         ;2083
0000f0  2301              MOVS     r3,#1                 ;2085
                  |L7.242|
0000f2  f8805024          STRB     r5,[r0,#0x24]         ;2090
0000f6  4618              MOV      r0,r3                 ;2093
0000f8  bdf8              POP      {r3-r7,pc}
;;;2095   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L7.252|
                          DCD      0x40012400
                  |L7.256|
                          DCD      SystemCoreClock
                  |L7.260|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;1908     */
;;;1909   __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1910   {
;;;1911     /* Prevent unused argument(s) compilation warning */
;;;1912     UNUSED(hadc);
;;;1913     /* NOTE : This function should not be modified. When the callback is needed,
;;;1914               function HAL_ADC_ConvCpltCallback must be implemented in the user file.
;;;1915      */
;;;1916   }
;;;1917   
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;1922     */
;;;1923   __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1924   {
;;;1925     /* Prevent unused argument(s) compilation warning */
;;;1926     UNUSED(hadc);
;;;1927     /* NOTE : This function should not be modified. When the callback is needed,
;;;1928               function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
;;;1929     */
;;;1930   }
;;;1931   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_ADC_DeInit PROC
;;;628      */
;;;629    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;630    {
000002  4604              MOV      r4,r0
;;;631      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;632      
;;;633      /* Check ADC handle */
;;;634      if(hadc == NULL)
000004  2c00              CMP      r4,#0
000006  d00a              BEQ      |L10.30|
;;;635      {
;;;636         return HAL_ERROR;
;;;637      }
;;;638      
;;;639      /* Check the parameters */
;;;640      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;641      
;;;642      /* Set ADC state */
;;;643      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  f0400002          ORR      r0,r0,#2
00000e  62a0              STR      r0,[r4,#0x28]
;;;644      
;;;645      /* Stop potential conversion on going, on regular and injected groups */
;;;646      /* Disable ADC peripheral */
;;;647      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       ADC_ConversionStop_Disable
000016  4605              MOV      r5,r0
;;;648      
;;;649      
;;;650      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;651      /* correctly completed.                                                     */
;;;652      if (tmp_hal_status == HAL_OK)
000018  2600              MOVS     r6,#0
00001a  b115              CBZ      r5,|L10.34|
00001c  e05a              B        |L10.212|
                  |L10.30|
00001e  2001              MOVS     r0,#1                 ;636
;;;653      {
;;;654        /* ========== Reset ADC registers ========== */
;;;655    
;;;656    
;;;657    
;;;658    
;;;659        /* Reset register SR */
;;;660        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
;;;661                                    ADC_FLAG_JSTRT | ADC_FLAG_STRT));
;;;662                             
;;;663        /* Reset register CR1 */
;;;664        CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_AWDEN   | ADC_CR1_JAWDEN | ADC_CR1_DISCNUM | 
;;;665                                        ADC_CR1_JDISCEN | ADC_CR1_DISCEN | ADC_CR1_JAUTO   | 
;;;666                                        ADC_CR1_AWDSGL  | ADC_CR1_SCAN   | ADC_CR1_JEOCIE  |   
;;;667                                        ADC_CR1_AWDIE   | ADC_CR1_EOCIE  | ADC_CR1_AWDCH    ));
;;;668        
;;;669        /* Reset register CR2 */
;;;670        CLEAR_BIT(hadc->Instance->CR2, (ADC_CR2_TSVREFE | ADC_CR2_SWSTART | ADC_CR2_JSWSTART | 
;;;671                                        ADC_CR2_EXTTRIG | ADC_CR2_EXTSEL  | ADC_CR2_JEXTTRIG |  
;;;672                                        ADC_CR2_JEXTSEL | ADC_CR2_ALIGN   | ADC_CR2_DMA      |        
;;;673                                        ADC_CR2_RSTCAL  | ADC_CR2_CAL     | ADC_CR2_CONT     |          
;;;674                                        ADC_CR2_ADON                                          ));
;;;675        
;;;676        /* Reset register SMPR1 */
;;;677        CLEAR_BIT(hadc->Instance->SMPR1, (ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16 | ADC_SMPR1_SMP15 | 
;;;678                                          ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP12 | 
;;;679                                          ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10                    ));
;;;680        
;;;681        /* Reset register SMPR2 */
;;;682        CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP9 | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | 
;;;683                                          ADC_SMPR2_SMP6 | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | 
;;;684                                          ADC_SMPR2_SMP3 | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | 
;;;685                                          ADC_SMPR2_SMP0                                    ));
;;;686    
;;;687        /* Reset register JOFR1 */
;;;688        CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
;;;689        /* Reset register JOFR2 */
;;;690        CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
;;;691        /* Reset register JOFR3 */
;;;692        CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
;;;693        /* Reset register JOFR4 */
;;;694        CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
;;;695        
;;;696        /* Reset register HTR */
;;;697        CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
;;;698        /* Reset register LTR */
;;;699        CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
;;;700        
;;;701        /* Reset register SQR1 */
;;;702        CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
;;;703                                        ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
;;;704                                        ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
;;;705        
;;;706        /* Reset register SQR1 */
;;;707        CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
;;;708                                        ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
;;;709                                        ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
;;;710        
;;;711        /* Reset register SQR2 */
;;;712        CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10 | 
;;;713                                        ADC_SQR2_SQ9  | ADC_SQR2_SQ8  | ADC_SQR2_SQ7   );
;;;714        
;;;715        /* Reset register SQR3 */
;;;716        CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4 | 
;;;717                                        ADC_SQR3_SQ3 | ADC_SQR3_SQ2 | ADC_SQR3_SQ1  );
;;;718        
;;;719        /* Reset register JSQR */
;;;720        CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
;;;721                                        ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
;;;722                                        ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
;;;723        
;;;724        /* Reset register JSQR */
;;;725        CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
;;;726                                        ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
;;;727                                        ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
;;;728        
;;;729        /* Reset register DR */
;;;730        /* bits in access mode read only, no direct reset applicable*/
;;;731        
;;;732        /* Reset registers JDR1, JDR2, JDR3, JDR4 */
;;;733        /* bits in access mode read only, no direct reset applicable*/
;;;734        
;;;735        /* ========== Hard reset ADC peripheral ========== */
;;;736        /* Performs a global reset of the entire ADC peripheral: ADC state is     */
;;;737        /* forced to a similar state after device power-on.                       */
;;;738        /* If needed, copy-paste and uncomment the following reset code into      */
;;;739        /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
;;;740        /*                                                                        */
;;;741        /*  __HAL_RCC_ADC1_FORCE_RESET()                                          */
;;;742        /*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */
;;;743        
;;;744    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;745        if (hadc->MspDeInitCallback == NULL)
;;;746        {
;;;747          hadc->MspDeInitCallback = HAL_ADC_MspDeInit; /* Legacy weak MspDeInit  */
;;;748        }
;;;749        
;;;750        /* DeInit the low level hardware */
;;;751        hadc->MspDeInitCallback(hadc);
;;;752    #else
;;;753        /* DeInit the low level hardware */
;;;754        HAL_ADC_MspDeInit(hadc);
;;;755    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;756        
;;;757        /* Set ADC error code to none */
;;;758        ADC_CLEAR_ERRORCODE(hadc);
;;;759        
;;;760        /* Set ADC state */
;;;761        hadc->State = HAL_ADC_STATE_RESET; 
;;;762      
;;;763      }
;;;764      
;;;765      /* Process unlocked */
;;;766      __HAL_UNLOCK(hadc);
;;;767      
;;;768      /* Return function status */
;;;769      return tmp_hal_status;
;;;770    }
000020  bd70              POP      {r4-r6,pc}
                  |L10.34|
000022  6821              LDR      r1,[r4,#0]            ;660
000024  f06f001f          MVN      r0,#0x1f              ;660
000028  6008              STR      r0,[r1,#0]            ;660
00002a  6820              LDR      r0,[r4,#0]            ;664
00002c  6841              LDR      r1,[r0,#4]            ;664
00002e  4a2b              LDR      r2,|L10.220|
000030  4011              ANDS     r1,r1,r2              ;664
000032  6041              STR      r1,[r0,#4]            ;664
000034  6820              LDR      r0,[r4,#0]            ;670
000036  6881              LDR      r1,[r0,#8]            ;670
000038  4a29              LDR      r2,|L10.224|
00003a  4011              ANDS     r1,r1,r2              ;670
00003c  6081              STR      r1,[r0,#8]            ;670
00003e  6820              LDR      r0,[r4,#0]            ;677
000040  68c1              LDR      r1,[r0,#0xc]          ;677
000042  f001417f          AND      r1,r1,#0xff000000     ;677
000046  60c1              STR      r1,[r0,#0xc]          ;677
000048  6820              LDR      r0,[r4,#0]            ;682
00004a  6901              LDR      r1,[r0,#0x10]         ;682
00004c  f0014140          AND      r1,r1,#0xc0000000     ;682
000050  6101              STR      r1,[r0,#0x10]         ;682
000052  6820              LDR      r0,[r4,#0]            ;688
000054  6941              LDR      r1,[r0,#0x14]         ;688
000056  f36f010b          BFC      r1,#0,#12             ;688
00005a  6141              STR      r1,[r0,#0x14]         ;688
00005c  6820              LDR      r0,[r4,#0]            ;690
00005e  6981              LDR      r1,[r0,#0x18]         ;690
000060  f36f010b          BFC      r1,#0,#12             ;690
000064  6181              STR      r1,[r0,#0x18]         ;690
000066  6820              LDR      r0,[r4,#0]            ;692
000068  69c1              LDR      r1,[r0,#0x1c]         ;692
00006a  f36f010b          BFC      r1,#0,#12             ;692
00006e  61c1              STR      r1,[r0,#0x1c]         ;692
000070  6820              LDR      r0,[r4,#0]            ;694
000072  6a01              LDR      r1,[r0,#0x20]         ;694
000074  f36f010b          BFC      r1,#0,#12             ;694
000078  6201              STR      r1,[r0,#0x20]         ;694
00007a  6820              LDR      r0,[r4,#0]            ;697
00007c  6a41              LDR      r1,[r0,#0x24]         ;697
00007e  f36f010b          BFC      r1,#0,#12             ;697
000082  6241              STR      r1,[r0,#0x24]         ;697
000084  6820              LDR      r0,[r4,#0]            ;699
000086  6a81              LDR      r1,[r0,#0x28]         ;699
000088  f36f010b          BFC      r1,#0,#12             ;699
00008c  6281              STR      r1,[r0,#0x28]         ;699
00008e  6820              LDR      r0,[r4,#0]            ;702
000090  6ac1              LDR      r1,[r0,#0x2c]         ;702
000092  f001417f          AND      r1,r1,#0xff000000     ;702
000096  62c1              STR      r1,[r0,#0x2c]         ;702
000098  6820              LDR      r0,[r4,#0]            ;707
00009a  6ac1              LDR      r1,[r0,#0x2c]         ;707
00009c  f001417f          AND      r1,r1,#0xff000000     ;707
0000a0  62c1              STR      r1,[r0,#0x2c]         ;707
0000a2  6820              LDR      r0,[r4,#0]            ;712
0000a4  6b01              LDR      r1,[r0,#0x30]         ;712
0000a6  f0014140          AND      r1,r1,#0xc0000000     ;712
0000aa  6301              STR      r1,[r0,#0x30]         ;712
0000ac  6820              LDR      r0,[r4,#0]            ;716
0000ae  6b41              LDR      r1,[r0,#0x34]         ;716
0000b0  f0014140          AND      r1,r1,#0xc0000000     ;716
0000b4  6341              STR      r1,[r0,#0x34]         ;716
0000b6  6820              LDR      r0,[r4,#0]            ;720
0000b8  6b81              LDR      r1,[r0,#0x38]         ;720
0000ba  f36f0115          BFC      r1,#0,#22             ;720
0000be  6381              STR      r1,[r0,#0x38]         ;720
0000c0  6820              LDR      r0,[r4,#0]            ;725
0000c2  6b81              LDR      r1,[r0,#0x38]         ;725
0000c4  f36f0115          BFC      r1,#0,#22             ;725
0000c8  6381              STR      r1,[r0,#0x38]         ;725
0000ca  4620              MOV      r0,r4                 ;754
0000cc  f7fffffe          BL       HAL_ADC_MspDeInit
0000d0  62e6              STR      r6,[r4,#0x2c]         ;758
0000d2  62a6              STR      r6,[r4,#0x28]         ;761
                  |L10.212|
0000d4  f8846024          STRB     r6,[r4,#0x24]         ;766
0000d8  4628              MOV      r0,r5                 ;769
0000da  bd70              POP      {r4-r6,pc}
;;;771    
                          ENDP

                  |L10.220|
                          DCD      0xff3f0000
                  |L10.224|
                          DCD      0xff0106f0

                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;1951     */
;;;1952   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1953   {
;;;1954     /* Prevent unused argument(s) compilation warning */
;;;1955     UNUSED(hadc);
;;;1956     /* NOTE : This function should not be modified. When the callback is needed,
;;;1957               function HAL_ADC_ErrorCallback must be implemented in the user file.
;;;1958     */
;;;1959   }
;;;1960   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;2207     */
;;;2208   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  6ac0              LDR      r0,[r0,#0x2c]
;;;2209   {
;;;2210     return hadc->ErrorCode;
;;;2211   }
000002  4770              BX       lr
;;;2212   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;2196     */
;;;2197   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  6a80              LDR      r0,[r0,#0x28]
;;;2198   {
;;;2199     /* Return ADC state */
;;;2200     return hadc->State;
;;;2201   }
000002  4770              BX       lr
;;;2202   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;1761     */
;;;1762   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  6800              LDR      r0,[r0,#0]
;;;1763   {
;;;1764     /* Check the parameters */
;;;1765     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1766   
;;;1767     /* Note: EOC flag is not cleared here by software because automatically     */
;;;1768     /*       cleared by hardware when reading register DR.                      */
;;;1769     
;;;1770     /* Return ADC converted value */ 
;;;1771     return hadc->Instance->DR;
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;1772   }
000004  4770              BX       lr
;;;1773   
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;1778     */
;;;1779   void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1780   {
000002  4604              MOV      r4,r0
;;;1781     uint32_t tmp_sr = hadc->Instance->SR;
000004  6820              LDR      r0,[r4,#0]
000006  6805              LDR      r5,[r0,#0]
;;;1782     uint32_t tmp_cr1 = hadc->Instance->CR1;
000008  6846              LDR      r6,[r0,#4]
;;;1783   
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1786     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1787     assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;1788     
;;;1789     
;;;1790     /* ========== Check End of Conversion flag for regular group ========== */
;;;1791     if((tmp_cr1 & ADC_IT_EOC) == ADC_IT_EOC)
00000a  06b1              LSLS     r1,r6,#26
00000c  d525              BPL      |L15.90|
;;;1792     {
;;;1793       if((tmp_sr & ADC_FLAG_EOC) == ADC_FLAG_EOC)
00000e  07a9              LSLS     r1,r5,#30
000010  d523              BPL      |L15.90|
;;;1794       {
;;;1795         /* Update state machine on conversion status if not in error state */
;;;1796         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000012  6aa1              LDR      r1,[r4,#0x28]
000014  06c9              LSLS     r1,r1,#27
000016  d403              BMI      |L15.32|
;;;1797         {
;;;1798           /* Set ADC state */
;;;1799           SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
000018  6aa1              LDR      r1,[r4,#0x28]
00001a  f4417100          ORR      r1,r1,#0x200
00001e  62a1              STR      r1,[r4,#0x28]
                  |L15.32|
;;;1800         }
;;;1801         
;;;1802         /* Determine whether any further conversion upcoming on group regular   */
;;;1803         /* by external trigger, continuous mode or scan sequence on going.      */
;;;1804         /* Note: On STM32F1 devices, in case of sequencer enabled               */
;;;1805         /*       (several ranks selected), end of conversion flag is raised     */
;;;1806         /*       at the end of the sequence.                                    */
;;;1807         if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
000020  6881              LDR      r1,[r0,#8]
000022  f3c14142          UBFX     r1,r1,#17,#3
000026  2907              CMP      r1,#7
000028  d110              BNE      |L15.76|
;;;1808            (hadc->Init.ContinuousConvMode == DISABLE)   )
00002a  7b21              LDRB     r1,[r4,#0xc]
00002c  b971              CBNZ     r1,|L15.76|
;;;1809         {
;;;1810           /* Disable ADC end of conversion interrupt on group regular */
;;;1811           __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
00002e  6841              LDR      r1,[r0,#4]
000030  f0210120          BIC      r1,r1,#0x20
000034  6041              STR      r1,[r0,#4]
;;;1812           
;;;1813           /* Set ADC state */
;;;1814           CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
000036  6aa0              LDR      r0,[r4,#0x28]
000038  f4207080          BIC      r0,r0,#0x100
00003c  62a0              STR      r0,[r4,#0x28]
;;;1815           
;;;1816           if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
00003e  6aa0              LDR      r0,[r4,#0x28]
000040  04c0              LSLS     r0,r0,#19
000042  d403              BMI      |L15.76|
;;;1817           {
;;;1818             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
000044  6aa0              LDR      r0,[r4,#0x28]
000046  f0400001          ORR      r0,r0,#1
00004a  62a0              STR      r0,[r4,#0x28]
                  |L15.76|
;;;1819           }
;;;1820         }
;;;1821   
;;;1822         /* Conversion complete callback */
;;;1823   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1824         hadc->ConvCpltCallback(hadc);
;;;1825   #else
;;;1826         HAL_ADC_ConvCpltCallback(hadc);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1827   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1828         
;;;1829         /* Clear regular group conversion flag */
;;;1830         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
000052  6821              LDR      r1,[r4,#0]
000054  f06f0012          MVN      r0,#0x12
000058  6008              STR      r0,[r1,#0]
                  |L15.90|
;;;1831       }
;;;1832     }
;;;1833     
;;;1834     /* ========== Check End of Conversion flag for injected group ========== */
;;;1835     if((tmp_cr1 & ADC_IT_JEOC) == ADC_IT_JEOC)
00005a  0630              LSLS     r0,r6,#24
00005c  d52e              BPL      |L15.188|
;;;1836     {
;;;1837       if((tmp_sr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC)
00005e  0768              LSLS     r0,r5,#29
000060  d52c              BPL      |L15.188|
;;;1838       {
;;;1839         /* Update state machine on conversion status if not in error state */
;;;1840         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000062  6aa0              LDR      r0,[r4,#0x28]
000064  06c0              LSLS     r0,r0,#27
000066  d403              BMI      |L15.112|
;;;1841         {
;;;1842           /* Set ADC state */
;;;1843           SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
000068  6aa0              LDR      r0,[r4,#0x28]
00006a  f4405000          ORR      r0,r0,#0x2000
00006e  62a0              STR      r0,[r4,#0x28]
                  |L15.112|
;;;1844         }
;;;1845   
;;;1846         /* Determine whether any further conversion upcoming on group injected  */
;;;1847         /* by external trigger, scan sequence on going or by automatic injected */
;;;1848         /* conversion from group regular (same conditions as group regular      */
;;;1849         /* interruption disabling above).                                       */
;;;1850         /* Note: On STM32F1 devices, in case of sequencer enabled               */
;;;1851         /*       (several ranks selected), end of conversion flag is raised     */
;;;1852         /*       at the end of the sequence.                                    */
;;;1853         if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
000070  6820              LDR      r0,[r4,#0]
000072  6881              LDR      r1,[r0,#8]
000074  f3c13102          UBFX     r1,r1,#12,#3
000078  2907              CMP      r1,#7
00007a  d009              BEQ      |L15.144|
;;;1854            (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
00007c  6841              LDR      r1,[r0,#4]
00007e  0549              LSLS     r1,r1,#21
000080  d415              BMI      |L15.174|
;;;1855            (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
000082  6881              LDR      r1,[r0,#8]
000084  f3c14142          UBFX     r1,r1,#17,#3
000088  2907              CMP      r1,#7
00008a  d110              BNE      |L15.174|
;;;1856             (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
00008c  7b21              LDRB     r1,[r4,#0xc]
00008e  b971              CBNZ     r1,|L15.174|
                  |L15.144|
;;;1857         {
;;;1858           /* Disable ADC end of conversion interrupt on group injected */
;;;1859           __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
000090  6841              LDR      r1,[r0,#4]
000092  f0210180          BIC      r1,r1,#0x80
000096  6041              STR      r1,[r0,#4]
;;;1860           
;;;1861           /* Set ADC state */
;;;1862           CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
000098  6aa0              LDR      r0,[r4,#0x28]
00009a  f4205080          BIC      r0,r0,#0x1000
00009e  62a0              STR      r0,[r4,#0x28]
;;;1863   
;;;1864           if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
0000a0  6aa0              LDR      r0,[r4,#0x28]
0000a2  05c0              LSLS     r0,r0,#23
0000a4  d403              BMI      |L15.174|
;;;1865           { 
;;;1866             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
0000a6  6aa0              LDR      r0,[r4,#0x28]
0000a8  f0400001          ORR      r0,r0,#1
0000ac  62a0              STR      r0,[r4,#0x28]
                  |L15.174|
;;;1867           }
;;;1868         }
;;;1869   
;;;1870         /* Conversion complete callback */ 
;;;1871   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1872         hadc->InjectedConvCpltCallback(hadc);
;;;1873   #else
;;;1874         HAL_ADCEx_InjectedConvCpltCallback(hadc);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;1875   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1876         
;;;1877         /* Clear injected group conversion flag */
;;;1878         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
0000b4  6821              LDR      r1,[r4,#0]
0000b6  f06f000c          MVN      r0,#0xc
0000ba  6008              STR      r0,[r1,#0]
                  |L15.188|
;;;1879       }
;;;1880     }
;;;1881      
;;;1882     /* ========== Check Analog watchdog flags ========== */
;;;1883     if((tmp_cr1 & ADC_IT_AWD) == ADC_IT_AWD)
0000bc  0670              LSLS     r0,r6,#25
0000be  d50c              BPL      |L15.218|
;;;1884     {
;;;1885       if((tmp_sr & ADC_FLAG_AWD) == ADC_FLAG_AWD)
0000c0  07e8              LSLS     r0,r5,#31
0000c2  d00a              BEQ      |L15.218|
;;;1886       {
;;;1887         /* Set ADC state */
;;;1888         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
0000c4  6aa0              LDR      r0,[r4,#0x28]
0000c6  f4403080          ORR      r0,r0,#0x10000
0000ca  62a0              STR      r0,[r4,#0x28]
;;;1889         
;;;1890         /* Level out of window callback */ 
;;;1891   #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;1892         hadc->LevelOutOfWindowCallback(hadc);
;;;1893   #else
;;;1894         HAL_ADC_LevelOutOfWindowCallback(hadc);
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;1895   #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;1896         
;;;1897         /* Clear the ADC analog watchdog flag */
;;;1898         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
0000d2  6821              LDR      r1,[r4,#0]
0000d4  f06f0001          MVN      r0,#1
0000d8  6008              STR      r0,[r1,#0]
                  |L15.218|
;;;1899       }
;;;1900     }
;;;1901     
;;;1902   }
0000da  bd70              POP      {r4-r6,pc}
;;;1903   
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;410      */
;;;411    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;412    {
000004  4604              MOV      r4,r0
;;;413      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;414      uint32_t tmp_cr1 = 0U;
;;;415      uint32_t tmp_cr2 = 0U;
000006  2700              MOVS     r7,#0
;;;416      uint32_t tmp_sqr1 = 0U;
000008  2500              MOVS     r5,#0
;;;417      
;;;418      /* Check ADC handle */
;;;419      if(hadc == NULL)
00000a  2c00              CMP      r4,#0
00000c  d003              BEQ      |L16.22|
;;;420      {
;;;421        return HAL_ERROR;
;;;422      }
;;;423      
;;;424      /* Check the parameters */
;;;425      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;426      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;427      assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
;;;428      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;429      assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
;;;430      
;;;431      if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
;;;432      {
;;;433        assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;434        assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;435        if(hadc->Init.DiscontinuousConvMode != DISABLE)
;;;436        {
;;;437          assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;438        }
;;;439      }
;;;440      
;;;441      /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
;;;442      /* at RCC top level.                                                        */
;;;443      /* Refer to header of this file for more details on clock enabling          */
;;;444      /* procedure.                                                               */
;;;445    
;;;446      /* Actions performed only if ADC is coming from state reset:                */
;;;447      /* - Initialization of ADC MSP                                              */
;;;448      if (hadc->State == HAL_ADC_STATE_RESET)
00000e  6aa0              LDR      r0,[r4,#0x28]
000010  2600              MOVS     r6,#0
000012  b118              CBZ      r0,|L16.28|
000014  e008              B        |L16.40|
                  |L16.22|
000016  2001              MOVS     r0,#1                 ;421
                  |L16.24|
;;;449      {
;;;450        /* Initialize ADC error code */
;;;451        ADC_CLEAR_ERRORCODE(hadc);
;;;452        
;;;453        /* Allocate lock resource and initialize it */
;;;454        hadc->Lock = HAL_UNLOCKED;
;;;455        
;;;456    #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
;;;457        /* Init the ADC Callback settings */
;;;458        hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
;;;459        hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
;;;460        hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
;;;461        hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
;;;462        hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
;;;463        
;;;464        if (hadc->MspInitCallback == NULL)
;;;465        {
;;;466          hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
;;;467        }
;;;468        
;;;469        /* Init the low level hardware */
;;;470        hadc->MspInitCallback(hadc);
;;;471    #else
;;;472        /* Init the low level hardware */
;;;473        HAL_ADC_MspInit(hadc);
;;;474    #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
;;;475      }
;;;476      
;;;477      /* Stop potential conversion on going, on regular and injected groups */
;;;478      /* Disable ADC peripheral */
;;;479      /* Note: In case of ADC already enabled, precaution to not launch an        */
;;;480      /*       unwanted conversion while modifying register CR2 by writing 1 to   */
;;;481      /*       bit ADON.                                                          */
;;;482      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;483      
;;;484      
;;;485      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;486      /* correctly completed.                                                     */
;;;487      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
;;;488          (tmp_hal_status == HAL_OK)                                  )
;;;489      {
;;;490        /* Set ADC state */
;;;491        ADC_STATE_CLR_SET(hadc->State,
;;;492                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;493                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;494        
;;;495        /* Set ADC parameters */
;;;496        
;;;497        /* Configuration of ADC:                                                  */
;;;498        /*  - data alignment                                                      */
;;;499        /*  - external trigger to start conversion                                */
;;;500        /*  - external trigger polarity (always set to 1, because needed for all  */
;;;501        /*    triggers: external trigger of SW start)                             */
;;;502        /*  - continuous conversion mode                                          */
;;;503        /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
;;;504        /*       HAL_ADC_Start_xxx functions because if set in this function,     */
;;;505        /*       a conversion on injected group would start a conversion also on  */
;;;506        /*       regular group after ADC enabling.                                */
;;;507        tmp_cr2 |= (hadc->Init.DataAlign                                          |
;;;508                    ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv)            |
;;;509                    ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)   );
;;;510    
;;;511        /* Configuration of ADC:                                                  */
;;;512        /*  - scan mode                                                           */
;;;513        /*  - discontinuous mode disable/enable                                   */
;;;514        /*  - discontinuous mode number of conversions                            */
;;;515        tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
;;;516        
;;;517        /* Enable discontinuous mode only if continuous mode is disabled */
;;;518        /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
;;;519        /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
;;;520        if (hadc->Init.DiscontinuousConvMode == ENABLE)
;;;521        {
;;;522          if (hadc->Init.ContinuousConvMode == DISABLE)
;;;523          {
;;;524            /* Enable the selected ADC regular discontinuous mode */
;;;525            /* Set the number of channels to be converted in discontinuous mode */
;;;526            SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
;;;527                             ADC_CR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion)  );
;;;528          }
;;;529          else
;;;530          {
;;;531            /* ADC regular group settings continuous and sequencer discontinuous*/
;;;532            /* cannot be enabled simultaneously.                                */
;;;533            
;;;534            /* Update ADC state machine to error */
;;;535            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;536            
;;;537            /* Set ADC error code to ADC IP internal error */
;;;538            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;539          }
;;;540        }
;;;541        
;;;542        /* Update ADC configuration register CR1 with previous settings */
;;;543          MODIFY_REG(hadc->Instance->CR1,
;;;544                     ADC_CR1_SCAN    |
;;;545                     ADC_CR1_DISCEN  |
;;;546                     ADC_CR1_DISCNUM    ,
;;;547                     tmp_cr1             );
;;;548        
;;;549        /* Update ADC configuration register CR2 with previous settings */
;;;550          MODIFY_REG(hadc->Instance->CR2,
;;;551                     ADC_CR2_ALIGN   |
;;;552                     ADC_CR2_EXTSEL  |
;;;553                     ADC_CR2_EXTTRIG |
;;;554                     ADC_CR2_CONT       ,
;;;555                     tmp_cr2             );
;;;556    
;;;557        /* Configuration of regular group sequencer:                              */
;;;558        /* - if scan mode is disabled, regular channels sequence length is set to */
;;;559        /*   0x00: 1 channel converted (channel on regular rank 1)                */
;;;560        /*   Parameter "NbrOfConversion" is discarded.                            */
;;;561        /*   Note: Scan mode is present by hardware on this device and, if        */
;;;562        /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
;;;563        /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
;;;564        /* - if scan mode is enabled, regular channels sequence length is set to  */
;;;565        /*   parameter "NbrOfConversion"                                          */
;;;566        if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
;;;567        {
;;;568          tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
;;;569        }
;;;570          
;;;571        MODIFY_REG(hadc->Instance->SQR1,
;;;572                   ADC_SQR1_L          ,
;;;573                   tmp_sqr1             );
;;;574        
;;;575        /* Check back that ADC registers have effectively been configured to      */
;;;576        /* ensure of no potential problem of ADC core IP clocking.                */
;;;577        /* Check through register CR2 (excluding bits set in other functions:     */
;;;578        /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
;;;579        /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
;;;580        /* measurement path bit (TSVREFE).                                        */
;;;581        if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
;;;582                                            ADC_CR2_SWSTART | ADC_CR2_JSWSTART |
;;;583                                            ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL |
;;;584                                            ADC_CR2_TSVREFE                     ))
;;;585             == tmp_cr2)
;;;586        {
;;;587          /* Set ADC error code to none */
;;;588          ADC_CLEAR_ERRORCODE(hadc);
;;;589          
;;;590          /* Set the ADC state */
;;;591          ADC_STATE_CLR_SET(hadc->State,
;;;592                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;593                            HAL_ADC_STATE_READY);
;;;594        }
;;;595        else
;;;596        {
;;;597          /* Update ADC state machine to error */
;;;598          ADC_STATE_CLR_SET(hadc->State,
;;;599                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;600                            HAL_ADC_STATE_ERROR_INTERNAL);
;;;601          
;;;602          /* Set ADC error code to ADC IP internal error */
;;;603          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;604          
;;;605          tmp_hal_status = HAL_ERROR;
;;;606        }
;;;607      
;;;608      }
;;;609      else
;;;610      {
;;;611        /* Update ADC state machine to error */
;;;612        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;613            
;;;614        tmp_hal_status = HAL_ERROR;
;;;615      }
;;;616      
;;;617      /* Return function status */
;;;618      return tmp_hal_status;
;;;619    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L16.28|
00001c  62e6              STR      r6,[r4,#0x2c]         ;451
00001e  f8846024          STRB     r6,[r4,#0x24]         ;454
000022  4620              MOV      r0,r4                 ;473
000024  f7fffffe          BL       HAL_ADC_MspInit
                  |L16.40|
000028  4620              MOV      r0,r4                 ;482
00002a  f7fffffe          BL       ADC_ConversionStop_Disable
00002e  6aa1              LDR      r1,[r4,#0x28]         ;487
000030  06c9              LSLS     r1,r1,#27             ;487
000032  d400              BMI      |L16.54|
000034  b128              CBZ      r0,|L16.66|
                  |L16.54|
000036  6aa0              LDR      r0,[r4,#0x28]         ;612
000038  f0400010          ORR      r0,r0,#0x10           ;612
00003c  62a0              STR      r0,[r4,#0x28]         ;612
00003e  2001              MOVS     r0,#1                 ;614
000040  e7ea              B        |L16.24|
                  |L16.66|
000042  6aa1              LDR      r1,[r4,#0x28]         ;491
000044  f4215188          BIC      r1,r1,#0x1100         ;491
000048  f0410102          ORR      r1,r1,#2              ;491
00004c  62a1              STR      r1,[r4,#0x28]         ;491
00004e  6862              LDR      r2,[r4,#4]            ;507
000050  69e1              LDR      r1,[r4,#0x1c]         ;507
000052  7b23              LDRB     r3,[r4,#0xc]          ;507
000054  430a              ORRS     r2,r2,r1              ;507
000056  ea470143          ORR      r1,r7,r3,LSL #1       ;507
00005a  430a              ORRS     r2,r2,r1              ;507
00005c  68a1              LDR      r1,[r4,#8]            ;515
00005e  f44f7780          MOV      r7,#0x100             ;515
000062  42b9              CMP      r1,r7                 ;515
000064  d008              BEQ      |L16.120|
000066  2901              CMP      r1,#1                 ;515
000068  d006              BEQ      |L16.120|
00006a  2100              MOVS     r1,#0                 ;515
                  |L16.108|
00006c  f894c014          LDRB     r12,[r4,#0x14]        ;520
000070  f1bc0f01          CMP      r12,#1                ;520
000074  d002              BEQ      |L16.124|
000076  e00a              B        |L16.142|
                  |L16.120|
000078  4639              MOV      r1,r7                 ;515
00007a  e7f7              B        |L16.108|
                  |L16.124|
00007c  b1f3              CBZ      r3,|L16.188|
00007e  6aa3              LDR      r3,[r4,#0x28]         ;535
000080  f0430320          ORR      r3,r3,#0x20           ;535
000084  62a3              STR      r3,[r4,#0x28]         ;535
000086  6ae3              LDR      r3,[r4,#0x2c]         ;538
000088  f0430301          ORR      r3,r3,#1              ;538
00008c  62e3              STR      r3,[r4,#0x2c]         ;538
                  |L16.142|
00008e  6823              LDR      r3,[r4,#0]            ;543
000090  f8d3c004          LDR      r12,[r3,#4]           ;543
000094  f42c4c69          BIC      r12,r12,#0xe900       ;543
000098  ea4c0c01          ORR      r12,r12,r1            ;543
00009c  f8c3c004          STR      r12,[r3,#4]           ;543
0000a0  6821              LDR      r1,[r4,#0]            ;550
0000a2  688b              LDR      r3,[r1,#8]            ;550
0000a4  f8dfc068          LDR      r12,|L16.272|
0000a8  ea03030c          AND      r3,r3,r12             ;550
0000ac  4313              ORRS     r3,r3,r2              ;550
0000ae  608b              STR      r3,[r1,#8]            ;550
0000b0  68a1              LDR      r1,[r4,#8]            ;566
0000b2  42b9              CMP      r1,r7                 ;566
0000b4  d009              BEQ      |L16.202|
0000b6  2901              CMP      r1,#1                 ;566
0000b8  d007              BEQ      |L16.202|
0000ba  e009              B        |L16.208|
                  |L16.188|
0000bc  69a3              LDR      r3,[r4,#0x18]         ;526
0000be  1e5b              SUBS     r3,r3,#1              ;526
0000c0  ea413143          ORR      r1,r1,r3,LSL #13      ;526
0000c4  f4416100          ORR      r1,r1,#0x800          ;526
0000c8  e7e1              B        |L16.142|
                  |L16.202|
0000ca  8a21              LDRH     r1,[r4,#0x10]         ;568
0000cc  1e49              SUBS     r1,r1,#1              ;568
0000ce  050d              LSLS     r5,r1,#20             ;568
                  |L16.208|
0000d0  6821              LDR      r1,[r4,#0]            ;571
0000d2  6acb              LDR      r3,[r1,#0x2c]         ;571
0000d4  f4230370          BIC      r3,r3,#0xf00000       ;571
0000d8  432b              ORRS     r3,r3,r5              ;571
0000da  62cb              STR      r3,[r1,#0x2c]         ;571
0000dc  6821              LDR      r1,[r4,#0]            ;581
0000de  6889              LDR      r1,[r1,#8]            ;581
0000e0  4b0c              LDR      r3,|L16.276|
0000e2  4019              ANDS     r1,r1,r3              ;581
0000e4  4291              CMP      r1,r2                 ;581
0000e6  d107              BNE      |L16.248|
0000e8  62e6              STR      r6,[r4,#0x2c]         ;588
0000ea  6aa1              LDR      r1,[r4,#0x28]         ;591
0000ec  f0210102          BIC      r1,r1,#2              ;591
0000f0  f0410101          ORR      r1,r1,#1              ;591
0000f4  62a1              STR      r1,[r4,#0x28]         ;591
0000f6  e78f              B        |L16.24|
                  |L16.248|
0000f8  6aa0              LDR      r0,[r4,#0x28]         ;598
0000fa  f0200002          BIC      r0,r0,#2              ;598
0000fe  f0400010          ORR      r0,r0,#0x10           ;598
000102  62a0              STR      r0,[r4,#0x28]         ;598
000104  6ae0              LDR      r0,[r4,#0x2c]         ;603
000106  f0400001          ORR      r0,r0,#1              ;603
00010a  62e0              STR      r0,[r4,#0x2c]         ;603
00010c  2001              MOVS     r0,#1                 ;605
00010e  e783              B        |L16.24|
;;;620    
                          ENDP

                  |L16.272|
                          DCD      0xffe1f7fd
                  |L16.276|
                          DCD      0xff1f0efe

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1936     */
;;;1937   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1938   {
;;;1939     /* Prevent unused argument(s) compilation warning */
;;;1940     UNUSED(hadc);
;;;1941     /* NOTE : This function should not be modified. When the callback is needed,
;;;1942               function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
;;;1943     */
;;;1944   }
;;;1945   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;790      */
;;;791    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;792    {
;;;793      /* Prevent unused argument(s) compilation warning */
;;;794      UNUSED(hadc);
;;;795      /* NOTE : This function should not be modified. When the callback is needed,
;;;796                function HAL_ADC_MspDeInit must be implemented in the user file.
;;;797       */ 
;;;798    }
;;;799    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;776      */
;;;777    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;778    {
;;;779      /* Prevent unused argument(s) compilation warning */
;;;780      UNUSED(hadc);
;;;781      /* NOTE : This function should not be modified. When the callback is needed,
;;;782                function HAL_ADC_MspInit must be implemented in the user file.
;;;783       */ 
;;;784    }
;;;785    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=2

                  HAL_ADC_PollForConversion PROC
;;;1192     */
;;;1193   HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1194   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1195     uint32_t tickstart = 0U;
;;;1196     
;;;1197     /* Variables for polling in case of scan mode enabled and polling for each  */
;;;1198     /* conversion.                                                              */
;;;1199     __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
000008  f04f0800          MOV      r8,#0
00000c  f8cd8000          STR      r8,[sp,#0]
;;;1200     uint32_t Conversion_Timeout_CPU_cycles_max = 0U;
;;;1201    
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1204     
;;;1205     /* Get tick count */
;;;1206     tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4606              MOV      r6,r0
;;;1207     
;;;1208     /* Verification that ADC configuration is compliant with polling for        */
;;;1209     /* each conversion:                                                         */
;;;1210     /* Particular case is ADC configured in DMA mode                            */
;;;1211     if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
000016  6820              LDR      r0,[r4,#0]
000018  6881              LDR      r1,[r0,#8]
00001a  05c9              LSLS     r1,r1,#23
00001c  d508              BPL      |L20.48|
;;;1212     {
;;;1213       /* Update ADC state machine to error */
;;;1214       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00001e  6aa0              LDR      r0,[r4,#0x28]
000020  f0400020          ORR      r0,r0,#0x20
000024  62a0              STR      r0,[r4,#0x28]
;;;1215       
;;;1216       /* Process unlocked */
;;;1217       __HAL_UNLOCK(hadc);
000026  f8848024          STRB     r8,[r4,#0x24]
;;;1218       
;;;1219       return HAL_ERROR;
00002a  2001              MOVS     r0,#1
                  |L20.44|
;;;1220     }
;;;1221     
;;;1222     /* Polling for end of conversion: differentiation if single/sequence        */
;;;1223     /* conversion.                                                              */
;;;1224     /*  - If single conversion for regular group (Scan mode disabled or enabled */
;;;1225     /*    with NbrOfConversion =1), flag EOC is used to determine the           */
;;;1226     /*    conversion completion.                                                */
;;;1227     /*  - If sequence conversion for regular group (scan mode enabled and       */
;;;1228     /*    NbrOfConversion >=2), flag EOC is set only at the end of the          */
;;;1229     /*    sequence.                                                             */
;;;1230     /*    To poll for each conversion, the maximum conversion time is computed  */
;;;1231     /*    from ADC conversion time (selected sampling time + conversion time of */
;;;1232     /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
;;;1233     /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
;;;1234     /*    As flag EOC is not set after each conversion, no timeout status can   */
;;;1235     /*    be set.                                                               */
;;;1236     if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
;;;1237         HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
;;;1238     {
;;;1239       /* Wait until End of Conversion flag is raised */
;;;1240       while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
;;;1241       {
;;;1242         /* Check if timeout is disabled (set to infinite wait) */
;;;1243         if(Timeout != HAL_MAX_DELAY)
;;;1244         {
;;;1245           if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;1246           {
;;;1247             /* New check to avoid false timeout detection in case of preemption */
;;;1248             if(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
;;;1249             {
;;;1250               /* Update ADC state machine to timeout */
;;;1251               SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;1252               
;;;1253               /* Process unlocked */
;;;1254               __HAL_UNLOCK(hadc);
;;;1255               
;;;1256               return HAL_TIMEOUT;
;;;1257             }
;;;1258           }
;;;1259         }
;;;1260       }
;;;1261     }
;;;1262     else
;;;1263     {
;;;1264       /* Replace polling by wait for maximum conversion time */
;;;1265       /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
;;;1266       /*    and ADC maximum conversion cycles on all channels.                  */
;;;1267       /*  - Wait for the expected ADC clock cycles delay                        */
;;;1268       Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
;;;1269                                             / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;1270                                            * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
;;;1271       
;;;1272       while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;1273       {
;;;1274         /* Check if timeout is disabled (set to infinite wait) */
;;;1275         if(Timeout != HAL_MAX_DELAY)
;;;1276         {
;;;1277           if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
;;;1278           {
;;;1279             /* New check to avoid false timeout detection in case of preemption */
;;;1280             if(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;1281             {
;;;1282               /* Update ADC state machine to timeout */
;;;1283               SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;1284   
;;;1285               /* Process unlocked */
;;;1286               __HAL_UNLOCK(hadc);
;;;1287   
;;;1288               return HAL_TIMEOUT;
;;;1289             }
;;;1290           }
;;;1291         }
;;;1292         Conversion_Timeout_CPU_cycles ++;
;;;1293       }
;;;1294     }
;;;1295     
;;;1296     /* Clear regular group conversion flag */
;;;1297     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
;;;1298     
;;;1299     /* Update ADC state machine */
;;;1300     SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;1301     
;;;1302     /* Determine whether any further conversion upcoming on group regular       */
;;;1303     /* by external trigger, continuous mode or scan sequence on going.          */
;;;1304     /* Note: On STM32F1 devices, in case of sequencer enabled                   */
;;;1305     /*       (several ranks selected), end of conversion flag is raised         */
;;;1306     /*       at the end of the sequence.                                        */
;;;1307     if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
;;;1308        (hadc->Init.ContinuousConvMode == DISABLE)   )
;;;1309     {   
;;;1310       /* Set ADC state */
;;;1311       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;1312   
;;;1313       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1314       { 
;;;1315         SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;1316       }
;;;1317     }
;;;1318     
;;;1319     /* Return ADC state */
;;;1320     return HAL_OK;
;;;1321   }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L20.48|
000030  6841              LDR      r1,[r0,#4]            ;1236
000032  05c9              LSLS     r1,r1,#23             ;1236
000034  d403              BMI      |L20.62|
000036  6ac0              LDR      r0,[r0,#0x2c]         ;1237
000038  f4100f70          TST      r0,#0xf00000          ;1237
00003c  d031              BEQ      |L20.162|
                  |L20.62|
00003e  2002              MOVS     r0,#2                 ;1268
000040  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000044  493e              LDR      r1,|L20.320|
000046  6809              LDR      r1,[r1,#0]            ;1268  ; SystemCoreClock
000048  fbb1f7f0          UDIV     r7,r1,r0              ;1268
00004c  6820              LDR      r0,[r4,#0]            ;1268
00004e  6901              LDR      r1,[r0,#0x10]         ;1268
000050  4a3c              LDR      r2,|L20.324|
000052  4211              TST      r1,r2                 ;1268
000054  ea4f0262          ASR      r2,r2,#1              ;1270
000058  ea4f13a2          ASR      r3,r2,#6              ;1270
00005c  d126              BNE      |L20.172|
00005e  68c1              LDR      r1,[r0,#0xc]          ;1270
000060  ea4f1c62          ASR      r12,r2,#5             ;1270
000064  ea110f0c          TST      r1,r12                ;1270
000068  d120              BNE      |L20.172|
00006a  6901              LDR      r1,[r0,#0x10]         ;1270
00006c  4211              TST      r1,r2                 ;1270
00006e  d12c              BNE      |L20.202|
000070  68c0              LDR      r0,[r0,#0xc]          ;1270
000072  4218              TST      r0,r3                 ;1270
000074  d129              BNE      |L20.202|
000076  2014              MOVS     r0,#0x14              ;1270
000078  e02a              B        |L20.208|
                  |L20.122|
00007a  1c68              ADDS     r0,r5,#1              ;1243
00007c  d011              BEQ      |L20.162|
00007e  b125              CBZ      r5,|L20.138|
000080  f7fffffe          BL       HAL_GetTick
000084  1b80              SUBS     r0,r0,r6              ;1245
000086  42a8              CMP      r0,r5                 ;1245
000088  d90b              BLS      |L20.162|
                  |L20.138|
00008a  6820              LDR      r0,[r4,#0]            ;1248
00008c  6800              LDR      r0,[r0,#0]            ;1248
00008e  0780              LSLS     r0,r0,#30             ;1248
000090  d407              BMI      |L20.162|
000092  6aa0              LDR      r0,[r4,#0x28]         ;1251
000094  f0400004          ORR      r0,r0,#4              ;1251
000098  62a0              STR      r0,[r4,#0x28]         ;1251
00009a  f8848024          STRB     r8,[r4,#0x24]         ;1254
00009e  2003              MOVS     r0,#3                 ;1256
0000a0  e7c4              B        |L20.44|
                  |L20.162|
0000a2  6820              LDR      r0,[r4,#0]            ;1240
0000a4  6800              LDR      r0,[r0,#0]            ;1240
0000a6  0780              LSLS     r0,r0,#30             ;1240
0000a8  d5e7              BPL      |L20.122|
0000aa  e02c              B        |L20.262|
                  |L20.172|
0000ac  6901              LDR      r1,[r0,#0x10]         ;1270
0000ae  4211              TST      r1,r2                 ;1270
0000b0  d102              BNE      |L20.184|
0000b2  68c1              LDR      r1,[r0,#0xc]          ;1270
0000b4  4219              TST      r1,r3                 ;1270
0000b6  d006              BEQ      |L20.198|
                  |L20.184|
0000b8  6902              LDR      r2,[r0,#0x10]         ;1270
0000ba  4923              LDR      r1,|L20.328|
0000bc  420a              TST      r2,r1                 ;1270
0000be  d106              BNE      |L20.206|
0000c0  68c0              LDR      r0,[r0,#0xc]          ;1270
0000c2  4208              TST      r0,r1                 ;1270
0000c4  d103              BNE      |L20.206|
                  |L20.198|
0000c6  2054              MOVS     r0,#0x54              ;1270
0000c8  e002              B        |L20.208|
                  |L20.202|
0000ca  2029              MOVS     r0,#0x29              ;1270
0000cc  e000              B        |L20.208|
                  |L20.206|
0000ce  20fc              MOVS     r0,#0xfc              ;1270
                  |L20.208|
0000d0  4347              MULS     r7,r0,r7              ;1270
0000d2  e015              B        |L20.256|
                  |L20.212|
0000d4  1c68              ADDS     r0,r5,#1              ;1275
0000d6  d010              BEQ      |L20.250|
0000d8  b125              CBZ      r5,|L20.228|
0000da  f7fffffe          BL       HAL_GetTick
0000de  1b80              SUBS     r0,r0,r6              ;1277
0000e0  42a8              CMP      r0,r5                 ;1277
0000e2  d90a              BLS      |L20.250|
                  |L20.228|
0000e4  9800              LDR      r0,[sp,#0]            ;1280
0000e6  42b8              CMP      r0,r7                 ;1280
0000e8  d207              BCS      |L20.250|
0000ea  6aa0              LDR      r0,[r4,#0x28]         ;1283
0000ec  f0400004          ORR      r0,r0,#4              ;1283
0000f0  62a0              STR      r0,[r4,#0x28]         ;1283
0000f2  f8848024          STRB     r8,[r4,#0x24]         ;1286
0000f6  2003              MOVS     r0,#3                 ;1288
0000f8  e798              B        |L20.44|
                  |L20.250|
0000fa  9800              LDR      r0,[sp,#0]            ;1292
0000fc  1c40              ADDS     r0,r0,#1              ;1292
0000fe  9000              STR      r0,[sp,#0]            ;1292
                  |L20.256|
000100  9800              LDR      r0,[sp,#0]            ;1272
000102  42b8              CMP      r0,r7                 ;1272
000104  d3e6              BCC      |L20.212|
                  |L20.262|
000106  6821              LDR      r1,[r4,#0]            ;1297
000108  f06f0012          MVN      r0,#0x12              ;1297
00010c  6008              STR      r0,[r1,#0]            ;1297
00010e  6aa0              LDR      r0,[r4,#0x28]         ;1300
000110  f4407000          ORR      r0,r0,#0x200          ;1300
000114  62a0              STR      r0,[r4,#0x28]         ;1300
000116  6820              LDR      r0,[r4,#0]            ;1307
000118  6880              LDR      r0,[r0,#8]            ;1307
00011a  f3c04042          UBFX     r0,r0,#17,#3          ;1307
00011e  2807              CMP      r0,#7                 ;1307
000120  d10c              BNE      |L20.316|
000122  7b20              LDRB     r0,[r4,#0xc]          ;1308
000124  b950              CBNZ     r0,|L20.316|
000126  6aa0              LDR      r0,[r4,#0x28]         ;1311
000128  f4207080          BIC      r0,r0,#0x100          ;1311
00012c  62a0              STR      r0,[r4,#0x28]         ;1311
00012e  6aa0              LDR      r0,[r4,#0x28]         ;1313
000130  04c0              LSLS     r0,r0,#19             ;1313
000132  d403              BMI      |L20.316|
000134  6aa0              LDR      r0,[r4,#0x28]         ;1315
000136  f0400001          ORR      r0,r0,#1              ;1315
00013a  62a0              STR      r0,[r4,#0x28]         ;1315
                  |L20.316|
00013c  2000              MOVS     r0,#0                 ;1320
00013e  e775              B        |L20.44|
;;;1322   
                          ENDP

                  |L20.320|
                          DCD      SystemCoreClock
                  |L20.324|
                          DCD      0x24924924
                  |L20.328|
                          DCD      0x00249249

                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;1331     */
;;;1332   HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1333   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1334     uint32_t tickstart = 0U; 
;;;1335   
;;;1336     /* Check the parameters */
;;;1337     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1338     assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;1339     
;;;1340     /* Get tick count */
;;;1341     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4607              MOV      r7,r0
;;;1342     
;;;1343     /* Check selected event flag */
;;;1344     while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
000010  e016              B        |L21.64|
                  |L21.18|
;;;1345     {
;;;1346       /* Check if timeout is disabled (set to infinite wait) */
;;;1347       if(Timeout != HAL_MAX_DELAY)
000012  1c68              ADDS     r0,r5,#1
000014  d014              BEQ      |L21.64|
;;;1348       {
;;;1349         if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
000016  b125              CBZ      r5,|L21.34|
000018  f7fffffe          BL       HAL_GetTick
00001c  1bc0              SUBS     r0,r0,r7
00001e  42a8              CMP      r0,r5
000020  d90e              BLS      |L21.64|
                  |L21.34|
;;;1350         {
;;;1351           /* New check to avoid false timeout detection in case of preemption */
;;;1352           if(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  ea360000          BICS     r0,r6,r0
00002a  d009              BEQ      |L21.64|
;;;1353           {
;;;1354             /* Update ADC state machine to timeout */
;;;1355             SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
00002c  6aa0              LDR      r0,[r4,#0x28]
00002e  f0400004          ORR      r0,r0,#4
000032  62a0              STR      r0,[r4,#0x28]
;;;1356   
;;;1357             /* Process unlocked */
;;;1358             __HAL_UNLOCK(hadc);
000034  2000              MOVS     r0,#0
000036  f8840024          STRB     r0,[r4,#0x24]
;;;1359   
;;;1360             return HAL_TIMEOUT;
00003a  2003              MOVS     r0,#3
                  |L21.60|
;;;1361           }
;;;1362         }
;;;1363       }
;;;1364     }
;;;1365     
;;;1366     /* Analog watchdog (level out of window) event */
;;;1367     /* Set ADC state */
;;;1368     SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;1369       
;;;1370     /* Clear ADC analog watchdog flag */
;;;1371     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;1372     
;;;1373     /* Return ADC state */
;;;1374     return HAL_OK;
;;;1375   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L21.64|
000040  6820              LDR      r0,[r4,#0]            ;1344
000042  6800              LDR      r0,[r0,#0]            ;1344
000044  ea360000          BICS     r0,r6,r0              ;1344
000048  d1e3              BNE      |L21.18|
00004a  6aa0              LDR      r0,[r4,#0x28]         ;1368
00004c  f4403080          ORR      r0,r0,#0x10000        ;1368
000050  62a0              STR      r0,[r4,#0x28]         ;1368
000052  6821              LDR      r1,[r4,#0]            ;1371
000054  f06f0001          MVN      r0,#1                 ;1371
000058  6008              STR      r0,[r1,#0]            ;1371
00005a  2000              MOVS     r0,#0                 ;1374
00005c  e7ee              B        |L21.60|
;;;1376   
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;1035     */
;;;1036   HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1037   {
000002  4604              MOV      r4,r0
;;;1038     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1039     
;;;1040     /* Check the parameters */
;;;1041     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1042     
;;;1043     /* Process locked */
;;;1044     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L22.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1045      
;;;1046     /* Enable the ADC peripheral */
;;;1047     tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;1048     
;;;1049     /* Start conversion if ADC is effectively enabled */
;;;1050     if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L22.42|
;;;1051     {
;;;1052       /* Set ADC state                                                          */
;;;1053       /* - Clear state bitfield related to regular group conversion results     */
;;;1054       /* - Set state bitfield related to regular operation                      */
;;;1055       ADC_STATE_CLR_SET(hadc->State,
;;;1056                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC,
;;;1057                         HAL_ADC_STATE_REG_BUSY);
;;;1058       
;;;1059       /* Set group injected state (from auto-injection) and multimode state     */
;;;1060       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1061       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1062       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1063       {
;;;1064         /* Set ADC state (ADC independent or master) */
;;;1065         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1066         
;;;1067         /* If conversions on group regular are also triggering group injected,  */
;;;1068         /* update ADC state.                                                    */
;;;1069         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1070         {
;;;1071           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1072         }
;;;1073       }
;;;1074       else
;;;1075       {
;;;1076         /* Set ADC state (ADC slave) */
;;;1077         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1078         
;;;1079         /* If conversions on group regular are also triggering group injected,  */
;;;1080         /* update ADC state.                                                    */
;;;1081         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1082         {
;;;1083           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1084         }
;;;1085       }
;;;1086       
;;;1087       /* State machine update: Check if an injected conversion is ongoing */
;;;1088       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1089       {
;;;1090         /* Reset ADC error code fields related to conversions on group regular */
;;;1091         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1092       }
;;;1093       else
;;;1094       {
;;;1095         /* Reset ADC all error code fields */
;;;1096         ADC_CLEAR_ERRORCODE(hadc);
;;;1097       }
;;;1098       
;;;1099       /* Process unlocked */
;;;1100       /* Unlock before starting ADC conversions: in case of potential           */
;;;1101       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1102       __HAL_UNLOCK(hadc);
;;;1103     
;;;1104       /* Clear regular group conversion flag */
;;;1105       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1106       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1107       
;;;1108       /* Enable conversion of regular group.                                    */
;;;1109       /* If software start has been selected, conversion starts immediately.    */
;;;1110       /* If external trigger has been selected, conversion will start at next   */
;;;1111       /* trigger event.                                                         */
;;;1112       /* Case of multimode enabled:                                             */ 
;;;1113       /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
;;;1114       /*  - if ADC is master, ADC is enabled and conversion is started.         */
;;;1115       /* If ADC is master, ADC is enabled and conversion is started.            */
;;;1116       /* Note: Alternate trigger for single conversion could be to force an     */
;;;1117       /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
;;;1118       if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
;;;1119           ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;1120       {
;;;1121         /* Start ADC conversion on regular group with SW start */
;;;1122         SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1123       }
;;;1124       else
;;;1125       {
;;;1126         /* Start ADC conversion on regular group with external trigger */
;;;1127         SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1128       }
;;;1129     }
;;;1130     else
;;;1131     {
;;;1132       /* Process unlocked */
;;;1133       __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L22.34|
;;;1134     }
;;;1135       
;;;1136     /* Return function status */
;;;1137     return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;1138   }
000024  bd70              POP      {r4-r6,pc}
                  |L22.38|
000026  2002              MOVS     r0,#2                 ;1044
000028  bd70              POP      {r4-r6,pc}
                  |L22.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;1055
00002c  f2402301          MOV      r3,#0x201             ;1055
000030  4398              BICS     r0,r0,r3              ;1055
000032  f4407080          ORR      r0,r0,#0x100          ;1055
000036  62a0              STR      r0,[r4,#0x28]         ;1055
000038  4d23              LDR      r5,|L22.200|
00003a  6820              LDR      r0,[r4,#0]            ;1062
00003c  4b23              LDR      r3,|L22.204|
00003e  42a8              CMP      r0,r5                 ;1062
000040  d118              BNE      |L22.116|
000042  681e              LDR      r6,[r3,#0]            ;1062
000044  f4162f70          TST      r6,#0xf0000           ;1062
000048  d014              BEQ      |L22.116|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;1077
00004c  f4461680          ORR      r6,r6,#0x100000       ;1077
000050  62a6              STR      r6,[r4,#0x28]         ;1077
000052  681e              LDR      r6,[r3,#0]            ;1081
000054  0576              LSLS     r6,r6,#21             ;1081
000056  d505              BPL      |L22.100|
000058  6aa6              LDR      r6,[r4,#0x28]         ;1083
00005a  f4265600          BIC      r6,r6,#0x2000         ;1083
00005e  f4465680          ORR      r6,r6,#0x1000         ;1083
000062  62a6              STR      r6,[r4,#0x28]         ;1083
                  |L22.100|
000064  6aa6              LDR      r6,[r4,#0x28]         ;1088
000066  04f6              LSLS     r6,r6,#19             ;1088
000068  d512              BPL      |L22.144|
00006a  6ae6              LDR      r6,[r4,#0x2c]         ;1091
00006c  f0260606          BIC      r6,r6,#6              ;1091
000070  62e6              STR      r6,[r4,#0x2c]         ;1091
000072  e00e              B        |L22.146|
                  |L22.116|
000074  6aa6              LDR      r6,[r4,#0x28]         ;1065
000076  f4261680          BIC      r6,r6,#0x100000       ;1065
00007a  62a6              STR      r6,[r4,#0x28]         ;1065
00007c  6846              LDR      r6,[r0,#4]            ;1069
00007e  0576              LSLS     r6,r6,#21             ;1069
000080  d5f0              BPL      |L22.100|
000082  6aa6              LDR      r6,[r4,#0x28]         ;1071
000084  f4265600          BIC      r6,r6,#0x2000         ;1071
000088  f4465680          ORR      r6,r6,#0x1000         ;1071
00008c  62a6              STR      r6,[r4,#0x28]         ;1071
00008e  e7e9              B        |L22.100|
                  |L22.144|
000090  62e2              STR      r2,[r4,#0x2c]         ;1096
                  |L22.146|
000092  f8842024          STRB     r2,[r4,#0x24]         ;1102
000096  f06f0202          MVN      r2,#2                 ;1106
00009a  6002              STR      r2,[r0,#0]            ;1106
00009c  6820              LDR      r0,[r4,#0]            ;1118
00009e  6882              LDR      r2,[r0,#8]            ;1118
0000a0  f3c24242          UBFX     r2,r2,#17,#3          ;1118
0000a4  2a07              CMP      r2,#7                 ;1118
0000a6  d105              BNE      |L22.180|
0000a8  42a8              CMP      r0,r5                 ;1119
0000aa  d108              BNE      |L22.190|
0000ac  681a              LDR      r2,[r3,#0]            ;1119
0000ae  f4122f70          TST      r2,#0xf0000           ;1119
0000b2  d004              BEQ      |L22.190|
                  |L22.180|
0000b4  6882              LDR      r2,[r0,#8]            ;1127
0000b6  f4421280          ORR      r2,r2,#0x100000       ;1127
0000ba  6082              STR      r2,[r0,#8]            ;1127
0000bc  e7b1              B        |L22.34|
                  |L22.190|
0000be  6882              LDR      r2,[r0,#8]            ;1122
0000c0  f44202a0          ORR      r2,r2,#0x500000       ;1122
0000c4  6082              STR      r2,[r0,#8]            ;1122
0000c6  e7ac              B        |L22.34|
;;;1139   
                          ENDP

                  |L22.200|
                          DCD      0x40012800
                  |L22.204|
                          DCD      0x40012404

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;1552     */
;;;1553   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1554   {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
;;;1555     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1556     
;;;1557     /* Check the parameters */
;;;1558     assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
;;;1559       
;;;1560     /* Verification if multimode is disabled (for devices with several ADC)     */
;;;1561     /* If multimode is enabled, dedicated function multimode conversion         */
;;;1562     /* start DMA must be used.                                                  */
;;;1563     if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
00000a  f8df8100          LDR      r8,|L23.268|
00000e  6820              LDR      r0,[r4,#0]
000010  4f3f              LDR      r7,|L23.272|
000012  f1080604          ADD      r6,r8,#4
000016  4540              CMP      r0,r8
000018  d001              BEQ      |L23.30|
00001a  42b8              CMP      r0,r7
00001c  d107              BNE      |L23.46|
                  |L23.30|
00001e  6830              LDR      r0,[r6,#0]
000020  f4102f70          TST      r0,#0xf0000
000024  d003              BEQ      |L23.46|
;;;1564     {
;;;1565       /* Process locked */
;;;1566       __HAL_LOCK(hadc);
;;;1567       
;;;1568       /* Enable the ADC peripheral */
;;;1569       tmp_hal_status = ADC_Enable(hadc);
;;;1570       
;;;1571       /* Start conversion if ADC is effectively enabled */
;;;1572       if (tmp_hal_status == HAL_OK)
;;;1573       {
;;;1574         /* Set ADC state                                                        */
;;;1575         /* - Clear state bitfield related to regular group conversion results   */
;;;1576         /* - Set state bitfield related to regular operation                    */
;;;1577         ADC_STATE_CLR_SET(hadc->State,
;;;1578                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1579                           HAL_ADC_STATE_REG_BUSY);
;;;1580       
;;;1581       /* Set group injected state (from auto-injection) and multimode state     */
;;;1582       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1583       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1584       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1585       {
;;;1586         /* Set ADC state (ADC independent or master) */
;;;1587         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1588         
;;;1589         /* If conversions on group regular are also triggering group injected,  */
;;;1590         /* update ADC state.                                                    */
;;;1591         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1592         {
;;;1593           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1594         }
;;;1595       }
;;;1596       else
;;;1597       {
;;;1598         /* Set ADC state (ADC slave) */
;;;1599         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1600         
;;;1601         /* If conversions on group regular are also triggering group injected,  */
;;;1602         /* update ADC state.                                                    */
;;;1603         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1604         {
;;;1605           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1606         }
;;;1607       }
;;;1608         
;;;1609         /* State machine update: Check if an injected conversion is ongoing */
;;;1610         if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1611         {
;;;1612           /* Reset ADC error code fields related to conversions on group regular */
;;;1613           CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1614         }
;;;1615         else
;;;1616         {
;;;1617           /* Reset ADC all error code fields */
;;;1618           ADC_CLEAR_ERRORCODE(hadc);
;;;1619         }
;;;1620         
;;;1621         /* Process unlocked */
;;;1622         /* Unlock before starting ADC conversions: in case of potential         */
;;;1623         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1624         __HAL_UNLOCK(hadc);
;;;1625         
;;;1626         /* Set the DMA transfer complete callback */
;;;1627         hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;1628   
;;;1629         /* Set the DMA half transfer complete callback */
;;;1630         hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;1631         
;;;1632         /* Set the DMA error callback */
;;;1633         hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;1634   
;;;1635         
;;;1636         /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */
;;;1637         /* start (in case of SW start):                                         */
;;;1638         
;;;1639         /* Clear regular group conversion flag and overrun flag */
;;;1640         /* (To ensure of no unknown state from potential previous ADC           */
;;;1641         /* operations)                                                          */
;;;1642         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1643         
;;;1644         /* Enable ADC DMA mode */
;;;1645         SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;1646         
;;;1647         /* Start the DMA channel */
;;;1648         HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;1649         
;;;1650         /* Enable conversion of regular group.                                  */
;;;1651         /* If software start has been selected, conversion starts immediately.  */
;;;1652         /* If external trigger has been selected, conversion will start at next */
;;;1653         /* trigger event.                                                       */
;;;1654         if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
;;;1655         {
;;;1656           /* Start ADC conversion on regular group with SW start */
;;;1657           SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1658         }
;;;1659         else
;;;1660         {
;;;1661           /* Start ADC conversion on regular group with external trigger */
;;;1662           SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1663         }
;;;1664       }
;;;1665       else
;;;1666       {
;;;1667         /* Process unlocked */
;;;1668         __HAL_UNLOCK(hadc);
;;;1669       }
;;;1670     }
;;;1671     else
;;;1672     {
;;;1673       tmp_hal_status = HAL_ERROR;
000026  2501              MOVS     r5,#1
                  |L23.40|
;;;1674     }
;;;1675     
;;;1676     /* Return function status */
;;;1677     return tmp_hal_status;
000028  4628              MOV      r0,r5
                  |L23.42|
;;;1678   }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L23.46|
00002e  f8940024          LDRB     r0,[r4,#0x24]         ;1566
000032  2801              CMP      r0,#1                 ;1566
000034  d00b              BEQ      |L23.78|
000036  2001              MOVS     r0,#1                 ;1566
000038  f8840024          STRB     r0,[r4,#0x24]         ;1566
00003c  4620              MOV      r0,r4                 ;1569
00003e  f7fffffe          BL       ADC_Enable
000042  4605              MOV      r5,r0                 ;1569
000044  2100              MOVS     r1,#0                 ;1572
000046  b125              CBZ      r5,|L23.82|
000048  f8841024          STRB     r1,[r4,#0x24]         ;1668
00004c  e7ec              B        |L23.40|
                  |L23.78|
00004e  2002              MOVS     r0,#2                 ;1566
000050  e7eb              B        |L23.42|
                  |L23.82|
000052  6aa0              LDR      r0,[r4,#0x28]         ;1577
000054  f6406201          MOV      r2,#0xe01             ;1577
000058  4390              BICS     r0,r0,r2              ;1577
00005a  f4407080          ORR      r0,r0,#0x100          ;1577
00005e  62a0              STR      r0,[r4,#0x28]         ;1577
000060  6820              LDR      r0,[r4,#0]            ;1584
000062  42b8              CMP      r0,r7                 ;1584
000064  d118              BNE      |L23.152|
000066  6832              LDR      r2,[r6,#0]            ;1584
000068  f4122f70          TST      r2,#0xf0000           ;1584
00006c  d014              BEQ      |L23.152|
00006e  6aa2              LDR      r2,[r4,#0x28]         ;1599
000070  f4421280          ORR      r2,r2,#0x100000       ;1599
000074  62a2              STR      r2,[r4,#0x28]         ;1599
000076  6830              LDR      r0,[r6,#0]            ;1603
000078  0540              LSLS     r0,r0,#21             ;1603
00007a  d505              BPL      |L23.136|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;1605
00007e  f4205000          BIC      r0,r0,#0x2000         ;1605
000082  f4405080          ORR      r0,r0,#0x1000         ;1605
000086  62a0              STR      r0,[r4,#0x28]         ;1605
                  |L23.136|
000088  6aa0              LDR      r0,[r4,#0x28]         ;1610
00008a  04c0              LSLS     r0,r0,#19             ;1610
00008c  d512              BPL      |L23.180|
00008e  6ae0              LDR      r0,[r4,#0x2c]         ;1613
000090  f0200006          BIC      r0,r0,#6              ;1613
000094  62e0              STR      r0,[r4,#0x2c]         ;1613
000096  e00e              B        |L23.182|
                  |L23.152|
000098  6aa2              LDR      r2,[r4,#0x28]         ;1587
00009a  f4221280          BIC      r2,r2,#0x100000       ;1587
00009e  62a2              STR      r2,[r4,#0x28]         ;1587
0000a0  6840              LDR      r0,[r0,#4]            ;1591
0000a2  0540              LSLS     r0,r0,#21             ;1591
0000a4  d5f0              BPL      |L23.136|
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;1593
0000a8  f4205000          BIC      r0,r0,#0x2000         ;1593
0000ac  f4405080          ORR      r0,r0,#0x1000         ;1593
0000b0  62a0              STR      r0,[r4,#0x28]         ;1593
0000b2  e7e9              B        |L23.136|
                  |L23.180|
0000b4  62e1              STR      r1,[r4,#0x2c]         ;1618
                  |L23.182|
0000b6  f8841024          STRB     r1,[r4,#0x24]         ;1624
0000ba  6a21              LDR      r1,[r4,#0x20]         ;1627
0000bc  4815              LDR      r0,|L23.276|
0000be  6288              STR      r0,[r1,#0x28]         ;1627
0000c0  6a21              LDR      r1,[r4,#0x20]         ;1630
0000c2  4815              LDR      r0,|L23.280|
0000c4  62c8              STR      r0,[r1,#0x2c]         ;1630
0000c6  6a21              LDR      r1,[r4,#0x20]         ;1633
0000c8  4814              LDR      r0,|L23.284|
0000ca  6308              STR      r0,[r1,#0x30]         ;1633
0000cc  6821              LDR      r1,[r4,#0]            ;1642
0000ce  f06f0002          MVN      r0,#2                 ;1642
0000d2  6008              STR      r0,[r1,#0]            ;1642
0000d4  6820              LDR      r0,[r4,#0]            ;1645
0000d6  6881              LDR      r1,[r0,#8]            ;1645
0000d8  f4417180          ORR      r1,r1,#0x100          ;1645
0000dc  6081              STR      r1,[r0,#8]            ;1645
0000de  6821              LDR      r1,[r4,#0]            ;1648
0000e0  4653              MOV      r3,r10                ;1648
0000e2  314c              ADDS     r1,r1,#0x4c           ;1648
0000e4  464a              MOV      r2,r9                 ;1648
0000e6  6a20              LDR      r0,[r4,#0x20]         ;1648
0000e8  f7fffffe          BL       HAL_DMA_Start_IT
0000ec  6820              LDR      r0,[r4,#0]            ;1654
0000ee  6881              LDR      r1,[r0,#8]            ;1654
0000f0  f3c14142          UBFX     r1,r1,#17,#3          ;1654
0000f4  2907              CMP      r1,#7                 ;1654
0000f6  d004              BEQ      |L23.258|
0000f8  6881              LDR      r1,[r0,#8]            ;1662
0000fa  f4411180          ORR      r1,r1,#0x100000       ;1662
0000fe  6081              STR      r1,[r0,#8]            ;1662
000100  e792              B        |L23.40|
                  |L23.258|
000102  6881              LDR      r1,[r0,#8]            ;1657
000104  f44101a0          ORR      r1,r1,#0x500000       ;1657
000108  6081              STR      r1,[r0,#8]            ;1657
00010a  e78d              B        |L23.40|
;;;1679   
                          ENDP

                  |L23.268|
                          DCD      0x40012400
                  |L23.272|
                          DCD      0x40012800
                  |L23.276|
                          DCD      ADC_DMAConvCplt
                  |L23.280|
                          DCD      ADC_DMAHalfConvCplt
                  |L23.284|
                          DCD      ADC_DMAError

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;1384     */
;;;1385   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1386   {
000002  4604              MOV      r4,r0
;;;1387     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1388     
;;;1389     /* Check the parameters */
;;;1390     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1391     
;;;1392     /* Process locked */
;;;1393     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L24.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1394       
;;;1395     /* Enable the ADC peripheral */
;;;1396     tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;1397     
;;;1398     /* Start conversion if ADC is effectively enabled */
;;;1399     if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L24.42|
;;;1400     {
;;;1401       /* Set ADC state                                                          */
;;;1402       /* - Clear state bitfield related to regular group conversion results     */
;;;1403       /* - Set state bitfield related to regular operation                      */
;;;1404       ADC_STATE_CLR_SET(hadc->State,
;;;1405                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1406                         HAL_ADC_STATE_REG_BUSY);
;;;1407       
;;;1408       /* Set group injected state (from auto-injection) and multimode state     */
;;;1409       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1410       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1411       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1412       {
;;;1413         /* Set ADC state (ADC independent or master) */
;;;1414         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1415         
;;;1416         /* If conversions on group regular are also triggering group injected,  */
;;;1417         /* update ADC state.                                                    */
;;;1418         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1419         {
;;;1420           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1421         }
;;;1422       }
;;;1423       else
;;;1424       {
;;;1425         /* Set ADC state (ADC slave) */
;;;1426         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1427         
;;;1428         /* If conversions on group regular are also triggering group injected,  */
;;;1429         /* update ADC state.                                                    */
;;;1430         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1431         {
;;;1432           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1433         }
;;;1434       }
;;;1435       
;;;1436       /* State machine update: Check if an injected conversion is ongoing */
;;;1437       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1438       {
;;;1439         /* Reset ADC error code fields related to conversions on group regular */
;;;1440         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1441       }
;;;1442       else
;;;1443       {
;;;1444         /* Reset ADC all error code fields */
;;;1445         ADC_CLEAR_ERRORCODE(hadc);
;;;1446       }
;;;1447       
;;;1448       /* Process unlocked */
;;;1449       /* Unlock before starting ADC conversions: in case of potential           */
;;;1450       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1451       __HAL_UNLOCK(hadc);
;;;1452       
;;;1453       /* Clear regular group conversion flag and overrun flag */
;;;1454       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1455       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1456       
;;;1457       /* Enable end of conversion interrupt for regular group */
;;;1458       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
;;;1459       
;;;1460       /* Enable conversion of regular group.                                    */
;;;1461       /* If software start has been selected, conversion starts immediately.    */
;;;1462       /* If external trigger has been selected, conversion will start at next   */
;;;1463       /* trigger event.                                                         */
;;;1464       /* Case of multimode enabled:                                             */ 
;;;1465       /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
;;;1466       /*  - if ADC is master, ADC is enabled and conversion is started.         */
;;;1467       if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
;;;1468           ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;1469       {
;;;1470         /* Start ADC conversion on regular group with SW start */
;;;1471         SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1472       }
;;;1473       else
;;;1474       {
;;;1475         /* Start ADC conversion on regular group with external trigger */
;;;1476         SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1477       }
;;;1478     }
;;;1479     else
;;;1480     {
;;;1481       /* Process unlocked */
;;;1482       __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L24.34|
;;;1483     }
;;;1484     
;;;1485     /* Return function status */
;;;1486     return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;1487   }
000024  bd70              POP      {r4-r6,pc}
                  |L24.38|
000026  2002              MOVS     r0,#2                 ;1393
000028  bd70              POP      {r4-r6,pc}
                  |L24.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;1404
00002c  f6406301          MOV      r3,#0xe01             ;1404
000030  4398              BICS     r0,r0,r3              ;1404
000032  f4407080          ORR      r0,r0,#0x100          ;1404
000036  62a0              STR      r0,[r4,#0x28]         ;1404
000038  4d26              LDR      r5,|L24.212|
00003a  6820              LDR      r0,[r4,#0]            ;1411
00003c  4b26              LDR      r3,|L24.216|
00003e  42a8              CMP      r0,r5                 ;1411
000040  d118              BNE      |L24.116|
000042  681e              LDR      r6,[r3,#0]            ;1411
000044  f4162f70          TST      r6,#0xf0000           ;1411
000048  d014              BEQ      |L24.116|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;1426
00004c  f4461680          ORR      r6,r6,#0x100000       ;1426
000050  62a6              STR      r6,[r4,#0x28]         ;1426
000052  681e              LDR      r6,[r3,#0]            ;1430
000054  0576              LSLS     r6,r6,#21             ;1430
000056  d505              BPL      |L24.100|
000058  6aa6              LDR      r6,[r4,#0x28]         ;1432
00005a  f4265600          BIC      r6,r6,#0x2000         ;1432
00005e  f4465680          ORR      r6,r6,#0x1000         ;1432
000062  62a6              STR      r6,[r4,#0x28]         ;1432
                  |L24.100|
000064  6aa6              LDR      r6,[r4,#0x28]         ;1437
000066  04f6              LSLS     r6,r6,#19             ;1437
000068  d512              BPL      |L24.144|
00006a  6ae6              LDR      r6,[r4,#0x2c]         ;1440
00006c  f0260606          BIC      r6,r6,#6              ;1440
000070  62e6              STR      r6,[r4,#0x2c]         ;1440
000072  e00e              B        |L24.146|
                  |L24.116|
000074  6aa6              LDR      r6,[r4,#0x28]         ;1414
000076  f4261680          BIC      r6,r6,#0x100000       ;1414
00007a  62a6              STR      r6,[r4,#0x28]         ;1414
00007c  6846              LDR      r6,[r0,#4]            ;1418
00007e  0576              LSLS     r6,r6,#21             ;1418
000080  d5f0              BPL      |L24.100|
000082  6aa6              LDR      r6,[r4,#0x28]         ;1420
000084  f4265600          BIC      r6,r6,#0x2000         ;1420
000088  f4465680          ORR      r6,r6,#0x1000         ;1420
00008c  62a6              STR      r6,[r4,#0x28]         ;1420
00008e  e7e9              B        |L24.100|
                  |L24.144|
000090  62e2              STR      r2,[r4,#0x2c]         ;1445
                  |L24.146|
000092  f8842024          STRB     r2,[r4,#0x24]         ;1451
000096  f06f0202          MVN      r2,#2                 ;1455
00009a  6002              STR      r2,[r0,#0]            ;1455
00009c  6820              LDR      r0,[r4,#0]            ;1458
00009e  6842              LDR      r2,[r0,#4]            ;1458
0000a0  f0420220          ORR      r2,r2,#0x20           ;1458
0000a4  6042              STR      r2,[r0,#4]            ;1458
0000a6  6820              LDR      r0,[r4,#0]            ;1467
0000a8  6882              LDR      r2,[r0,#8]            ;1467
0000aa  f3c24242          UBFX     r2,r2,#17,#3          ;1467
0000ae  2a07              CMP      r2,#7                 ;1467
0000b0  d105              BNE      |L24.190|
0000b2  42a8              CMP      r0,r5                 ;1468
0000b4  d108              BNE      |L24.200|
0000b6  681a              LDR      r2,[r3,#0]            ;1468
0000b8  f4122f70          TST      r2,#0xf0000           ;1468
0000bc  d004              BEQ      |L24.200|
                  |L24.190|
0000be  6882              LDR      r2,[r0,#8]            ;1476
0000c0  f4421280          ORR      r2,r2,#0x100000       ;1476
0000c4  6082              STR      r2,[r0,#8]            ;1476
0000c6  e7ac              B        |L24.34|
                  |L24.200|
0000c8  6882              LDR      r2,[r0,#8]            ;1471
0000ca  f44202a0          ORR      r2,r2,#0x500000       ;1471
0000ce  6082              STR      r2,[r0,#8]            ;1471
0000d0  e7a7              B        |L24.34|
;;;1488   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L24.212|
                          DCD      0x40012800
                  |L24.216|
                          DCD      0x40012404

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;1148     */
;;;1149   HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1150   {
000002  4604              MOV      r4,r0
;;;1151     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1152     
;;;1153     /* Check the parameters */
;;;1154     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1155        
;;;1156     /* Process locked */
;;;1157     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L25.28|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1158     
;;;1159     /* Stop potential conversion on going, on regular and injected groups */
;;;1160     /* Disable ADC peripheral */
;;;1161     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop_Disable
000018  b110              CBZ      r0,|L25.32|
00001a  e007              B        |L25.44|
                  |L25.28|
00001c  2002              MOVS     r0,#2                 ;1157
;;;1162     
;;;1163     /* Check if ADC is effectively disabled */
;;;1164     if (tmp_hal_status == HAL_OK)
;;;1165     {
;;;1166       /* Set ADC state */
;;;1167       ADC_STATE_CLR_SET(hadc->State,
;;;1168                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1169                         HAL_ADC_STATE_READY);
;;;1170     }
;;;1171     
;;;1172     /* Process unlocked */
;;;1173     __HAL_UNLOCK(hadc);
;;;1174     
;;;1175     /* Return function status */
;;;1176     return tmp_hal_status;
;;;1177   }
00001e  bd10              POP      {r4,pc}
                  |L25.32|
000020  6aa1              LDR      r1,[r4,#0x28]         ;1167
000022  f4215188          BIC      r1,r1,#0x1100         ;1167
000026  f0410101          ORR      r1,r1,#1              ;1167
00002a  62a1              STR      r1,[r4,#0x28]         ;1167
                  |L25.44|
00002c  2100              MOVS     r1,#0                 ;1173
00002e  f8841024          STRB     r1,[r4,#0x24]         ;1173
000032  bd10              POP      {r4,pc}
;;;1178   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;1693     */
;;;1694   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1695   {
000002  4604              MOV      r4,r0
;;;1696     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1697     
;;;1698     /* Check the parameters */
;;;1699     assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
;;;1700        
;;;1701     /* Process locked */
;;;1702     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L26.28|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1703     
;;;1704     /* Stop potential conversion on going, on regular and injected groups */
;;;1705     /* Disable ADC peripheral */
;;;1706     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop_Disable
000018  b110              CBZ      r0,|L26.32|
00001a  e013              B        |L26.68|
                  |L26.28|
00001c  2002              MOVS     r0,#2                 ;1702
;;;1707     
;;;1708     /* Check if ADC is effectively disabled */
;;;1709     if (tmp_hal_status == HAL_OK)
;;;1710     {
;;;1711       /* Disable ADC DMA mode */
;;;1712       CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;1713       
;;;1714       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1715       /* DMA transfer is on going)                                              */
;;;1716       if (hadc->DMA_Handle->State == HAL_DMA_STATE_BUSY)
;;;1717       {
;;;1718         tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1719         
;;;1720         /* Check if DMA channel effectively disabled */
;;;1721         if (tmp_hal_status == HAL_OK)
;;;1722         {
;;;1723           /* Set ADC state */
;;;1724           ADC_STATE_CLR_SET(hadc->State,
;;;1725                             HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1726                             HAL_ADC_STATE_READY);
;;;1727         }
;;;1728         else
;;;1729         {
;;;1730           /* Update ADC state machine to error */
;;;1731           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1732         }
;;;1733       }
;;;1734     }
;;;1735     
;;;1736     /* Process unlocked */
;;;1737     __HAL_UNLOCK(hadc);
;;;1738       
;;;1739     /* Return function status */
;;;1740     return tmp_hal_status;
;;;1741   }
00001e  bd10              POP      {r4,pc}
                  |L26.32|
000020  6821              LDR      r1,[r4,#0]            ;1712
000022  688a              LDR      r2,[r1,#8]            ;1712
000024  f4227280          BIC      r2,r2,#0x100          ;1712
000028  608a              STR      r2,[r1,#8]            ;1712
00002a  6a21              LDR      r1,[r4,#0x20]         ;1716
00002c  f8912021          LDRB     r2,[r1,#0x21]         ;1716
000030  2a02              CMP      r2,#2                 ;1716
000032  d107              BNE      |L26.68|
000034  4608              MOV      r0,r1                 ;1718
000036  f7fffffe          BL       HAL_DMA_Abort
00003a  b138              CBZ      r0,|L26.76|
00003c  6aa1              LDR      r1,[r4,#0x28]         ;1731
00003e  f0410140          ORR      r1,r1,#0x40           ;1731
000042  62a1              STR      r1,[r4,#0x28]         ;1731
                  |L26.68|
000044  2100              MOVS     r1,#0                 ;1737
000046  f8841024          STRB     r1,[r4,#0x24]         ;1737
00004a  bd10              POP      {r4,pc}
                  |L26.76|
00004c  6aa1              LDR      r1,[r4,#0x28]         ;1724
00004e  f4215188          BIC      r1,r1,#0x1100         ;1724
000052  f0410101          ORR      r1,r1,#1              ;1724
000056  62a1              STR      r1,[r4,#0x28]         ;1724
000058  e7f4              B        |L26.68|
;;;1742   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_IT PROC
;;;1495     */
;;;1496   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1497   {
000002  4604              MOV      r4,r0
;;;1498     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;1499     
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1502        
;;;1503     /* Process locked */
;;;1504     __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L27.28|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;1505     
;;;1506     /* Stop potential conversion on going, on regular and injected groups */
;;;1507     /* Disable ADC peripheral */
;;;1508     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ConversionStop_Disable
000018  b110              CBZ      r0,|L27.32|
00001a  e00c              B        |L27.54|
                  |L27.28|
00001c  2002              MOVS     r0,#2                 ;1504
;;;1509     
;;;1510     /* Check if ADC is effectively disabled */
;;;1511     if (tmp_hal_status == HAL_OK)
;;;1512     {
;;;1513       /* Disable ADC end of conversion interrupt for regular group */
;;;1514       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
;;;1515       
;;;1516       /* Set ADC state */
;;;1517       ADC_STATE_CLR_SET(hadc->State,
;;;1518                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1519                         HAL_ADC_STATE_READY);
;;;1520     }
;;;1521     
;;;1522     /* Process unlocked */
;;;1523     __HAL_UNLOCK(hadc);
;;;1524     
;;;1525     /* Return function status */
;;;1526     return tmp_hal_status;
;;;1527   }
00001e  bd10              POP      {r4,pc}
                  |L27.32|
000020  6821              LDR      r1,[r4,#0]            ;1514
000022  684a              LDR      r2,[r1,#4]            ;1514
000024  f0220220          BIC      r2,r2,#0x20           ;1514
000028  604a              STR      r2,[r1,#4]            ;1514
00002a  6aa1              LDR      r1,[r4,#0x28]         ;1517
00002c  f4215188          BIC      r1,r1,#0x1100         ;1517
000030  f0410101          ORR      r1,r1,#1              ;1517
000034  62a1              STR      r1,[r4,#0x28]         ;1517
                  |L27.54|
000036  2100              MOVS     r1,#0                 ;1523
000038  f8841024          STRB     r1,[r4,#0x24]         ;1523
00003c  bd10              POP      {r4,pc}
;;;1528   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____RRX|
#line 665
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
