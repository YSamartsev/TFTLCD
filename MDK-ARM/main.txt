; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\main.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\main.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\main.crf ..\Src\main.c]
                          THUMB

                          AREA ||i.Error_Handler||, CODE, READONLY, ALIGN=1

                  Error_Handler PROC
;;;606    
;;;607    void Error_Handler(void)
000000  f44f747a          MOV      r4,#0x3e8
                  |L1.4|
;;;608    {
;;;609      while (1)
;;;610      {
;;;611        /* Toggle LED2 with a period of one second */
;;;612        //BSP_LED_Toggle(LED2);
;;;613        HAL_Delay(1000);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_Delay
00000a  e7fb              B        |L1.4|
;;;614    		
;;;615      }
;;;616    }
;;;617    
                          ENDP


                          AREA ||i.ITM_SendChar||, CODE, READONLY, ALIGN=2

                  ITM_SendChar PROC
;;;1875    */
;;;1876   __STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
000000  4908              LDR      r1,|L2.36|
;;;1877   {
;;;1878     if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
000002  6809              LDR      r1,[r1,#0]
000004  07c9              LSLS     r1,r1,#31
000006  d00c              BEQ      |L2.34|
;;;1879         ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
000008  4906              LDR      r1,|L2.36|
00000a  3980              SUBS     r1,r1,#0x80
00000c  6809              LDR      r1,[r1,#0]
00000e  07c9              LSLS     r1,r1,#31
000010  d007              BEQ      |L2.34|
;;;1880     {
;;;1881       while (ITM->PORT[0U].u32 == 0UL)
000012  f04f4160          MOV      r1,#0xe0000000
000016  e000              B        |L2.26|
                  |L2.24|
;;;1882       {
;;;1883         __NOP();
000018  bf00              NOP      
                  |L2.26|
00001a  680a              LDR      r2,[r1,#0]            ;1881
00001c  2a00              CMP      r2,#0                 ;1881
00001e  d0fb              BEQ      |L2.24|
;;;1884       }
;;;1885       ITM->PORT[0U].u8 = (uint8_t)ch;
000020  7008              STRB     r0,[r1,#0]
                  |L2.34|
;;;1886     }
;;;1887     return (ch);
;;;1888   }
000022  4770              BX       lr
;;;1889   
                          ENDP

                  |L2.36|
                          DCD      0xe0000e80

                          AREA ||i.LCD_RESET_SET||, CODE, READONLY, ALIGN=2

                  LCD_RESET_SET PROC
;;;426    
;;;427    void LCD_RESET_SET(void)
000000  b570              PUSH     {r4-r6,lr}
;;;428    {
;;;429    		LCD_RST_LOW();  //ST7789_RST_Clr(); //Керується через PB11. В платі не використовується
000002  4d0a              LDR      r5,|L3.44|
000004  f44f6400          MOV      r4,#0x800
000008  2200              MOVS     r2,#0
00000a  4621              MOV      r1,r4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_GPIO_WritePin
;;;430        HAL_Delay(20);
000012  2014              MOVS     r0,#0x14
000014  f7fffffe          BL       HAL_Delay
;;;431       
;;;432    		LCD_RST_HIGH();  //ST7789_RST_Set();
000018  2201              MOVS     r2,#1
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       HAL_GPIO_WritePin
;;;433        HAL_Delay(10);
000022  e8bd4070          POP      {r4-r6,lr}
000026  200a              MOVS     r0,#0xa
000028  f7ffbffe          B.W      HAL_Delay
;;;434    	  //delay_ms(20);
;;;435    }
;;;436    
                          ENDP

                  |L3.44|
                          DCD      0x40010c00

                          AREA ||i.SystemClock_Config||, CODE, READONLY, ALIGN=1

                  SystemClock_Config PROC
;;;338      */
;;;339    void SystemClock_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;340    {
000002  b094              SUB      sp,sp,#0x50
;;;341      RCC_OscInitTypeDef RCC_OscInitStruct = {0};
000004  2128              MOVS     r1,#0x28
000006  a80a              ADD      r0,sp,#0x28
000008  f7fffffe          BL       __aeabi_memclr4
;;;342      RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
00000c  2114              MOVS     r1,#0x14
00000e  a805              ADD      r0,sp,#0x14
000010  f7fffffe          BL       __aeabi_memclr4
;;;343      RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
000014  2400              MOVS     r4,#0
000016  9401              STR      r4,[sp,#4]
000018  9402              STR      r4,[sp,#8]
00001a  9403              STR      r4,[sp,#0xc]
00001c  9404              STR      r4,[sp,#0x10]
;;;344    
;;;345      //==/** Initializes the RCC Oscillators according to the specified parameters
;;;346      //* in the RCC_OscInitTypeDef structure.
;;;347      //
;;;348      RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
00001e  2005              MOVS     r0,#5
000020  900a              STR      r0,[sp,#0x28]
;;;349      RCC_OscInitStruct.HSEState = RCC_HSE_ON;
000022  f44f3080          MOV      r0,#0x10000
000026  900b              STR      r0,[sp,#0x2c]
;;;350      RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
000028  940c              STR      r4,[sp,#0x30]
;;;351      RCC_OscInitStruct.LSEState = RCC_LSE_ON;
00002a  2501              MOVS     r5,#1
00002c  950d              STR      r5,[sp,#0x34]
;;;352      RCC_OscInitStruct.HSIState = RCC_HSI_ON;
00002e  950e              STR      r5,[sp,#0x38]
;;;353      RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
000030  2602              MOVS     r6,#2
000032  9611              STR      r6,[sp,#0x44]
;;;354      RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
000034  9012              STR      r0,[sp,#0x48]
;;;355      RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
000036  f44f10e0          MOV      r0,#0x1c0000
00003a  9013              STR      r0,[sp,#0x4c]
;;;356      if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
00003c  a80a              ADD      r0,sp,#0x28
00003e  f7fffffe          BL       HAL_RCC_OscConfig
000042  b108              CBZ      r0,|L4.72|
;;;357      {
;;;358        Error_Handler();
000044  f7fffffe          BL       Error_Handler
                  |L4.72|
;;;359      }
;;;360      //==/** Initializes the CPU, AHB and APB buses clocks
;;;361      //
;;;362      RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
000048  200f              MOVS     r0,#0xf
00004a  9005              STR      r0,[sp,#0x14]
;;;363                                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
;;;364      RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
00004c  9606              STR      r6,[sp,#0x18]
;;;365      RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
00004e  9407              STR      r4,[sp,#0x1c]
;;;366      RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
000050  f44f6080          MOV      r0,#0x400
000054  9008              STR      r0,[sp,#0x20]
;;;367      RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
000056  9409              STR      r4,[sp,#0x24]
;;;368    
;;;369      if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
000058  2102              MOVS     r1,#2
00005a  a805              ADD      r0,sp,#0x14
00005c  f7fffffe          BL       HAL_RCC_ClockConfig
000060  b108              CBZ      r0,|L4.102|
;;;370      {
;;;371        Error_Handler();
000062  f7fffffe          BL       Error_Handler
                  |L4.102|
;;;372      }
;;;373      PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC;
000066  9501              STR      r5,[sp,#4]
;;;374      PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
000068  f44f7080          MOV      r0,#0x100
00006c  9002              STR      r0,[sp,#8]
;;;375      if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
00006e  a801              ADD      r0,sp,#4
000070  f7fffffe          BL       HAL_RCCEx_PeriphCLKConfig
000074  2800              CMP      r0,#0
000076  d001              BEQ      |L4.124|
;;;376      {
;;;377        Error_Handler();
000078  f7fffffe          BL       Error_Handler
                  |L4.124|
;;;378      }
;;;379    } 
00007c  b014              ADD      sp,sp,#0x50
00007e  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP


                          AREA ||i.__backspace||, CODE, READONLY, ALIGN=2

                  __backspace PROC
;;;188    
;;;189    int __backspace(FILE *f)
000000  4902              LDR      r1,|L5.12|
;;;190    {
;;;191        backspace_called = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;192        return 0;
000006  2000              MOVS     r0,#0
;;;193    }
000008  4770              BX       lr
;;;194    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||area_number.29||

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;159    
;;;160    int fgetc(FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
;;;162        /* if we just backspaced, then return the backspaced character */
;;;163        /* otherwise output the next character in the stream */
;;;164        if (backspace_called == 1)
000002  4c0d              LDR      r4,|L6.56|
000004  7820              LDRB     r0,[r4,#0]  ; backspace_called
000006  2801              CMP      r0,#1
000008  d012              BEQ      |L6.48|
00000a  4a0c              LDR      r2,|L6.60|
00000c  490c              LDR      r1,|L6.64|
00000e  f04f33ff          MOV      r3,#0xffffffff        ;161
                  |L6.18|
000012  4618              MOV      r0,r3                 ;161
000014  6815              LDR      r5,[r2,#0]            ;161  ; ITM_RxBuffer
000016  428d              CMP      r5,r1                 ;161
000018  d001              BEQ      |L6.30|
00001a  6810              LDR      r0,[r2,#0]            ;161  ; ITM_RxBuffer
00001c  6011              STR      r1,[r2,#0]            ;161  ; ITM_RxBuffer
                  |L6.30|
;;;165        {
;;;166          backspace_called = 0;
;;;167        }
;;;168        else {
;;;169            do {
;;;170                r = ITM_ReceiveChar();
00001e  6060              STR      r0,[r4,#4]  ; r
;;;171            } while (r == -1);
000020  1c40              ADDS     r0,r0,#1
000022  d0f6              BEQ      |L6.18|
;;;172            
;;;173            last_char_read = (unsigned char)r;
000024  6860              LDR      r0,[r4,#4]  ; r
000026  7060              STRB     r0,[r4,#1]
;;;174    
;;;175    #ifdef ECHO_FGETC
;;;176            ITM_SendChar(r);
000028  f7fffffe          BL       ITM_SendChar
                  |L6.44|
;;;177    #endif
;;;178        }
;;;179    
;;;180        return last_char_read;
00002c  7860              LDRB     r0,[r4,#1]  ; last_char_read
;;;181    }
00002e  bd70              POP      {r4-r6,pc}
                  |L6.48|
000030  2000              MOVS     r0,#0                 ;166
000032  7020              STRB     r0,[r4,#0]            ;166
000034  e7fa              B        |L6.44|
;;;182    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      ||area_number.29||
                  |L6.60|
                          DCD      ITM_RxBuffer
                  |L6.64|
                          DCD      0x5aa55aa5

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;133    
;;;134    int fputc(int ch, FILE *f) {
000000  f7ffbffe          B.W      ITM_SendChar
;;;135    
;;;136      return (ITM_SendChar((uint32_t)ch)); // Це виводить в Debug printf, с ST Link|V2 працює
;;;137      //ITM_SendChar((uint32_t)ch);
;;;138    	//return ch;
;;;139    	
;;;140    /*	if (DEMCR & TRCENA) {
;;;141        while (ITM_Port32(0) == 0);
;;;142        ITM_Port8(0) = ch;
;;;143      }
;;;144      return(ch); */
;;;145    	
;;;146    	/*	==============Якщо треба вивести в UART Працює =============	
;;;147    	//ITM_SendChar(ch); Якщо розремити, то не працює
;;;148    	HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
;;;149    	return ch;
;;;150    	========================================================= */
;;;151    	
;;;152    	//HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); //Це виводить в UART PA9-Tx, PA10-Rx. Через перехідник UART-USB треба подати на Віртуальний компорт РС.
;;;153    	//return ch;
;;;154    } 
;;;155    
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;204    //		uint8_t in, jn;
;;;205    int main(void)
000000  b086              SUB      sp,sp,#0x18
;;;206                                                                                                                                                                                                                                                                                               {  
;;;207      /* STM32F103xB HAL library initialization:
;;;208           - Configure the Flash prefetch
;;;209           - Systick timer is configured by default as source of time base, but user 
;;;210             can eventually implement his proper time base source (a general purpose 
;;;211             timer for example or other time source), keeping in mind that Time base 
;;;212             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
;;;213             handled in milliseconds basis.
;;;214           - Set NVIC Group Priority to 4
;;;215           - Low Level Initialization
;;;216         */
;;;217      HAL_Init();  
000002  f7fffffe          BL       HAL_Init
;;;218      
;;;219      /* Configure the system clock = 64 MHz */
;;;220      SystemClock_Config();
000006  f7fffffe          BL       SystemClock_Config
;;;221    
;;;222    	/* -------------RTC Start--------------*/
;;;223    /*
;;;224    Для використання переривання RTC_IRQHandler треба в stm32f1xx_hal_msp.c: функції HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc) встановити:
;;;225    	  HAL_NVIC_SetPriority(RTC_IRQn, 0, 0);
;;;226        HAL_NVIC_EnableIRQ(RTC_IRQn); 
;;;227    	Для використання переривання RTC_Alarm_IRQHandler треба в stm32f1xx_hal_msp.c:	
;;;228    		HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0x0F, 0);
;;;229    		HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);	
;;;230    */
;;;231    	
;;;232      /*##-1- Configure the RTC peripheral #######################################*/
;;;233     //==== RtcHandle.Instance = RTC;
;;;234      
;;;235    	  /* Configure RTC prescaler and RTC data registers */
;;;236      /* RTC configured as follows:
;;;237          - Asynch Prediv  = Automatic calculation of prediv for 1 sec timebase
;;;238      */
;;;239      //=====RtcHandle.Init.AsynchPrediv = RTC_AUTO_1_SECOND;
;;;240    
;;;241    /*====	if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
;;;242      {
;;;243        Error_Handler();
;;;244      } */
;;;245    
;;;246      /*##-2- Configure Alarm ####################################################*/
;;;247      /* Configure RTC Alarm */
;;;248      //RTC_AlarmConfig(); //Для перерівання через інтервал часу
;;;249    //=====	RTC_SECConfig(); //Конфігурую для перивання кожну секуду по RTC_IRQHandler
;;;250    
;;;251    
;;;252    /* -------------RTC End--------------*/
;;;253    
;;;254    
;;;255    /* -------------TFT LCD--------------*/	
;;;256      /* Check the availability of adafruit 1.8" TFT shield on top of STM32NUCLEO
;;;257         board. This is done by reading the state of IO PB.00 pin (mapped to JoyStick
;;;258         available on adafruit 1.8" TFT shield). If the state of PB.00 is high then
;;;259         the adafruit 1.8" TFT shield is available. */  
;;;260    //  if(TFT_ShieldDetect() == SHIELD_DETECTED)
;;;261    //  {
;;;262      
;;;263      /* LCD SPI Config */
;;;264      //SPIx_Init();
;;;265    
;;;266    	//MX_SPI_Init(); //Не роблю, це робиться в stm32f1xx_nucleo.c
;;;267    
;;;268    /*in = 0;
;;;269    		jn = 0;
;;;270    		while(in < 100) //ST7789_WIDTH
;;;271    		{		while(jn < 100)  //ST7789_HEIGHT
;;;272    				{
;;;273    					//ST7789_WriteData(data, sizeof(data));
;;;274    					//printf("jn = %04d\n\r", jn);
;;;275    					jn++;
;;;276    				}
;;;277    				//printf("-------------------in = %04d, Last jn = %04d\n\r", in, jn);
;;;278    				jn = 0;
;;;279    				in++;
;;;280    		}
;;;281    		printf("----------------------Last in = %04d, Last jn = %04d\n\r", in, jn);
;;;282    		
;;;283    		*/
;;;284    	/* Initialize ST7735 low level bus layer -----------------------------------*/
;;;285      LCD_IO_Init(); //Визначаються піни для RESET, DC, CS
00000a  f7fffffe          BL       LCD_IO_Init
;;;286      // LCD SPI Config: SCK, SDA 
;;;287     
;;;288     	SPIx_MspInit(); //Конфігурація пінів для MOSI, MOSO, SCK SPIx 
00000e  f7fffffe          BL       SPIx_MspInit
;;;289    	//HAL_SPI_MspInit(&SpiHandle); //Конфігурація пінів для MOSI, MOSO, SCK SPIx
;;;290    		
;;;291    	SPIx_Init(); //Конфігурація параметрів SPI
000012  f7fffffe          BL       SPIx_Init
;;;292    
;;;293    printf("==================Start RTC Watch===================\n\r");
000016  a011              ADR      r0,|L8.92|
000018  f7fffffe          BL       __2printf
;;;294    
;;;295    /* LCD chip select high */
;;;296      //LCD_CS_HIGH(); //Використовую RESET, як CS
;;;297    
;;;298    
;;;299    /* Initialize the LCD */
;;;300    	BSP_LCD_Init(); //Спочатку через PB11 RESET, потім керується через Регістри
00001c  f7fffffe          BL       BSP_LCD_Init
;;;301    
;;;302    
;;;303    	//delay_init(72);	     //ғʱԵʼۯ
;;;304     
;;;305    	
;;;306    	
;;;307    
;;;308    	//==ST7789_WriteString(10, 20, "Real Time", Font_16x26, RED, WHITE);	
;;;309    	//==ST7789_WriteString(10, 50, "Timer", Font_16x26, RED, WHITE);
;;;310      
;;;311        /* Configure SD card */
;;;312        //SDCard_Config(); 
;;;313    	while (1)
;;;314    	{	
;;;315    		printf("===========AAAAAAAAAAAAA==============\n\r");
;;;316      /* Infinite loop */
;;;317    		char *myChar = "!"; 
;;;318    		ST7789_WriteChar(10, 20, *myChar, Font_16x26, WHITE, RED);
000020  4c1c              LDR      r4,|L8.148|
000022  f44f4578          MOV      r5,#0xf800
000026  f64f76ff          MOV      r6,#0xffff
;;;319    		ST7789_Test();
;;;320    		HAL_Delay(1000);
00002a  f44f777a          MOV      r7,#0x3e8
                  |L8.46|
00002e  a01a              ADR      r0,|L8.152|
000030  f7fffffe          BL       __2printf
000034  e9cd6501          STRD     r6,r5,[sp,#4]         ;318
000038  88a1              LDRH     r1,[r4,#4]            ;318  ; Font_16x26
00003a  f8ad1000          STRH     r1,[sp,#0]            ;318
00003e  6823              LDR      r3,[r4,#0]            ;318  ; Font_16x26
000040  f8ad1014          STRH     r1,[sp,#0x14]         ;318
000044  2221              MOVS     r2,#0x21              ;318
000046  9304              STR      r3,[sp,#0x10]         ;318
000048  2114              MOVS     r1,#0x14              ;318
00004a  200a              MOVS     r0,#0xa               ;318
00004c  f7fffffe          BL       ST7789_WriteChar
000050  f7fffffe          BL       ST7789_Test
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       HAL_Delay
00005a  e7e8              B        |L8.46|
;;;321    	//RTC_TimeShow(10, 100, aShowTime);
;;;322    	}
;;;323    }
;;;324    
                          ENDP

                  |L8.92|
00005c  3d3d3d3d          DCB      "==================Start RTC Watch===================\n\r"
000060  3d3d3d3d
000064  3d3d3d3d
000068  3d3d3d3d
00006c  3d3d5374
000070  61727420
000074  52544320
000078  57617463
00007c  683d3d3d
000080  3d3d3d3d
000084  3d3d3d3d
000088  3d3d3d3d
00008c  3d3d3d3d
000090  0a0d    
000092  00                DCB      0
000093  00                DCB      0
                  |L8.148|
                          DCD      Font_16x26
                  |L8.152|
000098  3d3d3d3d          DCB      "===========AAAAAAAAAAAAA==============\n\r",0
00009c  3d3d3d3d
0000a0  3d3d3d41
0000a4  41414141
0000a8  41414141
0000ac  41414141
0000b0  3d3d3d3d
0000b4  3d3d3d3d
0000b8  3d3d3d3d
0000bc  3d3d0a0d
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  aShowTime
                          %        50

                          AREA ||area_number.11||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.bss||
                  RtcHandle
                          %        20

                          AREA ||area_number.12||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.bss||
                  SpiHandle
                          %        88

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.13||, ||.bss||
                  ||str||
                          %        20

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.bss||
                  pDirectoryFiles
                          %        100

                          AREA ||area_number.15||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.bss||
                  SD_FatFs
                          %        560

                          AREA ||area_number.16||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.bss||
                  realdatatime
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  BlinkSpeed
000000  00                DCB      0x00

                          AREA ||area_number.19||, DATA, ALIGN=0

                          EXPORTAS ||area_number.19||, ||.data||
                  JoystickValue
000000  00                DCB      0x00

                          AREA ||area_number.20||, DATA, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.data||
                  SD_Path
                          DCDU     0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.data||
                  realdata
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  realmonth
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.23||, DATA, ALIGN=0

                          EXPORTAS ||area_number.23||, ||.data||
                  realyear
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  realhours
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.25||, DATA, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.data||
                  reatminutes
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  reatseconds
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.27||, DATA, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.data||
                  __stdout
                          DCDU     0x00000000

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  __stdin
                          DCDU     0x00000000

                          AREA ||area_number.29||, DATA, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.data||
                  backspace_called
000000  00                DCB      0x00
                  last_char_read
000001  000000            DCB      0x00,0x00,0x00
                  r
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_92531ed9____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___6_main_c_92531ed9____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_92531ed9____REVSH|
#line 478
|__asm___6_main_c_92531ed9____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_92531ed9____RRX|
#line 665
|__asm___6_main_c_92531ed9____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
