; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_hal_adc_ex.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_hal_adc_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_hal_adc_ex.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc_ex.c]
                          THUMB

                          AREA ||i.HAL_ADCEx_Calibration_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_Calibration_Start PROC
;;;118      */
;;;119    HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;122      uint32_t tickstart;
;;;123      __IO uint32_t wait_loop_index = 0U;
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
;;;124      
;;;125      /* Check the parameters */
;;;126      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;127    
;;;128      /* Process locked */
;;;129      __HAL_LOCK(hadc);
000008  f8940024          LDRB     r0,[r4,#0x24]
00000c  2801              CMP      r0,#1
00000e  d00c              BEQ      |L1.42|
000010  2001              MOVS     r0,#1
000012  f8840024          STRB     r0,[r4,#0x24]
;;;130        
;;;131       /* 1. Disable ADC peripheral                                                 */
;;;132       tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       ADC_ConversionStop_Disable
;;;133      
;;;134       /* 2. Calibration prerequisite delay before starting the calibration.       */
;;;135       /*    - ADC must be enabled for at least two ADC clock cycles               */
;;;136       tmp_hal_status = ADC_Enable(hadc);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       ADC_Enable
000022  4607              MOV      r7,r0
;;;137    
;;;138       /* Check if ADC is effectively enabled */
;;;139       if (tmp_hal_status == HAL_OK)
000024  0038              MOVS     r0,r7
000026  d002              BEQ      |L1.46|
000028  e05d              B        |L1.230|
                  |L1.42|
00002a  2002              MOVS     r0,#2                 ;129
;;;140       {
;;;141         /* Set ADC state */
;;;142         ADC_STATE_CLR_SET(hadc->State,
;;;143                           HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;144                           HAL_ADC_STATE_BUSY_INTERNAL);
;;;145        
;;;146        /* Hardware prerequisite: delay before starting the calibration.          */
;;;147        /*  - Computation of CPU clock cycles corresponding to ADC clock cycles.  */
;;;148        /*  - Wait for the expected ADC clock cycles delay */
;;;149        wait_loop_index = ((SystemCoreClock
;;;150                            / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;151                           * ADC_PRECALIBRATION_DELAY_ADCCLOCKCYCLES        );
;;;152    
;;;153        while(wait_loop_index != 0U)
;;;154        {
;;;155          wait_loop_index--;
;;;156        }
;;;157    
;;;158        /* 3. Resets ADC calibration registers */  
;;;159        SET_BIT(hadc->Instance->CR2, ADC_CR2_RSTCAL);
;;;160        
;;;161        tickstart = HAL_GetTick();  
;;;162    
;;;163        /* Wait for calibration reset completion */
;;;164        while(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_RSTCAL))
;;;165        {
;;;166          if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
;;;167          {
;;;168            /* New check to avoid false timeout detection in case of preemption */
;;;169            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_RSTCAL))
;;;170            {
;;;171              /* Update ADC state machine to error */
;;;172              ADC_STATE_CLR_SET(hadc->State,
;;;173                                HAL_ADC_STATE_BUSY_INTERNAL,
;;;174                                HAL_ADC_STATE_ERROR_INTERNAL);
;;;175    
;;;176              /* Process unlocked */
;;;177              __HAL_UNLOCK(hadc);
;;;178    
;;;179              return HAL_ERROR;
;;;180            }
;;;181          }
;;;182        }
;;;183        
;;;184        /* 4. Start ADC calibration */
;;;185        SET_BIT(hadc->Instance->CR2, ADC_CR2_CAL);
;;;186        
;;;187        tickstart = HAL_GetTick();  
;;;188    
;;;189        /* Wait for calibration completion */
;;;190        while(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_CAL))
;;;191        {
;;;192          if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
;;;193          {
;;;194            /* New check to avoid false timeout detection in case of preemption */
;;;195            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_CAL))
;;;196            {
;;;197              /* Update ADC state machine to error */
;;;198              ADC_STATE_CLR_SET(hadc->State,
;;;199                                HAL_ADC_STATE_BUSY_INTERNAL,
;;;200                                HAL_ADC_STATE_ERROR_INTERNAL);
;;;201    
;;;202              /* Process unlocked */
;;;203              __HAL_UNLOCK(hadc);
;;;204    
;;;205              return HAL_ERROR;
;;;206            }
;;;207          }
;;;208        }
;;;209        
;;;210        /* Set ADC state */
;;;211        ADC_STATE_CLR_SET(hadc->State,
;;;212                          HAL_ADC_STATE_BUSY_INTERNAL,
;;;213                          HAL_ADC_STATE_READY);
;;;214      }
;;;215      
;;;216      /* Process unlocked */
;;;217      __HAL_UNLOCK(hadc);
;;;218      
;;;219      /* Return function status */
;;;220      return tmp_hal_status;
;;;221    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L1.46|
00002e  6aa0              LDR      r0,[r4,#0x28]         ;142
000030  f4205088          BIC      r0,r0,#0x1100         ;142
000034  f0400002          ORR      r0,r0,#2              ;142
000038  62a0              STR      r0,[r4,#0x28]         ;142
00003a  2002              MOVS     r0,#2                 ;149
00003c  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000040  492b              LDR      r1,|L1.240|
000042  6809              LDR      r1,[r1,#0]            ;149  ; SystemCoreClock
000044  fbb1f0f0          UDIV     r0,r1,r0              ;149
000048  0040              LSLS     r0,r0,#1              ;149
00004a  9000              STR      r0,[sp,#0]            ;149
00004c  e002              B        |L1.84|
                  |L1.78|
00004e  9800              LDR      r0,[sp,#0]            ;155
000050  1e40              SUBS     r0,r0,#1              ;155
000052  9000              STR      r0,[sp,#0]            ;155
                  |L1.84|
000054  9800              LDR      r0,[sp,#0]            ;153
000056  2800              CMP      r0,#0                 ;153
000058  d1f9              BNE      |L1.78|
00005a  6820              LDR      r0,[r4,#0]            ;159
00005c  6881              LDR      r1,[r0,#8]            ;159
00005e  f0410108          ORR      r1,r1,#8              ;159
000062  6081              STR      r1,[r0,#8]            ;159
000064  f7fffffe          BL       HAL_GetTick
000068  4605              MOV      r5,r0                 ;161
00006a  e012              B        |L1.146|
                  |L1.108|
00006c  f7fffffe          BL       HAL_GetTick
000070  1b40              SUBS     r0,r0,r5              ;166
000072  280a              CMP      r0,#0xa               ;166
000074  d90d              BLS      |L1.146|
000076  6820              LDR      r0,[r4,#0]            ;169
000078  6880              LDR      r0,[r0,#8]            ;169
00007a  0700              LSLS     r0,r0,#28             ;169
00007c  d509              BPL      |L1.146|
00007e  6aa0              LDR      r0,[r4,#0x28]         ;172
000080  f0200002          BIC      r0,r0,#2              ;172
000084  f0400010          ORR      r0,r0,#0x10           ;172
000088  62a0              STR      r0,[r4,#0x28]         ;172
00008a  f8846024          STRB     r6,[r4,#0x24]         ;177
00008e  2001              MOVS     r0,#1                 ;179
000090  bdf8              POP      {r3-r7,pc}
                  |L1.146|
000092  6820              LDR      r0,[r4,#0]            ;164
000094  6880              LDR      r0,[r0,#8]            ;164
000096  0700              LSLS     r0,r0,#28             ;164
000098  d4e8              BMI      |L1.108|
00009a  6820              LDR      r0,[r4,#0]            ;185
00009c  6881              LDR      r1,[r0,#8]            ;185
00009e  f0410104          ORR      r1,r1,#4              ;185
0000a2  6081              STR      r1,[r0,#8]            ;185
0000a4  f7fffffe          BL       HAL_GetTick
0000a8  4605              MOV      r5,r0                 ;187
0000aa  e012              B        |L1.210|
                  |L1.172|
0000ac  f7fffffe          BL       HAL_GetTick
0000b0  1b40              SUBS     r0,r0,r5              ;192
0000b2  280a              CMP      r0,#0xa               ;192
0000b4  d90d              BLS      |L1.210|
0000b6  6820              LDR      r0,[r4,#0]            ;195
0000b8  6880              LDR      r0,[r0,#8]            ;195
0000ba  0740              LSLS     r0,r0,#29             ;195
0000bc  d509              BPL      |L1.210|
0000be  6aa0              LDR      r0,[r4,#0x28]         ;198
0000c0  f0200002          BIC      r0,r0,#2              ;198
0000c4  f0400010          ORR      r0,r0,#0x10           ;198
0000c8  62a0              STR      r0,[r4,#0x28]         ;198
0000ca  f8846024          STRB     r6,[r4,#0x24]         ;203
0000ce  2001              MOVS     r0,#1                 ;205
0000d0  bdf8              POP      {r3-r7,pc}
                  |L1.210|
0000d2  6820              LDR      r0,[r4,#0]            ;190
0000d4  6880              LDR      r0,[r0,#8]            ;190
0000d6  0740              LSLS     r0,r0,#29             ;190
0000d8  d4e8              BMI      |L1.172|
0000da  6aa0              LDR      r0,[r4,#0x28]         ;211
0000dc  f0200002          BIC      r0,r0,#2              ;211
0000e0  f0400001          ORR      r0,r0,#1              ;211
0000e4  62a0              STR      r0,[r4,#0x28]         ;211
                  |L1.230|
0000e6  f8846024          STRB     r6,[r4,#0x24]         ;217
0000ea  4638              MOV      r0,r7                 ;220
0000ec  bdf8              POP      {r3-r7,pc}
;;;222    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L1.240|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_ADCEx_InjectedConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedConfigChannel PROC
;;;999      */
;;;1000   HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1001   {
;;;1002     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000002  2200              MOVS     r2,#0
;;;1003     __IO uint32_t wait_loop_index = 0U;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;1004     
;;;1005     /* Check the parameters */
;;;1006     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1007     assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
;;;1008     assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
;;;1009     assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
;;;1010     assert_param(IS_ADC_EXTTRIGINJEC(sConfigInjected->ExternalTrigInjecConv));
;;;1011     assert_param(IS_ADC_RANGE(sConfigInjected->InjectedOffset));
;;;1012     
;;;1013     if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
000008  6883              LDR      r3,[r0,#8]
;;;1014     {
;;;1015       assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
;;;1016       assert_param(IS_ADC_INJECTED_NB_CONV(sConfigInjected->InjectedNbrOfConversion));
;;;1017       assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
;;;1018     }
;;;1019     
;;;1020     /* Process locked */
;;;1021     __HAL_LOCK(hadc);
00000a  f8904024          LDRB     r4,[r0,#0x24]
00000e  2c01              CMP      r4,#1
000010  d01e              BEQ      |L2.80|
000012  2401              MOVS     r4,#1
000014  f8804024          STRB     r4,[r0,#0x24]
000018  b1e3              CBZ      r3,|L2.84|
;;;1022     
;;;1023     /* Configuration of injected group sequencer:                               */
;;;1024     /* - if scan mode is disabled, injected channels sequence length is set to  */
;;;1025     /*   0x00: 1 channel converted (channel on regular rank 1)                  */
;;;1026     /*   Parameter "InjectedNbrOfConversion" is discarded.                      */
;;;1027     /*   Note: Scan mode is present by hardware on this device and, if          */
;;;1028     /*   disabled, discards automatically nb of conversions. Anyway, nb of      */
;;;1029     /*   conversions is forced to 0x00 for alignment over all STM32 devices.    */
;;;1030     /* - if scan mode is enabled, injected channels sequence length is set to   */
;;;1031     /*   parameter "InjectedNbrOfConversion".                                   */
;;;1032     if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
;;;1033     {
;;;1034       if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
;;;1035       {
;;;1036         /* Clear the old SQx bits for all injected ranks */
;;;1037         MODIFY_REG(hadc->Instance->JSQR                             ,
;;;1038                    ADC_JSQR_JL   |
;;;1039                    ADC_JSQR_JSQ4 |
;;;1040                    ADC_JSQR_JSQ3 |
;;;1041                    ADC_JSQR_JSQ2 |
;;;1042                    ADC_JSQR_JSQ1                                    ,
;;;1043                    ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,
;;;1044                                     ADC_INJECTED_RANK_1,
;;;1045                                     0x01U));
;;;1046       }
;;;1047       /* If another injected rank than rank1 was intended to be set, and could  */
;;;1048       /* not due to ScanConvMode disabled, error is reported.                   */
;;;1049       else
;;;1050       {
;;;1051         /* Update ADC state machine to error */
;;;1052         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1053         
;;;1054         tmp_hal_status = HAL_ERROR;
;;;1055       }
;;;1056     }
;;;1057     else
;;;1058     {
;;;1059       /* Since injected channels rank conv. order depends on total number of   */
;;;1060       /* injected conversions, selected rank must be below or equal to total   */
;;;1061       /* number of injected conversions to be updated.                         */
;;;1062       if (sConfigInjected->InjectedRank <= sConfigInjected->InjectedNbrOfConversion)
00001a  684c              LDR      r4,[r1,#4]
00001c  690b              LDR      r3,[r1,#0x10]
;;;1063       {
;;;1064         /* Clear the old SQx bits for the selected rank */
;;;1065         /* Set the SQx bits for the selected rank */
;;;1066         MODIFY_REG(hadc->Instance->JSQR                                         ,
00001e  261f              MOVS     r6,#0x1f
000020  429c              CMP      r4,r3                 ;1062
000022  d829              BHI      |L2.120|
000024  1b1c              SUBS     r4,r3,r4
000026  f1c40403          RSB      r4,r4,#3
00002a  eb040484          ADD      r4,r4,r4,LSL #2
00002e  40a6              LSLS     r6,r6,r4
000030  f4461c40          ORR      r12,r6,#0x300000
000034  6806              LDR      r6,[r0,#0]
000036  6bb7              LDR      r7,[r6,#0x38]
000038  ea27070c          BIC      r7,r7,r12
00003c  f8d1c000          LDR      r12,[r1,#0]
000040  fa0cfc04          LSL      r12,r12,r4
000044  1e5b              SUBS     r3,r3,#1
000046  ea4c5303          ORR      r3,r12,r3,LSL #20
00004a  431f              ORRS     r7,r7,r3
00004c  63b7              STR      r7,[r6,#0x38]
00004e  e01f              B        |L2.144|
                  |L2.80|
000050  2002              MOVS     r0,#2                 ;1021
;;;1067                    
;;;1068                    ADC_JSQR_JL                                               |
;;;1069                    ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
;;;1070                                     sConfigInjected->InjectedRank,         
;;;1071                                     sConfigInjected->InjectedNbrOfConversion)   ,
;;;1072                    
;;;1073                    ADC_JSQR_JL_SHIFT(sConfigInjected->InjectedNbrOfConversion) |
;;;1074                    ADC_JSQR_RK_JL(sConfigInjected->InjectedChannel,      
;;;1075                                     sConfigInjected->InjectedRank,         
;;;1076                                     sConfigInjected->InjectedNbrOfConversion)    );
;;;1077       }
;;;1078       else
;;;1079       {
;;;1080         /* Clear the old SQx bits for the selected rank */
;;;1081         MODIFY_REG(hadc->Instance->JSQR                                       ,
;;;1082                    
;;;1083                    ADC_JSQR_JL                                               |
;;;1084                    ADC_JSQR_RK_JL(ADC_JSQR_JSQ1,                         
;;;1085                                     sConfigInjected->InjectedRank,         
;;;1086                                     sConfigInjected->InjectedNbrOfConversion) ,
;;;1087                    
;;;1088                    0x00000000U);
;;;1089       }
;;;1090     } 
;;;1091       
;;;1092     /* Configuration of injected group                                          */
;;;1093     /* Parameters update conditioned to ADC state:                              */
;;;1094     /* Parameters that can be updated only when ADC is disabled:                */
;;;1095     /*  - external trigger to start conversion                                  */
;;;1096     /* Parameters update not conditioned to ADC state:                          */
;;;1097     /*  - Automatic injected conversion                                         */
;;;1098     /*  - Injected discontinuous mode                                           */
;;;1099     /* Note: In case of ADC already enabled, caution to not launch an unwanted  */
;;;1100     /*       conversion while modifying register CR2 by writing 1 to bit ADON.  */
;;;1101     if (ADC_IS_ENABLE(hadc) == RESET)
;;;1102     {    
;;;1103       MODIFY_REG(hadc->Instance->CR2                                           ,
;;;1104                  ADC_CR2_JEXTSEL |
;;;1105                  ADC_CR2_ADON                                                  ,
;;;1106                  ADC_CFGR_JEXTSEL(hadc, sConfigInjected->ExternalTrigInjecConv) );
;;;1107     }
;;;1108     
;;;1109     
;;;1110     /* Configuration of injected group                                          */
;;;1111     /*  - Automatic injected conversion                                         */
;;;1112     /*  - Injected discontinuous mode                                           */
;;;1113     
;;;1114       /* Automatic injected conversion can be enabled if injected group         */
;;;1115       /* external triggers are disabled.                                        */
;;;1116       if (sConfigInjected->AutoInjectedConv == ENABLE)
;;;1117       {
;;;1118         if (sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
;;;1119         {
;;;1120           SET_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO);
;;;1121         }
;;;1122         else
;;;1123         {
;;;1124           /* Update ADC state machine to error */
;;;1125           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1126           
;;;1127           tmp_hal_status = HAL_ERROR;
;;;1128         }
;;;1129       }
;;;1130       
;;;1131       /* Injected discontinuous can be enabled only if auto-injected mode is    */
;;;1132       /* disabled.                                                              */  
;;;1133       if (sConfigInjected->InjectedDiscontinuousConvMode == ENABLE)
;;;1134       {
;;;1135         if (sConfigInjected->AutoInjectedConv == DISABLE)
;;;1136         {
;;;1137           SET_BIT(hadc->Instance->CR1, ADC_CR1_JDISCEN);
;;;1138         } 
;;;1139         else
;;;1140         {
;;;1141           /* Update ADC state machine to error */
;;;1142           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1143           
;;;1144           tmp_hal_status = HAL_ERROR;
;;;1145         }
;;;1146       }
;;;1147   
;;;1148   
;;;1149     /* InjectedChannel sampling time configuration */
;;;1150     /* For channels 10 to 17 */
;;;1151     if (sConfigInjected->InjectedChannel >= ADC_CHANNEL_10)
;;;1152     {
;;;1153       MODIFY_REG(hadc->Instance->SMPR1                                                             ,
;;;1154                  ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel)                      ,
;;;1155                  ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
;;;1156     }
;;;1157     else /* For channels 0 to 9 */
;;;1158     {
;;;1159       MODIFY_REG(hadc->Instance->SMPR2                                                             ,
;;;1160                  ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel)                       ,
;;;1161                  ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel) );
;;;1162     }
;;;1163     
;;;1164     /* If ADC1 InjectedChannel_16 or InjectedChannel_17 is selected, enable Temperature sensor  */
;;;1165     /* and VREFINT measurement path.                                            */
;;;1166     if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
;;;1167         (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)      )
;;;1168     {
;;;1169       SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;1170     }
;;;1171     
;;;1172     
;;;1173     /* Configure the offset: offset enable/disable, InjectedChannel, offset value */
;;;1174     switch(sConfigInjected->InjectedRank)
;;;1175     {
;;;1176       case 1:
;;;1177         /* Set injected channel 1 offset */
;;;1178         MODIFY_REG(hadc->Instance->JOFR1,
;;;1179                    ADC_JOFR1_JOFFSET1,
;;;1180                    sConfigInjected->InjectedOffset);
;;;1181         break;
;;;1182       case 2:
;;;1183         /* Set injected channel 2 offset */
;;;1184         MODIFY_REG(hadc->Instance->JOFR2,
;;;1185                    ADC_JOFR2_JOFFSET2,
;;;1186                    sConfigInjected->InjectedOffset);
;;;1187         break;
;;;1188       case 3:
;;;1189         /* Set injected channel 3 offset */
;;;1190         MODIFY_REG(hadc->Instance->JOFR3,
;;;1191                    ADC_JOFR3_JOFFSET3,
;;;1192                    sConfigInjected->InjectedOffset);
;;;1193         break;
;;;1194       case 4:
;;;1195       default:
;;;1196         MODIFY_REG(hadc->Instance->JOFR4,
;;;1197                    ADC_JOFR4_JOFFSET4,
;;;1198                    sConfigInjected->InjectedOffset);
;;;1199         break;
;;;1200     }
;;;1201     
;;;1202     /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
;;;1203     /* and VREFINT measurement path.                                            */
;;;1204     if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) ||
;;;1205         (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)      )
;;;1206     {
;;;1207       /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
;;;1208       /* measurement channels (VrefInt/TempSensor). If these channels are       */
;;;1209       /* intended to be set on other ADC instances, an error is reported.       */
;;;1210       if (hadc->Instance == ADC1)
;;;1211       {
;;;1212         if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
;;;1213         {
;;;1214           SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;1215           
;;;1216           if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR))
;;;1217           {
;;;1218             /* Delay for temperature sensor stabilization time */
;;;1219             /* Compute number of CPU cycles to wait for */
;;;1220             wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;1221             while(wait_loop_index != 0U)
;;;1222             {
;;;1223               wait_loop_index--;
;;;1224             }
;;;1225           }
;;;1226         }
;;;1227       }
;;;1228       else
;;;1229       {
;;;1230         /* Update ADC state machine to error */
;;;1231         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1232         
;;;1233         tmp_hal_status = HAL_ERROR;
;;;1234       }
;;;1235     }
;;;1236     
;;;1237     /* Process unlocked */
;;;1238     __HAL_UNLOCK(hadc);
;;;1239     
;;;1240     /* Return function status */
;;;1241     return tmp_hal_status;
;;;1242   }
000052  bdf8              POP      {r3-r7,pc}
                  |L2.84|
000054  684b              LDR      r3,[r1,#4]            ;1034
000056  2b01              CMP      r3,#1                 ;1034
000058  d005              BEQ      |L2.102|
00005a  6a82              LDR      r2,[r0,#0x28]         ;1052
00005c  f0420220          ORR      r2,r2,#0x20           ;1052
000060  6282              STR      r2,[r0,#0x28]         ;1052
000062  2201              MOVS     r2,#1                 ;1054
000064  e014              B        |L2.144|
                  |L2.102|
000066  6803              LDR      r3,[r0,#0]            ;1037
000068  6b9c              LDR      r4,[r3,#0x38]         ;1037
00006a  680e              LDR      r6,[r1,#0]            ;1037
00006c  f36f0415          BFC      r4,#0,#22             ;1037
000070  ea4434c6          ORR      r4,r4,r6,LSL #15      ;1037
000074  639c              STR      r4,[r3,#0x38]         ;1037
000076  e00b              B        |L2.144|
                  |L2.120|
000078  1b1b              SUBS     r3,r3,r4              ;1081
00007a  f1c30303          RSB      r3,r3,#3              ;1081
00007e  eb030383          ADD      r3,r3,r3,LSL #2       ;1081
000082  409e              LSLS     r6,r6,r3              ;1081
000084  6803              LDR      r3,[r0,#0]            ;1081
000086  f4461640          ORR      r6,r6,#0x300000       ;1081
00008a  6b9c              LDR      r4,[r3,#0x38]         ;1081
00008c  43b4              BICS     r4,r4,r6              ;1081
00008e  639c              STR      r4,[r3,#0x38]         ;1081
                  |L2.144|
000090  6803              LDR      r3,[r0,#0]            ;1101
000092  689c              LDR      r4,[r3,#8]            ;1101
000094  43e4              MVNS     r4,r4                 ;1101
000096  07e4              LSLS     r4,r4,#31             ;1101
000098  d006              BEQ      |L2.168|
00009a  689c              LDR      r4,[r3,#8]            ;1103
00009c  f2470601          MOV      r6,#0x7001            ;1103
0000a0  43b4              BICS     r4,r4,r6              ;1103
0000a2  698e              LDR      r6,[r1,#0x18]         ;1103
0000a4  4334              ORRS     r4,r4,r6              ;1103
0000a6  609c              STR      r4,[r3,#8]            ;1103
                  |L2.168|
0000a8  7d4b              LDRB     r3,[r1,#0x15]         ;1116
0000aa  2b01              CMP      r3,#1                 ;1116
0000ac  d108              BNE      |L2.192|
0000ae  698b              LDR      r3,[r1,#0x18]         ;1118
0000b0  f5b34fe0          CMP      r3,#0x7000            ;1118
0000b4  d008              BEQ      |L2.200|
0000b6  6a82              LDR      r2,[r0,#0x28]         ;1125
0000b8  f0420220          ORR      r2,r2,#0x20           ;1125
0000bc  6282              STR      r2,[r0,#0x28]         ;1125
0000be  2201              MOVS     r2,#1                 ;1127
                  |L2.192|
0000c0  7d0b              LDRB     r3,[r1,#0x14]         ;1133
0000c2  2b01              CMP      r3,#1                 ;1133
0000c4  d006              BEQ      |L2.212|
0000c6  e00c              B        |L2.226|
                  |L2.200|
0000c8  6803              LDR      r3,[r0,#0]            ;1120
0000ca  685c              LDR      r4,[r3,#4]            ;1120
0000cc  f4446480          ORR      r4,r4,#0x400          ;1120
0000d0  605c              STR      r4,[r3,#4]            ;1120
0000d2  e7f5              B        |L2.192|
                  |L2.212|
0000d4  7d4b              LDRB     r3,[r1,#0x15]         ;1135
0000d6  b1a3              CBZ      r3,|L2.258|
0000d8  6a82              LDR      r2,[r0,#0x28]         ;1142
0000da  f0420220          ORR      r2,r2,#0x20           ;1142
0000de  6282              STR      r2,[r0,#0x28]         ;1142
0000e0  2201              MOVS     r2,#1                 ;1144
                  |L2.226|
0000e2  680b              LDR      r3,[r1,#0]            ;1151
0000e4  2607              MOVS     r6,#7                 ;1153
0000e6  2b0a              CMP      r3,#0xa               ;1151
0000e8  d311              BCC      |L2.270|
0000ea  6804              LDR      r4,[r0,#0]            ;1153
0000ec  68e7              LDR      r7,[r4,#0xc]          ;1153
0000ee  3b0a              SUBS     r3,r3,#0xa            ;1153
0000f0  eb030343          ADD      r3,r3,r3,LSL #1       ;1153
0000f4  409e              LSLS     r6,r6,r3              ;1153
0000f6  43b7              BICS     r7,r7,r6              ;1153
0000f8  688e              LDR      r6,[r1,#8]            ;1153
0000fa  409e              LSLS     r6,r6,r3              ;1153
0000fc  4337              ORRS     r7,r7,r6              ;1153
0000fe  60e7              STR      r7,[r4,#0xc]          ;1153
000100  e00f              B        |L2.290|
                  |L2.258|
000102  6803              LDR      r3,[r0,#0]            ;1137
000104  685c              LDR      r4,[r3,#4]            ;1137
000106  f4445480          ORR      r4,r4,#0x1000         ;1137
00010a  605c              STR      r4,[r3,#4]            ;1137
00010c  e7e9              B        |L2.226|
                  |L2.270|
00010e  6804              LDR      r4,[r0,#0]            ;1159
000110  6927              LDR      r7,[r4,#0x10]         ;1159
000112  eb030343          ADD      r3,r3,r3,LSL #1       ;1159
000116  409e              LSLS     r6,r6,r3              ;1159
000118  43b7              BICS     r7,r7,r6              ;1159
00011a  688e              LDR      r6,[r1,#8]            ;1159
00011c  409e              LSLS     r6,r6,r3              ;1159
00011e  4337              ORRS     r7,r7,r6              ;1159
000120  6127              STR      r7,[r4,#0x10]         ;1159
                  |L2.290|
000122  680b              LDR      r3,[r1,#0]            ;1166
000124  2b10              CMP      r3,#0x10              ;1166
000126  d001              BEQ      |L2.300|
000128  2b11              CMP      r3,#0x11              ;1167
00012a  d104              BNE      |L2.310|
                  |L2.300|
00012c  6803              LDR      r3,[r0,#0]            ;1169
00012e  689c              LDR      r4,[r3,#8]            ;1169
000130  f4440400          ORR      r4,r4,#0x800000       ;1169
000134  609c              STR      r4,[r3,#8]            ;1169
                  |L2.310|
000136  684b              LDR      r3,[r1,#4]            ;1174
000138  2b01              CMP      r3,#1                 ;1174
00013a  d010              BEQ      |L2.350|
00013c  2b02              CMP      r3,#2                 ;1174
00013e  d016              BEQ      |L2.366|
000140  2b03              CMP      r3,#3                 ;1174
000142  d01c              BEQ      |L2.382|
000144  6803              LDR      r3,[r0,#0]            ;1196
000146  6a1c              LDR      r4,[r3,#0x20]         ;1196
000148  68ce              LDR      r6,[r1,#0xc]          ;1196
00014a  f36f040b          BFC      r4,#0,#12             ;1196
00014e  4334              ORRS     r4,r4,r6              ;1196
000150  621c              STR      r4,[r3,#0x20]         ;1196
                  |L2.338|
000152  680b              LDR      r3,[r1,#0]            ;1204
000154  2b10              CMP      r3,#0x10              ;1204
000156  d01a              BEQ      |L2.398|
000158  2b11              CMP      r3,#0x11              ;1205
00015a  d018              BEQ      |L2.398|
00015c  e03b              B        |L2.470|
                  |L2.350|
00015e  6803              LDR      r3,[r0,#0]            ;1178
000160  695c              LDR      r4,[r3,#0x14]         ;1178
000162  68ce              LDR      r6,[r1,#0xc]          ;1178
000164  f36f040b          BFC      r4,#0,#12             ;1178
000168  4334              ORRS     r4,r4,r6              ;1178
00016a  615c              STR      r4,[r3,#0x14]         ;1178
00016c  e7f1              B        |L2.338|
                  |L2.366|
00016e  6803              LDR      r3,[r0,#0]            ;1184
000170  699c              LDR      r4,[r3,#0x18]         ;1184
000172  68ce              LDR      r6,[r1,#0xc]          ;1184
000174  f36f040b          BFC      r4,#0,#12             ;1184
000178  4334              ORRS     r4,r4,r6              ;1184
00017a  619c              STR      r4,[r3,#0x18]         ;1184
00017c  e7e9              B        |L2.338|
                  |L2.382|
00017e  6803              LDR      r3,[r0,#0]            ;1190
000180  69dc              LDR      r4,[r3,#0x1c]         ;1190
000182  68ce              LDR      r6,[r1,#0xc]          ;1190
000184  f36f040b          BFC      r4,#0,#12             ;1190
000188  4334              ORRS     r4,r4,r6              ;1190
00018a  61dc              STR      r4,[r3,#0x1c]         ;1190
00018c  e7e1              B        |L2.338|
                  |L2.398|
00018e  4c14              LDR      r4,|L2.480|
000190  6803              LDR      r3,[r0,#0]            ;1210
000192  42a3              CMP      r3,r4                 ;1210
000194  d11a              BNE      |L2.460|
000196  689c              LDR      r4,[r3,#8]            ;1212
000198  0224              LSLS     r4,r4,#8              ;1212
00019a  d41c              BMI      |L2.470|
00019c  689c              LDR      r4,[r3,#8]            ;1214
00019e  f4440400          ORR      r4,r4,#0x800000       ;1214
0001a2  609c              STR      r4,[r3,#8]            ;1214
0001a4  6809              LDR      r1,[r1,#0]            ;1216
0001a6  2910              CMP      r1,#0x10              ;1216
0001a8  d115              BNE      |L2.470|
0001aa  490e              LDR      r1,|L2.484|
0001ac  4b0e              LDR      r3,|L2.488|
0001ae  6809              LDR      r1,[r1,#0]            ;1220  ; SystemCoreClock
0001b0  fbb1f1f3          UDIV     r1,r1,r3              ;1220
0001b4  eb010181          ADD      r1,r1,r1,LSL #2       ;1220
0001b8  0049              LSLS     r1,r1,#1              ;1220
0001ba  9100              STR      r1,[sp,#0]            ;1220
0001bc  e002              B        |L2.452|
                  |L2.446|
0001be  9900              LDR      r1,[sp,#0]            ;1223
0001c0  1e49              SUBS     r1,r1,#1              ;1223
0001c2  9100              STR      r1,[sp,#0]            ;1223
                  |L2.452|
0001c4  9900              LDR      r1,[sp,#0]            ;1221
0001c6  2900              CMP      r1,#0                 ;1221
0001c8  d1f9              BNE      |L2.446|
0001ca  e004              B        |L2.470|
                  |L2.460|
0001cc  6a81              LDR      r1,[r0,#0x28]         ;1231
0001ce  f0410120          ORR      r1,r1,#0x20           ;1231
0001d2  6281              STR      r1,[r0,#0x28]         ;1231
0001d4  2201              MOVS     r2,#1                 ;1233
                  |L2.470|
0001d6  f8805024          STRB     r5,[r0,#0x24]         ;1238
0001da  4610              MOV      r0,r2                 ;1241
0001dc  bdf8              POP      {r3-r7,pc}
;;;1243   
                          ENDP

0001de  0000              DCW      0x0000
                  |L2.480|
                          DCD      0x40012400
                  |L2.484|
                          DCD      SystemCoreClock
                  |L2.488|
                          DCD      0x000f4240

                          AREA ||i.HAL_ADCEx_InjectedConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedConvCpltCallback PROC
;;;957      */
;;;958    __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;959    {
;;;960      /* Prevent unused argument(s) compilation warning */
;;;961      UNUSED(hadc);
;;;962      /* NOTE : This function Should not be modified, when the callback is needed,
;;;963                the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
;;;964      */
;;;965    }
;;;966    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedGetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedGetValue PROC
;;;888      */
;;;889    uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
000000  6800              LDR      r0,[r0,#0]
;;;890    {
;;;891      uint32_t tmp_jdr = 0U;
;;;892      
;;;893      /* Check the parameters */
;;;894      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;895      assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
;;;896      
;;;897      /* Get ADC converted value */ 
;;;898      switch(InjectedRank)
000002  2902              CMP      r1,#2
000004  d009              BEQ      |L4.26|
000006  2903              CMP      r1,#3
000008  d005              BEQ      |L4.22|
00000a  2904              CMP      r1,#4
00000c  d001              BEQ      |L4.18|
;;;899      {  
;;;900        case ADC_INJECTED_RANK_4: 
;;;901          tmp_jdr = hadc->Instance->JDR4;
;;;902          break;
;;;903        case ADC_INJECTED_RANK_3: 
;;;904          tmp_jdr = hadc->Instance->JDR3;
;;;905          break;
;;;906        case ADC_INJECTED_RANK_2: 
;;;907          tmp_jdr = hadc->Instance->JDR2;
;;;908          break;
;;;909        case ADC_INJECTED_RANK_1:
;;;910        default:
;;;911          tmp_jdr = hadc->Instance->JDR1;
00000e  6bc0              LDR      r0,[r0,#0x3c]
;;;912          break;
;;;913      }
;;;914      
;;;915      /* Return ADC converted value */ 
;;;916      return tmp_jdr;
;;;917    }
000010  4770              BX       lr
                  |L4.18|
000012  6c80              LDR      r0,[r0,#0x48]         ;901
000014  4770              BX       lr
                  |L4.22|
000016  6c40              LDR      r0,[r0,#0x44]         ;904
000018  4770              BX       lr
                  |L4.26|
00001a  6c00              LDR      r0,[r0,#0x40]         ;907
00001c  4770              BX       lr
;;;918    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedPollForConversion||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedPollForConversion PROC
;;;380      */
;;;381    HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;382    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;383      uint32_t tickstart;
;;;384    
;;;385      /* Variables for polling in case of scan mode enabled and polling for each  */
;;;386      /* conversion.                                                              */
;;;387      __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
000008  f04f0800          MOV      r8,#0
00000c  f8cd8000          STR      r8,[sp,#0]
;;;388      uint32_t Conversion_Timeout_CPU_cycles_max = 0U;
;;;389      
;;;390      /* Check the parameters */
;;;391      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;392    
;;;393      /* Get timeout */
;;;394      tickstart = HAL_GetTick();  
000010  f7fffffe          BL       HAL_GetTick
000014  4606              MOV      r6,r0
;;;395         
;;;396      /* Polling for end of conversion: differentiation if single/sequence        */
;;;397      /* conversion.                                                              */
;;;398      /* For injected group, flag JEOC is set only at the end of the sequence,    */
;;;399      /* not for each conversion within the sequence.                             */
;;;400      /*  - If single conversion for injected group (scan mode disabled or        */
;;;401      /*    InjectedNbrOfConversion ==1), flag JEOC is used to determine the      */
;;;402      /*    conversion completion.                                                */
;;;403      /*  - If sequence conversion for injected group (scan mode enabled and      */
;;;404      /*    InjectedNbrOfConversion >=2), flag JEOC is set only at the end of the */
;;;405      /*    sequence.                                                             */
;;;406      /*    To poll for each conversion, the maximum conversion time is computed  */
;;;407      /*    from ADC conversion time (selected sampling time + conversion time of */
;;;408      /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
;;;409      /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
;;;410      /*    As flag JEOC is not set after each conversion, no timeout status can  */
;;;411      /*    be set.                                                               */
;;;412      if ((hadc->Instance->JSQR & ADC_JSQR_JL) == RESET)
000016  6820              LDR      r0,[r4,#0]
000018  6b80              LDR      r0,[r0,#0x38]
00001a  f4101f40          TST      r0,#0x300000
00001e  d032              BEQ      |L5.134|
;;;413      {
;;;414        /* Wait until End of Conversion flag is raised */
;;;415        while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
;;;416        {
;;;417          /* Check if timeout is disabled (set to infinite wait) */
;;;418          if(Timeout != HAL_MAX_DELAY)
;;;419          {
;;;420            if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;421            {
;;;422              /* New check to avoid false timeout detection in case of preemption */
;;;423              if(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_JEOC))
;;;424              {
;;;425                /* Update ADC state machine to timeout */
;;;426                SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;427    
;;;428                /* Process unlocked */
;;;429                __HAL_UNLOCK(hadc);
;;;430    
;;;431                return HAL_TIMEOUT;
;;;432              }
;;;433            }
;;;434          }
;;;435        }
;;;436      }
;;;437      else
;;;438      {
;;;439        /* Replace polling by wait for maximum conversion time */
;;;440        /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
;;;441        /*    and ADC maximum conversion cycles on all channels.                  */
;;;442        /*  - Wait for the expected ADC clock cycles delay                        */
;;;443        Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000026  4943              LDR      r1,|L5.308|
000028  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00002a  fbb1f7f0          UDIV     r7,r1,r0
00002e  6820              LDR      r0,[r4,#0]
000030  6902              LDR      r2,[r0,#0x10]
000032  4941              LDR      r1,|L5.312|
000034  420a              TST      r2,r1
;;;444                                              / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;445                                             * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
000036  ea4f0161          ASR      r1,r1,#1
00003a  ea4f13a1          ASR      r3,r1,#6
00003e  d127              BNE      |L5.144|
000040  68c2              LDR      r2,[r0,#0xc]
000042  ea4f1c61          ASR      r12,r1,#5
000046  ea120f0c          TST      r2,r12
00004a  d121              BNE      |L5.144|
00004c  6902              LDR      r2,[r0,#0x10]
00004e  420a              TST      r2,r1
000050  d12d              BNE      |L5.174|
000052  68c0              LDR      r0,[r0,#0xc]
000054  4218              TST      r0,r3
000056  d12a              BNE      |L5.174|
000058  2014              MOVS     r0,#0x14
00005a  e02b              B        |L5.180|
                  |L5.92|
00005c  1c68              ADDS     r0,r5,#1              ;418
00005e  d012              BEQ      |L5.134|
000060  b125              CBZ      r5,|L5.108|
000062  f7fffffe          BL       HAL_GetTick
000066  1b80              SUBS     r0,r0,r6              ;420
000068  42a8              CMP      r0,r5                 ;420
00006a  d90c              BLS      |L5.134|
                  |L5.108|
00006c  6820              LDR      r0,[r4,#0]            ;423
00006e  6800              LDR      r0,[r0,#0]            ;423
000070  0740              LSLS     r0,r0,#29             ;423
000072  d408              BMI      |L5.134|
000074  6aa0              LDR      r0,[r4,#0x28]         ;426
000076  f0400004          ORR      r0,r0,#4              ;426
00007a  62a0              STR      r0,[r4,#0x28]         ;426
00007c  f8848024          STRB     r8,[r4,#0x24]         ;429
000080  2003              MOVS     r0,#3                 ;431
                  |L5.130|
;;;446        
;;;447        while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;448        {
;;;449          /* Check if timeout is disabled (set to infinite wait) */
;;;450          if(Timeout != HAL_MAX_DELAY)
;;;451          {
;;;452            if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;453            {
;;;454              /* New check to avoid false timeout detection in case of preemption */
;;;455              if(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;456              {
;;;457                /* Update ADC state machine to timeout */
;;;458                SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;459    
;;;460                /* Process unlocked */
;;;461                __HAL_UNLOCK(hadc);
;;;462    
;;;463                return HAL_TIMEOUT;
;;;464              }
;;;465            }
;;;466          }
;;;467          Conversion_Timeout_CPU_cycles ++;
;;;468        }
;;;469      }
;;;470    
;;;471      /* Clear injected group conversion flag */
;;;472      /* Note: On STM32F1 ADC, clear regular conversion flag raised               */
;;;473      /* simultaneously.                                                          */
;;;474      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC | ADC_FLAG_EOC);
;;;475      
;;;476      /* Update ADC state machine */
;;;477      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
;;;478      
;;;479      /* Determine whether any further conversion upcoming on group injected      */
;;;480      /* by external trigger or by automatic injected conversion                  */
;;;481      /* from group regular.                                                      */
;;;482      if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
;;;483         (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
;;;484         (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
;;;485          (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
;;;486      {
;;;487        /* Set ADC state */
;;;488        CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
;;;489        
;;;490        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
;;;491        {
;;;492          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;493        }
;;;494      }
;;;495      
;;;496      /* Return ADC state */
;;;497      return HAL_OK;
;;;498    }
000082  e8bd83f8          POP      {r3-r9,pc}
                  |L5.134|
000086  6820              LDR      r0,[r4,#0]            ;415
000088  6800              LDR      r0,[r0,#0]            ;415
00008a  0740              LSLS     r0,r0,#29             ;415
00008c  d5e6              BPL      |L5.92|
00008e  e02c              B        |L5.234|
                  |L5.144|
000090  6902              LDR      r2,[r0,#0x10]         ;445
000092  420a              TST      r2,r1                 ;445
000094  d102              BNE      |L5.156|
000096  68c1              LDR      r1,[r0,#0xc]          ;445
000098  4219              TST      r1,r3                 ;445
00009a  d006              BEQ      |L5.170|
                  |L5.156|
00009c  6902              LDR      r2,[r0,#0x10]         ;445
00009e  4927              LDR      r1,|L5.316|
0000a0  420a              TST      r2,r1                 ;445
0000a2  d106              BNE      |L5.178|
0000a4  68c0              LDR      r0,[r0,#0xc]          ;445
0000a6  4208              TST      r0,r1                 ;445
0000a8  d103              BNE      |L5.178|
                  |L5.170|
0000aa  2054              MOVS     r0,#0x54              ;445
0000ac  e002              B        |L5.180|
                  |L5.174|
0000ae  2029              MOVS     r0,#0x29              ;445
0000b0  e000              B        |L5.180|
                  |L5.178|
0000b2  20fc              MOVS     r0,#0xfc              ;445
                  |L5.180|
0000b4  4347              MULS     r7,r0,r7              ;445
0000b6  e015              B        |L5.228|
                  |L5.184|
0000b8  1c68              ADDS     r0,r5,#1              ;450
0000ba  d010              BEQ      |L5.222|
0000bc  b125              CBZ      r5,|L5.200|
0000be  f7fffffe          BL       HAL_GetTick
0000c2  1b80              SUBS     r0,r0,r6              ;452
0000c4  42a8              CMP      r0,r5                 ;452
0000c6  d90a              BLS      |L5.222|
                  |L5.200|
0000c8  9800              LDR      r0,[sp,#0]            ;455
0000ca  42b8              CMP      r0,r7                 ;455
0000cc  d207              BCS      |L5.222|
0000ce  6aa0              LDR      r0,[r4,#0x28]         ;458
0000d0  f0400004          ORR      r0,r0,#4              ;458
0000d4  62a0              STR      r0,[r4,#0x28]         ;458
0000d6  f8848024          STRB     r8,[r4,#0x24]         ;461
0000da  2003              MOVS     r0,#3                 ;463
0000dc  e7d1              B        |L5.130|
                  |L5.222|
0000de  9800              LDR      r0,[sp,#0]            ;467
0000e0  1c40              ADDS     r0,r0,#1              ;467
0000e2  9000              STR      r0,[sp,#0]            ;467
                  |L5.228|
0000e4  9800              LDR      r0,[sp,#0]            ;447
0000e6  42b8              CMP      r0,r7                 ;447
0000e8  d3e6              BCC      |L5.184|
                  |L5.234|
0000ea  6821              LDR      r1,[r4,#0]            ;474
0000ec  f06f000e          MVN      r0,#0xe               ;474
0000f0  6008              STR      r0,[r1,#0]            ;474
0000f2  6aa0              LDR      r0,[r4,#0x28]         ;477
0000f4  f4405000          ORR      r0,r0,#0x2000         ;477
0000f8  62a0              STR      r0,[r4,#0x28]         ;477
0000fa  6820              LDR      r0,[r4,#0]            ;482
0000fc  6881              LDR      r1,[r0,#8]            ;482
0000fe  f3c13102          UBFX     r1,r1,#12,#3          ;482
000102  2907              CMP      r1,#7                 ;482
000104  d009              BEQ      |L5.282|
000106  6841              LDR      r1,[r0,#4]            ;483
000108  0549              LSLS     r1,r1,#21             ;483
00010a  d411              BMI      |L5.304|
00010c  6880              LDR      r0,[r0,#8]            ;484
00010e  f3c04042          UBFX     r0,r0,#17,#3          ;484
000112  2807              CMP      r0,#7                 ;484
000114  d10c              BNE      |L5.304|
000116  7b20              LDRB     r0,[r4,#0xc]          ;485
000118  b950              CBNZ     r0,|L5.304|
                  |L5.282|
00011a  6aa0              LDR      r0,[r4,#0x28]         ;488
00011c  f4205080          BIC      r0,r0,#0x1000         ;488
000120  62a0              STR      r0,[r4,#0x28]         ;488
000122  6aa0              LDR      r0,[r4,#0x28]         ;490
000124  05c0              LSLS     r0,r0,#23             ;490
000126  d403              BMI      |L5.304|
000128  6aa0              LDR      r0,[r4,#0x28]         ;492
00012a  f0400001          ORR      r0,r0,#1              ;492
00012e  62a0              STR      r0,[r4,#0x28]         ;492
                  |L5.304|
000130  2000              MOVS     r0,#0                 ;497
000132  e7a6              B        |L5.130|
;;;499    
                          ENDP

                  |L5.308|
                          DCD      SystemCoreClock
                  |L5.312|
                          DCD      0x24924924
                  |L5.316|
                          DCD      0x00249249

                          AREA ||i.HAL_ADCEx_InjectedStart||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart PROC
;;;228      */
;;;229    HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;232      
;;;233      /* Check the parameters */
;;;234      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;235      
;;;236      /* Process locked */
;;;237      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L6.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;238        
;;;239      /* Enable the ADC peripheral */
;;;240      tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;241      
;;;242      /* Start conversion if ADC is effectively enabled */
;;;243      if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L6.42|
;;;244      {
;;;245        /* Set ADC state                                                          */
;;;246        /* - Clear state bitfield related to injected group conversion results    */
;;;247        /* - Set state bitfield related to injected operation                     */
;;;248        ADC_STATE_CLR_SET(hadc->State,
;;;249                          HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
;;;250                          HAL_ADC_STATE_INJ_BUSY);
;;;251        
;;;252        /* Case of independent mode or multimode (for devices with several ADCs): */
;;;253        /* Set multimode state.                                                   */
;;;254        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;255        {
;;;256          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;257        }
;;;258        else
;;;259        {
;;;260          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;261        }
;;;262        
;;;263        /* Check if a regular conversion is ongoing */
;;;264        /* Note: On this device, there is no ADC error code fields related to     */
;;;265        /*       conversions on group injected only. In case of conversion on     */
;;;266        /*       going on group regular, no error code is reset.                  */
;;;267        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
;;;268        {
;;;269          /* Reset ADC all error code fields */
;;;270          ADC_CLEAR_ERRORCODE(hadc);
;;;271        }
;;;272        
;;;273        /* Process unlocked */
;;;274        /* Unlock before starting ADC conversions: in case of potential           */
;;;275        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;276        __HAL_UNLOCK(hadc);
;;;277        
;;;278        /* Clear injected group conversion flag */
;;;279        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;280        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
;;;281            
;;;282        /* Enable conversion of injected group.                                   */
;;;283        /* If software start has been selected, conversion starts immediately.    */
;;;284        /* If external trigger has been selected, conversion will start at next   */
;;;285        /* trigger event.                                                         */
;;;286        /* If automatic injected conversion is enabled, conversion will start     */
;;;287        /* after next regular group conversion.                                   */
;;;288        /* Case of multimode enabled (for devices with several ADCs): if ADC is   */
;;;289        /* slave, ADC is enabled only (conversion is not started). If ADC is      */
;;;290        /* master, ADC is enabled and conversion is started.                      */
;;;291        if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO))
;;;292        {
;;;293          if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
;;;294              ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;295          {
;;;296            /* Start ADC conversion on injected group with SW start */
;;;297            SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
;;;298          }
;;;299          else
;;;300          {
;;;301            /* Start ADC conversion on injected group with external trigger */
;;;302            SET_BIT(hadc->Instance->CR2, ADC_CR2_JEXTTRIG);
;;;303          }
;;;304        }
;;;305      }
;;;306      else
;;;307      {
;;;308        /* Process unlocked */
;;;309        __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L6.34|
;;;310      }
;;;311      
;;;312      /* Return function status */
;;;313      return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;314    }
000024  bd70              POP      {r4-r6,pc}
                  |L6.38|
000026  2002              MOVS     r0,#2                 ;237
000028  bd70              POP      {r4-r6,pc}
                  |L6.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;248
00002c  f2420301          MOV      r3,#0x2001            ;248
000030  4398              BICS     r0,r0,r3              ;248
000032  f4405080          ORR      r0,r0,#0x1000         ;248
000036  62a0              STR      r0,[r4,#0x28]         ;248
000038  4b1a              LDR      r3,|L6.164|
00003a  6820              LDR      r0,[r4,#0]            ;254
00003c  4d1a              LDR      r5,|L6.168|
00003e  4298              CMP      r0,r3                 ;254
000040  d11a              BNE      |L6.120|
000042  682e              LDR      r6,[r5,#0]            ;254
000044  f4162f70          TST      r6,#0xf0000           ;254
000048  d016              BEQ      |L6.120|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;260
00004c  f4461680          ORR      r6,r6,#0x100000       ;260
000050  62a6              STR      r6,[r4,#0x28]         ;260
                  |L6.82|
000052  6aa6              LDR      r6,[r4,#0x28]         ;267
000054  05f6              LSLS     r6,r6,#23             ;267
000056  d400              BMI      |L6.90|
000058  62e2              STR      r2,[r4,#0x2c]         ;270
                  |L6.90|
00005a  f8842024          STRB     r2,[r4,#0x24]         ;276
00005e  f06f0204          MVN      r2,#4                 ;280
000062  6002              STR      r2,[r0,#0]            ;280
000064  6820              LDR      r0,[r4,#0]            ;291
000066  6842              LDR      r2,[r0,#4]            ;291
000068  0552              LSLS     r2,r2,#21             ;291
00006a  d4da              BMI      |L6.34|
00006c  6882              LDR      r2,[r0,#8]            ;293
00006e  f3c23202          UBFX     r2,r2,#12,#3          ;293
000072  2a07              CMP      r2,#7                 ;293
000074  d005              BEQ      |L6.130|
000076  e00a              B        |L6.142|
                  |L6.120|
000078  6aa6              LDR      r6,[r4,#0x28]         ;256
00007a  f4261680          BIC      r6,r6,#0x100000       ;256
00007e  62a6              STR      r6,[r4,#0x28]         ;256
000080  e7e7              B        |L6.82|
                  |L6.130|
000082  4298              CMP      r0,r3                 ;294
000084  d108              BNE      |L6.152|
000086  682a              LDR      r2,[r5,#0]            ;294
000088  f4122f70          TST      r2,#0xf0000           ;294
00008c  d004              BEQ      |L6.152|
                  |L6.142|
00008e  6882              LDR      r2,[r0,#8]            ;302
000090  f4424200          ORR      r2,r2,#0x8000         ;302
000094  6082              STR      r2,[r0,#8]            ;302
000096  e7c4              B        |L6.34|
                  |L6.152|
000098  6882              LDR      r2,[r0,#8]            ;297
00009a  f4421202          ORR      r2,r2,#0x208000       ;297
00009e  6082              STR      r2,[r0,#8]            ;297
0000a0  e7bf              B        |L6.34|
;;;315    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L6.164|
                          DCD      0x40012800
                  |L6.168|
                          DCD      0x40012404

                          AREA ||i.HAL_ADCEx_InjectedStart_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart_IT PROC
;;;506      */
;;;507    HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;508    {
000002  4604              MOV      r4,r0
;;;509      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;510      
;;;511      /* Check the parameters */
;;;512      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;513      
;;;514      /* Process locked */
;;;515      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L7.38|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;516        
;;;517      /* Enable the ADC peripheral */
;;;518      tmp_hal_status = ADC_Enable(hadc);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_Enable
000018  4601              MOV      r1,r0
;;;519      
;;;520      /* Start conversion if ADC is effectively enabled */
;;;521      if (tmp_hal_status == HAL_OK)
00001a  2200              MOVS     r2,#0
00001c  b129              CBZ      r1,|L7.42|
;;;522      {
;;;523        /* Set ADC state                                                          */
;;;524        /* - Clear state bitfield related to injected group conversion results    */
;;;525        /* - Set state bitfield related to injected operation                     */
;;;526        ADC_STATE_CLR_SET(hadc->State,
;;;527                          HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
;;;528                          HAL_ADC_STATE_INJ_BUSY);
;;;529        
;;;530        /* Case of independent mode or multimode (for devices with several ADCs): */
;;;531        /* Set multimode state.                                                   */
;;;532        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;533        {
;;;534          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;535        }
;;;536        else
;;;537        {
;;;538          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;539        }
;;;540        
;;;541        /* Check if a regular conversion is ongoing */
;;;542        /* Note: On this device, there is no ADC error code fields related to     */
;;;543        /*       conversions on group injected only. In case of conversion on     */
;;;544        /*       going on group regular, no error code is reset.                  */
;;;545        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
;;;546        {
;;;547          /* Reset ADC all error code fields */
;;;548          ADC_CLEAR_ERRORCODE(hadc);
;;;549        }
;;;550        
;;;551        /* Process unlocked */
;;;552        /* Unlock before starting ADC conversions: in case of potential           */
;;;553        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;554        __HAL_UNLOCK(hadc);
;;;555        
;;;556        /* Clear injected group conversion flag */
;;;557        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;558        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
;;;559        
;;;560        /* Enable end of conversion interrupt for injected channels */
;;;561        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;562        
;;;563        /* Start conversion of injected group if software start has been selected */
;;;564        /* and if automatic injected conversion is disabled.                      */
;;;565        /* If external trigger has been selected, conversion will start at next   */
;;;566        /* trigger event.                                                         */
;;;567        /* If automatic injected conversion is enabled, conversion will start     */
;;;568        /* after next regular group conversion.                                   */
;;;569        if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO))
;;;570        {
;;;571          if (ADC_IS_SOFTWARE_START_INJECTED(hadc)     &&
;;;572              ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;573          {
;;;574            /* Start ADC conversion on injected group with SW start */
;;;575            SET_BIT(hadc->Instance->CR2, (ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG));
;;;576          }
;;;577          else
;;;578          {
;;;579            /* Start ADC conversion on injected group with external trigger */
;;;580            SET_BIT(hadc->Instance->CR2, ADC_CR2_JEXTTRIG);
;;;581          }
;;;582        }
;;;583      }
;;;584      else
;;;585      {
;;;586        /* Process unlocked */
;;;587        __HAL_UNLOCK(hadc);
00001e  f8842024          STRB     r2,[r4,#0x24]
                  |L7.34|
;;;588      }
;;;589      
;;;590      /* Return function status */
;;;591      return tmp_hal_status;
000022  4608              MOV      r0,r1
;;;592    }
000024  bd70              POP      {r4-r6,pc}
                  |L7.38|
000026  2002              MOVS     r0,#2                 ;515
000028  bd70              POP      {r4-r6,pc}
                  |L7.42|
00002a  6aa0              LDR      r0,[r4,#0x28]         ;526
00002c  f2420301          MOV      r3,#0x2001            ;526
000030  4398              BICS     r0,r0,r3              ;526
000032  f4405080          ORR      r0,r0,#0x1000         ;526
000036  62a0              STR      r0,[r4,#0x28]         ;526
000038  4b1c              LDR      r3,|L7.172|
00003a  6820              LDR      r0,[r4,#0]            ;532
00003c  4d1c              LDR      r5,|L7.176|
00003e  4298              CMP      r0,r3                 ;532
000040  d11f              BNE      |L7.130|
000042  682e              LDR      r6,[r5,#0]            ;532
000044  f4162f70          TST      r6,#0xf0000           ;532
000048  d01b              BEQ      |L7.130|
00004a  6aa6              LDR      r6,[r4,#0x28]         ;538
00004c  f4461680          ORR      r6,r6,#0x100000       ;538
000050  62a6              STR      r6,[r4,#0x28]         ;538
                  |L7.82|
000052  6aa6              LDR      r6,[r4,#0x28]         ;545
000054  05f6              LSLS     r6,r6,#23             ;545
000056  d400              BMI      |L7.90|
000058  62e2              STR      r2,[r4,#0x2c]         ;548
                  |L7.90|
00005a  f8842024          STRB     r2,[r4,#0x24]         ;554
00005e  f06f0204          MVN      r2,#4                 ;558
000062  6002              STR      r2,[r0,#0]            ;558
000064  6820              LDR      r0,[r4,#0]            ;561
000066  6842              LDR      r2,[r0,#4]            ;561
000068  f0420280          ORR      r2,r2,#0x80           ;561
00006c  6042              STR      r2,[r0,#4]            ;561
00006e  6820              LDR      r0,[r4,#0]            ;569
000070  6842              LDR      r2,[r0,#4]            ;569
000072  0552              LSLS     r2,r2,#21             ;569
000074  d4d5              BMI      |L7.34|
000076  6882              LDR      r2,[r0,#8]            ;571
000078  f3c23202          UBFX     r2,r2,#12,#3          ;571
00007c  2a07              CMP      r2,#7                 ;571
00007e  d005              BEQ      |L7.140|
000080  e00a              B        |L7.152|
                  |L7.130|
000082  6aa6              LDR      r6,[r4,#0x28]         ;534
000084  f4261680          BIC      r6,r6,#0x100000       ;534
000088  62a6              STR      r6,[r4,#0x28]         ;534
00008a  e7e2              B        |L7.82|
                  |L7.140|
00008c  4298              CMP      r0,r3                 ;572
00008e  d108              BNE      |L7.162|
000090  682a              LDR      r2,[r5,#0]            ;572
000092  f4122f70          TST      r2,#0xf0000           ;572
000096  d004              BEQ      |L7.162|
                  |L7.152|
000098  6882              LDR      r2,[r0,#8]            ;580
00009a  f4424200          ORR      r2,r2,#0x8000         ;580
00009e  6082              STR      r2,[r0,#8]            ;580
0000a0  e7bf              B        |L7.34|
                  |L7.162|
0000a2  6882              LDR      r2,[r0,#8]            ;575
0000a4  f4421202          ORR      r2,r2,#0x208000       ;575
0000a8  6082              STR      r2,[r0,#8]            ;575
0000aa  e7ba              B        |L7.34|
;;;593    
                          ENDP

                  |L7.172|
                          DCD      0x40012800
                  |L7.176|
                          DCD      0x40012404

                          AREA ||i.HAL_ADCEx_InjectedStop||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop PROC
;;;327      */
;;;328    HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;329    {
000002  4604              MOV      r4,r0
;;;330      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;331      
;;;332      /* Check the parameters */
;;;333      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;334    
;;;335      /* Process locked */
;;;336      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00e              BEQ      |L8.42|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;337        
;;;338      /* Stop potential conversion and disable ADC peripheral                     */
;;;339      /* Conditioned to:                                                          */
;;;340      /* - No conversion on the other group (regular group) is intended to        */
;;;341      /*   continue (injected and regular groups stop conversion and ADC disable  */
;;;342      /*   are common)                                                            */
;;;343      /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
;;;344      if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
000012  6aa0              LDR      r0,[r4,#0x28]
000014  05c0              LSLS     r0,r0,#23
000016  d411              BMI      |L8.60|
;;;345         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  0540              LSLS     r0,r0,#21
00001e  d40d              BMI      |L8.60|
;;;346      {
;;;347        /* Stop potential conversion on going, on regular and injected groups */
;;;348        /* Disable ADC peripheral */
;;;349        tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       ADC_ConversionStop_Disable
;;;350        
;;;351        /* Check if ADC is effectively disabled */
;;;352        if (tmp_hal_status == HAL_OK)
000026  b110              CBZ      r0,|L8.46|
000028  e00d              B        |L8.70|
                  |L8.42|
00002a  2002              MOVS     r0,#2                 ;336
;;;353        {
;;;354          /* Set ADC state */
;;;355          ADC_STATE_CLR_SET(hadc->State,
;;;356                            HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;357                            HAL_ADC_STATE_READY);
;;;358        }
;;;359      }
;;;360      else
;;;361      {
;;;362        /* Update ADC state machine to error */
;;;363        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;364          
;;;365        tmp_hal_status = HAL_ERROR;
;;;366      }
;;;367      
;;;368      /* Process unlocked */
;;;369      __HAL_UNLOCK(hadc);
;;;370      
;;;371      /* Return function status */
;;;372      return tmp_hal_status;
;;;373    }
00002c  bd10              POP      {r4,pc}
                  |L8.46|
00002e  6aa1              LDR      r1,[r4,#0x28]         ;355
000030  f4215188          BIC      r1,r1,#0x1100         ;355
000034  f0410101          ORR      r1,r1,#1              ;355
000038  62a1              STR      r1,[r4,#0x28]         ;355
00003a  e004              B        |L8.70|
                  |L8.60|
00003c  6aa0              LDR      r0,[r4,#0x28]         ;363
00003e  f0400020          ORR      r0,r0,#0x20           ;363
000042  62a0              STR      r0,[r4,#0x28]         ;363
000044  2001              MOVS     r0,#1                 ;365
                  |L8.70|
000046  2100              MOVS     r1,#0                 ;369
000048  f8841024          STRB     r1,[r4,#0x24]         ;369
00004c  bd10              POP      {r4,pc}
;;;374    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedStop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop_IT PROC
;;;605      */
;;;606    HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;607    {
000002  4604              MOV      r4,r0
;;;608      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;609      
;;;610      /* Check the parameters */
;;;611      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;612    
;;;613      /* Process locked */
;;;614      __HAL_LOCK(hadc);
000004  f8940024          LDRB     r0,[r4,#0x24]
000008  2801              CMP      r0,#1
00000a  d00e              BEQ      |L9.42|
00000c  2001              MOVS     r0,#1
00000e  f8840024          STRB     r0,[r4,#0x24]
;;;615        
;;;616      /* Stop potential conversion and disable ADC peripheral                     */
;;;617      /* Conditioned to:                                                          */
;;;618      /* - No conversion on the other group (regular group) is intended to        */
;;;619      /*   continue (injected and regular groups stop conversion and ADC disable  */
;;;620      /*   are common)                                                            */
;;;621      /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
;;;622      if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
000012  6aa0              LDR      r0,[r4,#0x28]
000014  05c0              LSLS     r0,r0,#23
000016  d416              BMI      |L9.70|
;;;623         HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  0540              LSLS     r0,r0,#21
00001e  d412              BMI      |L9.70|
;;;624      {
;;;625        /* Stop potential conversion on going, on regular and injected groups */
;;;626        /* Disable ADC peripheral */
;;;627        tmp_hal_status = ADC_ConversionStop_Disable(hadc);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       ADC_ConversionStop_Disable
;;;628        
;;;629        /* Check if ADC is effectively disabled */
;;;630        if (tmp_hal_status == HAL_OK)
000026  b110              CBZ      r0,|L9.46|
000028  e012              B        |L9.80|
                  |L9.42|
00002a  2002              MOVS     r0,#2                 ;614
;;;631        {
;;;632          /* Disable ADC end of conversion interrupt for injected channels */
;;;633          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
;;;634          
;;;635          /* Set ADC state */
;;;636          ADC_STATE_CLR_SET(hadc->State,
;;;637                            HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;638                            HAL_ADC_STATE_READY);
;;;639        }
;;;640      }
;;;641      else
;;;642      {
;;;643        /* Update ADC state machine to error */
;;;644        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;645          
;;;646        tmp_hal_status = HAL_ERROR;
;;;647      }
;;;648      
;;;649      /* Process unlocked */
;;;650      __HAL_UNLOCK(hadc);
;;;651      
;;;652      /* Return function status */
;;;653      return tmp_hal_status;
;;;654    }
00002c  bd10              POP      {r4,pc}
                  |L9.46|
00002e  6821              LDR      r1,[r4,#0]            ;633
000030  684a              LDR      r2,[r1,#4]            ;633
000032  f0220280          BIC      r2,r2,#0x80           ;633
000036  604a              STR      r2,[r1,#4]            ;633
000038  6aa1              LDR      r1,[r4,#0x28]         ;636
00003a  f4215188          BIC      r1,r1,#0x1100         ;636
00003e  f0410101          ORR      r1,r1,#1              ;636
000042  62a1              STR      r1,[r4,#0x28]         ;636
000044  e004              B        |L9.80|
                  |L9.70|
000046  6aa0              LDR      r0,[r4,#0x28]         ;644
000048  f0400020          ORR      r0,r0,#0x20           ;644
00004c  62a0              STR      r0,[r4,#0x28]         ;644
00004e  2001              MOVS     r0,#1                 ;646
                  |L9.80|
000050  2100              MOVS     r1,#0                 ;650
000052  f8841024          STRB     r1,[r4,#0x24]         ;650
000056  bd10              POP      {r4,pc}
;;;655    
                          ENDP


                          AREA ||i.HAL_ADCEx_MultiModeConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeConfigChannel PROC
;;;1260     */
;;;1261   HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
000000  b570              PUSH     {r4-r6,lr}
;;;1262   {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1263     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000008  2500              MOVS     r5,#0
;;;1264     ADC_HandleTypeDef tmphadcSlave={0};
00000a  2130              MOVS     r1,#0x30
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;1265     
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;1268     assert_param(IS_ADC_MODE(multimode->Mode));
;;;1269     
;;;1270     /* Process locked */
;;;1271     __HAL_LOCK(hadc);
000012  f8940024          LDRB     r0,[r4,#0x24]
000016  2801              CMP      r0,#1
000018  d018              BEQ      |L10.76|
00001a  2001              MOVS     r0,#1
00001c  f8840024          STRB     r0,[r4,#0x24]
;;;1272     
;;;1273     /* Set a temporary handle of the ADC slave associated to the ADC master     */
;;;1274     ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
000020  4811              LDR      r0,|L10.104|
000022  9000              STR      r0,[sp,#0]
;;;1275     
;;;1276     /* Parameters update conditioned to ADC state:                              */
;;;1277     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1278     /* conversion on going on regular group:                                    */
;;;1279     /*  - ADC master and ADC slave DMA configuration                            */
;;;1280     /* Parameters that can be updated only when ADC is disabled:                */
;;;1281     /*  - Multimode mode selection                                              */
;;;1282     /* To optimize code, all multimode settings can be set when both ADCs of    */
;;;1283     /* the common group are in state: disabled.                                 */
;;;1284     if ((ADC_IS_ENABLE(hadc) == RESET)                     &&
000024  6820              LDR      r0,[r4,#0]
000026  6881              LDR      r1,[r0,#8]
000028  43c9              MVNS     r1,r1
00002a  07c9              LSLS     r1,r1,#31
00002c  d011              BEQ      |L10.82|
;;;1285         (ADC_IS_ENABLE(&tmphadcSlave) == RESET)            &&
00002e  9900              LDR      r1,[sp,#0]
000030  6889              LDR      r1,[r1,#8]
000032  43c9              MVNS     r1,r1
000034  07c9              LSLS     r1,r1,#31
000036  d00c              BEQ      |L10.82|
;;;1286         (IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance))   )
000038  490c              LDR      r1,|L10.108|
00003a  4288              CMP      r0,r1
00003c  d109              BNE      |L10.82|
;;;1287     {
;;;1288       MODIFY_REG(hadc->Instance->CR1,
00003e  6841              LDR      r1,[r0,#4]
000040  f4212270          BIC      r2,r1,#0xf0000
000044  6831              LDR      r1,[r6,#0]
000046  430a              ORRS     r2,r2,r1
000048  6042              STR      r2,[r0,#4]
00004a  e007              B        |L10.92|
                  |L10.76|
00004c  2002              MOVS     r0,#2                 ;1271
                  |L10.78|
;;;1289                  ADC_CR1_DUALMOD    ,
;;;1290                  multimode->Mode     );
;;;1291     }
;;;1292     /* If one of the ADC sharing the same common group is enabled, no update    */
;;;1293     /* could be done on neither of the multimode structure parameters.          */
;;;1294     else
;;;1295     {
;;;1296       /* Update ADC state machine to error */
;;;1297       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1298       
;;;1299       tmp_hal_status = HAL_ERROR;
;;;1300     }
;;;1301       
;;;1302       
;;;1303     /* Process unlocked */
;;;1304     __HAL_UNLOCK(hadc);
;;;1305     
;;;1306     /* Return function status */
;;;1307     return tmp_hal_status;
;;;1308   } 
00004e  b00c              ADD      sp,sp,#0x30
000050  bd70              POP      {r4-r6,pc}
                  |L10.82|
000052  6aa0              LDR      r0,[r4,#0x28]         ;1297
000054  f0400020          ORR      r0,r0,#0x20           ;1297
000058  62a0              STR      r0,[r4,#0x28]         ;1297
00005a  2501              MOVS     r5,#1                 ;1299
                  |L10.92|
00005c  2000              MOVS     r0,#0                 ;1304
00005e  f8840024          STRB     r0,[r4,#0x24]         ;1304
000062  4628              MOV      r0,r5                 ;1307
000064  e7f3              B        |L10.78|
;;;1309   #endif /* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */
                          ENDP

000066  0000              DCW      0x0000
                  |L10.104|
                          DCD      0x40012800
                  |L10.108|
                          DCD      0x40012400

                          AREA ||i.HAL_ADCEx_MultiModeGetValue||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeGetValue PROC
;;;925      */
;;;926    uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc)
000000  6800              LDR      r0,[r0,#0]
;;;927    {
;;;928      uint32_t tmpDR = 0U;
;;;929      
;;;930      /* Check the parameters */
;;;931      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;932      
;;;933      /* Check the parameters */
;;;934      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;935    
;;;936      /* Note: EOC flag is not cleared here by software because automatically     */
;;;937      /*       cleared by hardware when reading register DR.                      */
;;;938      
;;;939      /* On STM32F1 devices, ADC1 data register DR contains ADC2 conversions      */
;;;940      /* only if ADC1 DMA mode is enabled.                                        */
;;;941      tmpDR = hadc->Instance->DR;
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;942    
;;;943      if (HAL_IS_BIT_CLR(ADC1->CR2, ADC_CR2_DMA))
000004  4904              LDR      r1,|L11.24|
000006  6809              LDR      r1,[r1,#0]
000008  05c9              LSLS     r1,r1,#23
00000a  d403              BMI      |L11.20|
;;;944      {
;;;945        tmpDR |= (ADC2->DR << 16U);
00000c  4903              LDR      r1,|L11.28|
00000e  6809              LDR      r1,[r1,#0]
000010  ea404001          ORR      r0,r0,r1,LSL #16
                  |L11.20|
;;;946      }
;;;947        
;;;948      /* Return ADC converted value */ 
;;;949      return tmpDR;
;;;950    }
000014  4770              BX       lr
;;;951    #endif /* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40012408
                  |L11.28|
                          DCD      0x4001284c

                          AREA ||i.HAL_ADCEx_MultiModeStart_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStart_DMA PROC
;;;674      */
;;;675    HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;676    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
;;;677      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;678      ADC_HandleTypeDef tmphadcSlave={0};
00000c  2130              MOVS     r1,#0x30
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;679    
;;;680      /* Check the parameters */
;;;681      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;682      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;683      
;;;684      /* Process locked */
;;;685      __HAL_LOCK(hadc);
000014  f8940024          LDRB     r0,[r4,#0x24]
000018  2801              CMP      r0,#1
00001a  d014              BEQ      |L12.70|
00001c  2001              MOVS     r0,#1
00001e  f8840024          STRB     r0,[r4,#0x24]
;;;686    
;;;687      /* Set a temporary handle of the ADC slave associated to the ADC master     */
;;;688      ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
000022  482f              LDR      r0,|L12.224|
000024  9000              STR      r0,[sp,#0]
;;;689      
;;;690      /* On STM32F1 devices, ADC slave regular group must be configured with      */
;;;691      /* conversion trigger ADC_SOFTWARE_START.                                   */
;;;692      /* Note: External trigger of ADC slave must be enabled, it is already done  */
;;;693      /*       into function "HAL_ADC_Init()".                                    */
;;;694      if(!ADC_IS_SOFTWARE_START_REGULAR(&tmphadcSlave))  
000026  6880              LDR      r0,[r0,#8]
000028  2600              MOVS     r6,#0
00002a  f3c04042          UBFX     r0,r0,#17,#3
00002e  2807              CMP      r0,#7
000030  d00b              BEQ      |L12.74|
;;;695      {
;;;696        /* Update ADC state machine to error */
;;;697        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
000032  6aa0              LDR      r0,[r4,#0x28]
000034  f0400020          ORR      r0,r0,#0x20
000038  62a0              STR      r0,[r4,#0x28]
;;;698        
;;;699        /* Process unlocked */
;;;700        __HAL_UNLOCK(hadc);
00003a  f8846024          STRB     r6,[r4,#0x24]
;;;701        
;;;702        return HAL_ERROR;
00003e  2001              MOVS     r0,#1
                  |L12.64|
;;;703      }
;;;704      
;;;705      /* Enable the ADC peripherals: master and slave (in case if not already     */
;;;706      /* enabled previously)                                                      */
;;;707      tmp_hal_status = ADC_Enable(hadc);
;;;708      if (tmp_hal_status == HAL_OK)
;;;709      {
;;;710        tmp_hal_status = ADC_Enable(&tmphadcSlave);
;;;711      }
;;;712      
;;;713      /* Start conversion if all ADCs of multimode are effectively enabled */
;;;714      if (tmp_hal_status == HAL_OK)
;;;715      {
;;;716        /* Set ADC state (ADC master)                                             */
;;;717        /* - Clear state bitfield related to regular group conversion results     */
;;;718        /* - Set state bitfield related to regular operation                      */
;;;719        ADC_STATE_CLR_SET(hadc->State,
;;;720                          HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_MULTIMODE_SLAVE,
;;;721                          HAL_ADC_STATE_REG_BUSY);
;;;722          
;;;723        /* If conversions on group regular are also triggering group injected,    */
;;;724        /* update ADC state.                                                      */
;;;725        if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;726        {
;;;727          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;728        }
;;;729        
;;;730        /* Process unlocked */
;;;731        /* Unlock before starting ADC conversions: in case of potential           */
;;;732        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;733        __HAL_UNLOCK(hadc);
;;;734        
;;;735        /* Set ADC error code to none */
;;;736        ADC_CLEAR_ERRORCODE(hadc);
;;;737        
;;;738        
;;;739        /* Set the DMA transfer complete callback */
;;;740        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;741           
;;;742        /* Set the DMA half transfer complete callback */
;;;743        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;744        
;;;745        /* Set the DMA error callback */
;;;746        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;747    
;;;748        
;;;749        /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
;;;750        /* start (in case of SW start):                                           */
;;;751        
;;;752        /* Clear regular group conversion flag and overrun flag */
;;;753        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;754        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;755        
;;;756        /* Enable ADC DMA mode of ADC master */
;;;757        SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;758        
;;;759        /* Start the DMA channel */
;;;760        HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;761        
;;;762        /* Start conversion of regular group if software start has been selected. */
;;;763        /* If external trigger has been selected, conversion will start at next   */
;;;764        /* trigger event.                                                         */
;;;765        /* Note: Alternate trigger for single conversion could be to force an     */
;;;766        /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
;;;767        if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
;;;768        {
;;;769          /* Start ADC conversion on regular group with SW start */
;;;770          SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;771        }
;;;772        else
;;;773        {
;;;774          /* Start ADC conversion on regular group with external trigger */
;;;775          SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;776        }
;;;777      }
;;;778      else
;;;779      {
;;;780        /* Process unlocked */
;;;781        __HAL_UNLOCK(hadc);
;;;782      }
;;;783      
;;;784      /* Return function status */
;;;785      return tmp_hal_status;
;;;786    }
000040  b00c              ADD      sp,sp,#0x30
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L12.70|
000046  2002              MOVS     r0,#2                 ;685
000048  e7fa              B        |L12.64|
                  |L12.74|
00004a  4620              MOV      r0,r4                 ;707
00004c  f7fffffe          BL       ADC_Enable
000050  4605              MOV      r5,r0                 ;707
000052  0028              MOVS     r0,r5                 ;708
000054  d103              BNE      |L12.94|
000056  4668              MOV      r0,sp                 ;710
000058  f7fffffe          BL       ADC_Enable
00005c  4605              MOV      r5,r0                 ;710
                  |L12.94|
00005e  b11d              CBZ      r5,|L12.104|
000060  f8846024          STRB     r6,[r4,#0x24]         ;781
                  |L12.100|
000064  4628              MOV      r0,r5                 ;785
000066  e7eb              B        |L12.64|
                  |L12.104|
000068  6aa0              LDR      r0,[r4,#0x28]         ;719
00006a  491e              LDR      r1,|L12.228|
00006c  4008              ANDS     r0,r0,r1              ;719
00006e  f4407080          ORR      r0,r0,#0x100          ;719
000072  62a0              STR      r0,[r4,#0x28]         ;719
000074  6820              LDR      r0,[r4,#0]            ;725
000076  6840              LDR      r0,[r0,#4]            ;725
000078  0540              LSLS     r0,r0,#21             ;725
00007a  d505              BPL      |L12.136|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;727
00007e  f4205000          BIC      r0,r0,#0x2000         ;727
000082  f4405080          ORR      r0,r0,#0x1000         ;727
000086  62a0              STR      r0,[r4,#0x28]         ;727
                  |L12.136|
000088  f8846024          STRB     r6,[r4,#0x24]         ;733
00008c  62e6              STR      r6,[r4,#0x2c]         ;736
00008e  6a21              LDR      r1,[r4,#0x20]         ;740
000090  4815              LDR      r0,|L12.232|
000092  6288              STR      r0,[r1,#0x28]         ;740
000094  6a21              LDR      r1,[r4,#0x20]         ;743
000096  4815              LDR      r0,|L12.236|
000098  62c8              STR      r0,[r1,#0x2c]         ;743
00009a  6a21              LDR      r1,[r4,#0x20]         ;746
00009c  4814              LDR      r0,|L12.240|
00009e  6308              STR      r0,[r1,#0x30]         ;746
0000a0  6821              LDR      r1,[r4,#0]            ;754
0000a2  f06f0002          MVN      r0,#2                 ;754
0000a6  6008              STR      r0,[r1,#0]            ;754
0000a8  6820              LDR      r0,[r4,#0]            ;757
0000aa  6881              LDR      r1,[r0,#8]            ;757
0000ac  f4417180          ORR      r1,r1,#0x100          ;757
0000b0  6081              STR      r1,[r0,#8]            ;757
0000b2  6821              LDR      r1,[r4,#0]            ;760
0000b4  4643              MOV      r3,r8                 ;760
0000b6  314c              ADDS     r1,r1,#0x4c           ;760
0000b8  463a              MOV      r2,r7                 ;760
0000ba  6a20              LDR      r0,[r4,#0x20]         ;760
0000bc  f7fffffe          BL       HAL_DMA_Start_IT
0000c0  6820              LDR      r0,[r4,#0]            ;767
0000c2  6881              LDR      r1,[r0,#8]            ;767
0000c4  f3c14142          UBFX     r1,r1,#17,#3          ;767
0000c8  2907              CMP      r1,#7                 ;767
0000ca  d004              BEQ      |L12.214|
0000cc  6881              LDR      r1,[r0,#8]            ;775
0000ce  f4411180          ORR      r1,r1,#0x100000       ;775
0000d2  6081              STR      r1,[r0,#8]            ;775
0000d4  e7c6              B        |L12.100|
                  |L12.214|
0000d6  6881              LDR      r1,[r0,#8]            ;770
0000d8  f44101a0          ORR      r1,r1,#0x500000       ;770
0000dc  6081              STR      r1,[r0,#8]            ;770
0000de  e7c1              B        |L12.100|
;;;787    
                          ENDP

                  |L12.224|
                          DCD      0x40012800
                  |L12.228|
                          DCD      0xffeffdfe
                  |L12.232|
                          DCD      ADC_DMAConvCplt
                  |L12.236|
                          DCD      ADC_DMAHalfConvCplt
                  |L12.240|
                          DCD      ADC_DMAError

                          AREA ||i.HAL_ADCEx_MultiModeStop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStop_DMA PROC
;;;800      */
;;;801    HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
000000  b530              PUSH     {r4,r5,lr}
;;;802    {
000002  b08d              SUB      sp,sp,#0x34
000004  4604              MOV      r4,r0
;;;803      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
;;;804      ADC_HandleTypeDef tmphadcSlave={0};
000006  2130              MOVS     r1,#0x30
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;805      
;;;806      /* Check the parameters */
;;;807      assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
;;;808      
;;;809      /* Process locked */
;;;810      __HAL_LOCK(hadc);
00000e  f8940024          LDRB     r0,[r4,#0x24]
000012  2801              CMP      r0,#1
000014  d008              BEQ      |L13.40|
000016  2001              MOVS     r0,#1
000018  f8840024          STRB     r0,[r4,#0x24]
;;;811    
;;;812      /* Stop potential conversion on going, on regular and injected groups */
;;;813      /* Disable ADC master peripheral */
;;;814      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       ADC_ConversionStop_Disable
;;;815      
;;;816      /* Check if ADC is effectively disabled */
;;;817      if(tmp_hal_status == HAL_OK)
000022  2500              MOVS     r5,#0
000024  b118              CBZ      r0,|L13.46|
000026  e023              B        |L13.112|
                  |L13.40|
000028  2002              MOVS     r0,#2                 ;810
                  |L13.42|
;;;818      {
;;;819        /* Set a temporary handle of the ADC slave associated to the ADC master   */
;;;820        ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
;;;821    
;;;822        /* Disable ADC slave peripheral */
;;;823        tmp_hal_status = ADC_ConversionStop_Disable(&tmphadcSlave);
;;;824    
;;;825        /* Check if ADC is effectively disabled */
;;;826        if(tmp_hal_status != HAL_OK)
;;;827        {
;;;828          /* Update ADC state machine to error */
;;;829          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;830    
;;;831          /* Process unlocked */
;;;832          __HAL_UNLOCK(hadc);
;;;833    
;;;834          return HAL_ERROR;
;;;835        }
;;;836    
;;;837        /* Disable ADC DMA mode */
;;;838        CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;839        
;;;840        /* Reset configuration of ADC DMA continuous request for dual mode */
;;;841        CLEAR_BIT(hadc->Instance->CR1, ADC_CR1_DUALMOD);
;;;842            
;;;843        /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;844        /* while DMA transfer is on going)                                        */
;;;845        tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;846    
;;;847        /* Change ADC state (ADC master) */
;;;848        ADC_STATE_CLR_SET(hadc->State,
;;;849                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;850                          HAL_ADC_STATE_READY);
;;;851      }
;;;852      
;;;853      /* Process unlocked */
;;;854      __HAL_UNLOCK(hadc);
;;;855      
;;;856      /* Return function status */
;;;857      return tmp_hal_status;
;;;858    }
00002a  b00d              ADD      sp,sp,#0x34
00002c  bd30              POP      {r4,r5,pc}
                  |L13.46|
00002e  4812              LDR      r0,|L13.120|
000030  9001              STR      r0,[sp,#4]            ;820
000032  a801              ADD      r0,sp,#4              ;823
000034  f7fffffe          BL       ADC_ConversionStop_Disable
000038  b138              CBZ      r0,|L13.74|
00003a  6aa0              LDR      r0,[r4,#0x28]         ;829
00003c  f0400010          ORR      r0,r0,#0x10           ;829
000040  62a0              STR      r0,[r4,#0x28]         ;829
000042  f8845024          STRB     r5,[r4,#0x24]         ;832
000046  2001              MOVS     r0,#1                 ;834
000048  e7ef              B        |L13.42|
                  |L13.74|
00004a  6820              LDR      r0,[r4,#0]            ;838
00004c  6881              LDR      r1,[r0,#8]            ;838
00004e  f4217180          BIC      r1,r1,#0x100          ;838
000052  6081              STR      r1,[r0,#8]            ;838
000054  6820              LDR      r0,[r4,#0]            ;841
000056  6841              LDR      r1,[r0,#4]            ;841
000058  f4212170          BIC      r1,r1,#0xf0000        ;841
00005c  6041              STR      r1,[r0,#4]            ;841
00005e  6a20              LDR      r0,[r4,#0x20]         ;845
000060  f7fffffe          BL       HAL_DMA_Abort
000064  6aa1              LDR      r1,[r4,#0x28]         ;848
000066  f4215188          BIC      r1,r1,#0x1100         ;848
00006a  f0410101          ORR      r1,r1,#1              ;848
00006e  62a1              STR      r1,[r4,#0x28]         ;848
                  |L13.112|
000070  f8845024          STRB     r5,[r4,#0x24]         ;854
000074  e7d9              B        |L13.42|
;;;859    #endif /* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */
                          ENDP

000076  0000              DCW      0x0000
                  |L13.120|
                          DCD      0x40012800

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_adc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REVSH|
#line 478
|__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____RRX|
#line 665
|__asm___22_stm32f1xx_hal_adc_ex_c_3613cd7f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
