; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\diskio.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\diskio.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\diskio.crf ..\Middlewares\Third_Party\FatFs\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;89       */
;;;90     DSTATUS disk_initialize (
000000  b510              PUSH     {r4,lr}
;;;91     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;92     )
;;;93     {
;;;94       DSTATUS stat = RES_OK;
000002  2100              MOVS     r1,#0
;;;95       
;;;96       if(disk.is_initialized[pdrv] == 0)
000004  4a08              LDR      r2,|L1.40|
000006  5c13              LDRB     r3,[r2,r0]
000008  2b00              CMP      r3,#0
00000a  d10a              BNE      |L1.34|
;;;97       { 
;;;98         disk.is_initialized[pdrv] = 1;
00000c  2101              MOVS     r1,#1
00000e  5411              STRB     r1,[r2,r0]
;;;99         stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
000010  1811              ADDS     r1,r2,r0
000012  eb020080          ADD      r0,r2,r0,LSL #2
000016  7a09              LDRB     r1,[r1,#8]
000018  6840              LDR      r0,[r0,#4]
00001a  6802              LDR      r2,[r0,#0]
00001c  4608              MOV      r0,r1
00001e  4790              BLX      r2
000020  4601              MOV      r1,r0
                  |L1.34|
;;;100      }
;;;101      return stat;
000022  4608              MOV      r0,r1
;;;102    }
000024  bd10              POP      {r4,pc}
;;;103    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      disk

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;155    #if _USE_IOCTL == 1
;;;156    DRESULT disk_ioctl (
000000  b430              PUSH     {r4,r5}
;;;157    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;158    	BYTE cmd,		/* Control code */
;;;159    	void *buff		/* Buffer to send/receive control data */
;;;160    )
;;;161    {
;;;162      DRESULT res;
;;;163    
;;;164      res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
000002  4b05              LDR      r3,|L2.24|
000004  181c              ADDS     r4,r3,r0
000006  eb030080          ADD      r0,r3,r0,LSL #2
00000a  7a24              LDRB     r4,[r4,#8]
00000c  6840              LDR      r0,[r0,#4]
00000e  6903              LDR      r3,[r0,#0x10]
000010  4620              MOV      r0,r4
000012  bc30              POP      {r4,r5}
000014  4718              BX       r3
;;;165      return res;
;;;166    }
;;;167    #endif /* _USE_IOCTL == 1 */
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      disk

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;111      */
;;;112    DRESULT disk_read (
000000  b430              PUSH     {r4,r5}
;;;113    	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;114    	BYTE *buff,		/* Data buffer to store read data */
;;;115    	DWORD sector,	        /* Sector address in LBA */
;;;116    	UINT count		/* Number of sectors to read */
;;;117    )
;;;118    {
;;;119      DRESULT res;
;;;120     
;;;121      res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
000002  4c05              LDR      r4,|L3.24|
000004  1825              ADDS     r5,r4,r0
000006  eb040080          ADD      r0,r4,r0,LSL #2
00000a  7a2d              LDRB     r5,[r5,#8]
00000c  6840              LDR      r0,[r0,#4]
00000e  6884              LDR      r4,[r0,#8]
000010  4628              MOV      r0,r5
000012  46a4              MOV      r12,r4
000014  bc30              POP      {r4,r5}
000016  4760              BX       r12
;;;122      return res;
;;;123    }
;;;124    
                          ENDP

                  |L3.24|
                          DCD      disk

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=2

                  disk_status PROC
;;;74       */
;;;75     DSTATUS disk_status (
000000  4904              LDR      r1,|L4.20|
;;;76     	BYTE pdrv		/* Physical drive nmuber to identify the drive */
;;;77     )
;;;78     {
;;;79       DSTATUS stat;
;;;80       
;;;81       stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
000002  180a              ADDS     r2,r1,r0
000004  eb010080          ADD      r0,r1,r0,LSL #2
000008  7a12              LDRB     r2,[r2,#8]
00000a  6840              LDR      r0,[r0,#4]
00000c  6841              LDR      r1,[r0,#4]
00000e  4610              MOV      r0,r2
000010  4708              BX       r1
;;;82       return stat;
;;;83     }
;;;84     
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      disk

                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;133    #if _USE_WRITE == 1
;;;134    DRESULT disk_write (
000000  b430              PUSH     {r4,r5}
;;;135    	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;136    	const BYTE *buff,	/* Data to be written */
;;;137    	DWORD sector,		/* Sector address in LBA */
;;;138    	UINT count        	/* Number of sectors to write */
;;;139    )
;;;140    {
;;;141      DRESULT res;
;;;142      
;;;143      res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
000002  4c05              LDR      r4,|L5.24|
000004  1825              ADDS     r5,r4,r0
000006  eb040080          ADD      r0,r4,r0,LSL #2
00000a  7a2d              LDRB     r5,[r5,#8]
00000c  6840              LDR      r0,[r0,#4]
00000e  68c4              LDR      r4,[r0,#0xc]
000010  4628              MOV      r0,r5
000012  46a4              MOV      r12,r4
000014  bc30              POP      {r4,r5}
000016  4760              BX       r12
;;;144      return res;
;;;145    }
;;;146    #endif /* _USE_WRITE == 1 */
                          ENDP

                  |L5.24|
                          DCD      disk

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;173      */
;;;174    __weak DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;175    {
;;;176      return 0;
;;;177    }
000002  4770              BX       lr
;;;178    
                          ENDP

