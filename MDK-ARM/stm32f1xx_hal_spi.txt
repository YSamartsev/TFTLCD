; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_hal_spi.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_hal_spi.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_hal_spi.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_Abort||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort PROC
;;;2053     */
;;;2054   HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2055   {
000002  4604              MOV      r4,r0
;;;2056     HAL_StatusTypeDef errorcode;
;;;2057     __IO uint32_t count;
;;;2058     __IO uint32_t resetcount;
;;;2059   
;;;2060     /* Initialized local variable  */
;;;2061     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2062     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4844              LDR      r0,|L1.280|
000008  f64551c0          MOV      r1,#0x5dc0
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  2164              MOVS     r1,#0x64
000014  4348              MULS     r0,r1,r0
000016  9001              STR      r0,[sp,#4]
;;;2063     count = resetcount;
000018  9801              LDR      r0,[sp,#4]
00001a  9002              STR      r0,[sp,#8]
;;;2064   
;;;2065     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2066     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6841              LDR      r1,[r0,#4]
000020  f0210120          BIC      r1,r1,#0x20
000024  6041              STR      r1,[r0,#4]
;;;2067   
;;;2068     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;2069     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000026  6821              LDR      r1,[r4,#0]
000028  6848              LDR      r0,[r1,#4]
00002a  0600              LSLS     r0,r0,#24
00002c  d50d              BPL      |L1.74|
;;;2070     {
;;;2071       hspi->TxISR = SPI_AbortTx_ISR;
00002e  483b              LDR      r0,|L1.284|
000030  6460              STR      r0,[r4,#0x44]
                  |L1.50|
;;;2072       /* Wait HAL_SPI_STATE_ABORT state */
;;;2073       do
;;;2074       {
;;;2075         if (count == 0U)
000032  9802              LDR      r0,[sp,#8]
000034  2800              CMP      r0,#0
000036  d05c              BEQ      |L1.242|
;;;2076         {
;;;2077           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2078           break;
;;;2079         }
;;;2080         count--;
000038  9802              LDR      r0,[sp,#8]
00003a  1e40              SUBS     r0,r0,#1
00003c  9002              STR      r0,[sp,#8]
;;;2081       } while (hspi->State != HAL_SPI_STATE_ABORT);
00003e  f8940051          LDRB     r0,[r4,#0x51]
000042  2807              CMP      r0,#7
000044  d1f5              BNE      |L1.50|
                  |L1.70|
;;;2082       /* Reset Timeout Counter */
;;;2083       count = resetcount;
000046  9801              LDR      r0,[sp,#4]
000048  9002              STR      r0,[sp,#8]
                  |L1.74|
;;;2084     }
;;;2085   
;;;2086     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
00004a  6848              LDR      r0,[r1,#4]
00004c  0640              LSLS     r0,r0,#25
00004e  d50c              BPL      |L1.106|
;;;2087     {
;;;2088       hspi->RxISR = SPI_AbortRx_ISR;
000050  4833              LDR      r0,|L1.288|
000052  6420              STR      r0,[r4,#0x40]
                  |L1.84|
;;;2089       /* Wait HAL_SPI_STATE_ABORT state */
;;;2090       do
;;;2091       {
;;;2092         if (count == 0U)
000054  9802              LDR      r0,[sp,#8]
000056  b3e8              CBZ      r0,|L1.212|
;;;2093         {
;;;2094           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2095           break;
;;;2096         }
;;;2097         count--;
000058  9802              LDR      r0,[sp,#8]
00005a  1e40              SUBS     r0,r0,#1
00005c  9002              STR      r0,[sp,#8]
;;;2098       } while (hspi->State != HAL_SPI_STATE_ABORT);
00005e  f8940051          LDRB     r0,[r4,#0x51]
000062  2807              CMP      r0,#7
000064  d1f6              BNE      |L1.84|
                  |L1.102|
;;;2099       /* Reset Timeout Counter */
;;;2100       count = resetcount;
000066  9801              LDR      r0,[sp,#4]
000068  9002              STR      r0,[sp,#8]
                  |L1.106|
;;;2101     }
;;;2102   
;;;2103     /* Disable the SPI DMA Tx request if enabled */
;;;2104     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
00006a  6848              LDR      r0,[r1,#4]
;;;2105     {
;;;2106       /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2107       if (hspi->hdmatx != NULL)
;;;2108       {
;;;2109         /* Set the SPI DMA Abort callback :
;;;2110         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2111         hspi->hdmatx->XferAbortCallback = NULL;
;;;2112   
;;;2113         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2114         if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
;;;2115         {
;;;2116           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
00006c  f04f0740          MOV      r7,#0x40
000070  0780              LSLS     r0,r0,#30             ;2104
000072  f04f0600          MOV      r6,#0
000076  d515              BPL      |L1.164|
000078  6ca0              LDR      r0,[r4,#0x48]         ;2107
00007a  b198              CBZ      r0,|L1.164|
00007c  6346              STR      r6,[r0,#0x34]         ;2111
00007e  6ca0              LDR      r0,[r4,#0x48]         ;2114
000080  f7fffffe          BL       HAL_DMA_Abort
000084  b100              CBZ      r0,|L1.136|
000086  6567              STR      r7,[r4,#0x54]
                  |L1.136|
;;;2117         }
;;;2118   
;;;2119         /* Disable Tx DMA Request */
;;;2120         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
000088  6820              LDR      r0,[r4,#0]
00008a  6841              LDR      r1,[r0,#4]
00008c  f0210102          BIC      r1,r1,#2
000090  6041              STR      r1,[r0,#4]
000092  6820              LDR      r0,[r4,#0]            ;2066
                  |L1.148|
;;;2121   
;;;2122         /* Wait until TXE flag is set */
;;;2123         do
;;;2124         {
;;;2125           if (count == 0U)
000094  9902              LDR      r1,[sp,#8]
000096  b389              CBZ      r1,|L1.252|
;;;2126           {
;;;2127             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2128             break;
;;;2129           }
;;;2130           count--;
000098  9902              LDR      r1,[sp,#8]
00009a  1e49              SUBS     r1,r1,#1
00009c  9102              STR      r1,[sp,#8]
;;;2131         } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
00009e  6881              LDR      r1,[r0,#8]
0000a0  0789              LSLS     r1,r1,#30
0000a2  d5f7              BPL      |L1.148|
                  |L1.164|
;;;2132       }
;;;2133     }
;;;2134   
;;;2135     /* Disable the SPI DMA Rx request if enabled */
;;;2136     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6840              LDR      r0,[r0,#4]
0000a8  07c0              LSLS     r0,r0,#31
0000aa  d011              BEQ      |L1.208|
;;;2137     {
;;;2138       /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2139       if (hspi->hdmarx != NULL)
0000ac  6ce0              LDR      r0,[r4,#0x4c]
0000ae  b178              CBZ      r0,|L1.208|
;;;2140       {
;;;2141         /* Set the SPI DMA Abort callback :
;;;2142         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2143         hspi->hdmarx->XferAbortCallback = NULL;
0000b0  6346              STR      r6,[r0,#0x34]
;;;2144   
;;;2145         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2146         if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
0000b2  6ce0              LDR      r0,[r4,#0x4c]
0000b4  f7fffffe          BL       HAL_DMA_Abort
0000b8  b100              CBZ      r0,|L1.188|
;;;2147         {
;;;2148           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000ba  6567              STR      r7,[r4,#0x54]
                  |L1.188|
;;;2149         }
;;;2150   
;;;2151         /* Disable peripheral */
;;;2152         __HAL_SPI_DISABLE(hspi);
0000bc  6820              LDR      r0,[r4,#0]
0000be  6801              LDR      r1,[r0,#0]
0000c0  f0210140          BIC      r1,r1,#0x40
0000c4  6001              STR      r1,[r0,#0]
;;;2153   
;;;2154         /* Disable Rx DMA Request */
;;;2155         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6841              LDR      r1,[r0,#4]
0000ca  f0210101          BIC      r1,r1,#1
0000ce  6041              STR      r1,[r0,#4]
                  |L1.208|
;;;2156       }
;;;2157     }
;;;2158     /* Reset Tx and Rx transfer counters */
;;;2159     hspi->RxXferCount = 0U;
0000d0  87e6              STRH     r6,[r4,#0x3e]
;;;2160     hspi->TxXferCount = 0U;
0000d2  e000              B        |L1.214|
                  |L1.212|
0000d4  e013              B        |L1.254|
                  |L1.214|
0000d6  86e6              STRH     r6,[r4,#0x36]
;;;2161   
;;;2162     /* Check error during Abort procedure */
;;;2163     if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
0000d8  6d60              LDR      r0,[r4,#0x54]
0000da  2840              CMP      r0,#0x40
0000dc  d019              BEQ      |L1.274|
;;;2164     {
;;;2165       /* return HAL_Error in case of error during Abort procedure */
;;;2166       errorcode = HAL_ERROR;
;;;2167     }
;;;2168     else
;;;2169     {
;;;2170       /* Reset errorCode */
;;;2171       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
0000de  6566              STR      r6,[r4,#0x54]
                  |L1.224|
;;;2172     }
;;;2173   
;;;2174     /* Clear the Error flags in the SR register */
;;;2175     __HAL_SPI_CLEAR_OVRFLAG(hspi);
0000e0  6820              LDR      r0,[r4,#0]
0000e2  68c1              LDR      r1,[r0,#0xc]
0000e4  6880              LDR      r0,[r0,#8]
0000e6  9000              STR      r0,[sp,#0]
;;;2176   
;;;2177     /* Restore hspi->state to ready */
;;;2178     hspi->State = HAL_SPI_STATE_READY;
0000e8  2001              MOVS     r0,#1
0000ea  f8840051          STRB     r0,[r4,#0x51]
;;;2179   
;;;2180     return errorcode;
0000ee  4628              MOV      r0,r5
;;;2181   }
0000f0  bdfe              POP      {r1-r7,pc}
                  |L1.242|
0000f2  6d60              LDR      r0,[r4,#0x54]         ;2077
0000f4  f0400040          ORR      r0,r0,#0x40           ;2077
0000f8  6560              STR      r0,[r4,#0x54]         ;2077
0000fa  e7a4              B        |L1.70|
                  |L1.252|
0000fc  e004              B        |L1.264|
                  |L1.254|
0000fe  6d60              LDR      r0,[r4,#0x54]         ;2094
000100  f0400040          ORR      r0,r0,#0x40           ;2094
000104  6560              STR      r0,[r4,#0x54]         ;2094
000106  e7ae              B        |L1.102|
                  |L1.264|
000108  6d60              LDR      r0,[r4,#0x54]         ;2127
00010a  f0400040          ORR      r0,r0,#0x40           ;2127
00010e  6560              STR      r0,[r4,#0x54]         ;2127
000110  e7c8              B        |L1.164|
                  |L1.274|
000112  2501              MOVS     r5,#1                 ;2166
000114  e7e4              B        |L1.224|
;;;2182   
                          ENDP

000116  0000              DCW      0x0000
                  |L1.280|
                          DCD      SystemCoreClock
                  |L1.284|
                          DCD      SPI_AbortTx_ISR
                  |L1.288|
                          DCD      SPI_AbortRx_ISR

                          AREA ||i.HAL_SPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_AbortCpltCallback PROC
;;;2655     */
;;;2656   __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2657   {
;;;2658     /* Prevent unused argument(s) compilation warning */
;;;2659     UNUSED(hspi);
;;;2660   
;;;2661     /* NOTE : This function should not be modified, when the callback is needed,
;;;2662               the HAL_SPI_AbortCpltCallback can be implemented in the user file.
;;;2663      */
;;;2664   }
;;;2665   
                          ENDP


                          AREA ||i.HAL_SPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort_IT PROC
;;;2197     */
;;;2198   HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;2199   {
000004  4604              MOV      r4,r0
;;;2200     HAL_StatusTypeDef errorcode;
;;;2201     uint32_t abortcplt ;
;;;2202     __IO uint32_t count;
;;;2203     __IO uint32_t resetcount;
;;;2204   
;;;2205     /* Initialized local variable  */
;;;2206     errorcode = HAL_OK;
000006  2600              MOVS     r6,#0
;;;2207     abortcplt = 1U;
000008  2501              MOVS     r5,#1
;;;2208     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000a  4843              LDR      r0,|L3.280|
00000c  f64551c0          MOV      r1,#0x5dc0
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;2209     count = resetcount;
00001c  9801              LDR      r0,[sp,#4]
00001e  9002              STR      r0,[sp,#8]
;;;2210   
;;;2211     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2212     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000020  6820              LDR      r0,[r4,#0]
000022  6841              LDR      r1,[r0,#4]
000024  f0210120          BIC      r1,r1,#0x20
000028  6041              STR      r1,[r0,#4]
;;;2213   
;;;2214     /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
;;;2215     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
00002a  6821              LDR      r1,[r4,#0]
00002c  6848              LDR      r0,[r1,#4]
00002e  0600              LSLS     r0,r0,#24
000030  d50c              BPL      |L3.76|
;;;2216     {
;;;2217       hspi->TxISR = SPI_AbortTx_ISR;
000032  483a              LDR      r0,|L3.284|
000034  6460              STR      r0,[r4,#0x44]
                  |L3.54|
;;;2218       /* Wait HAL_SPI_STATE_ABORT state */
;;;2219       do
;;;2220       {
;;;2221         if (count == 0U)
000036  9802              LDR      r0,[sp,#8]
000038  b308              CBZ      r0,|L3.126|
;;;2222         {
;;;2223           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2224           break;
;;;2225         }
;;;2226         count--;
00003a  9802              LDR      r0,[sp,#8]
00003c  1e40              SUBS     r0,r0,#1
00003e  9002              STR      r0,[sp,#8]
;;;2227       } while (hspi->State != HAL_SPI_STATE_ABORT);
000040  f8940051          LDRB     r0,[r4,#0x51]
000044  2807              CMP      r0,#7
000046  d1f6              BNE      |L3.54|
                  |L3.72|
;;;2228       /* Reset Timeout Counter */
;;;2229       count = resetcount;
000048  9801              LDR      r0,[sp,#4]
00004a  9002              STR      r0,[sp,#8]
                  |L3.76|
;;;2230     }
;;;2231   
;;;2232     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
00004c  6848              LDR      r0,[r1,#4]
00004e  0640              LSLS     r0,r0,#25
000050  d50c              BPL      |L3.108|
;;;2233     {
;;;2234       hspi->RxISR = SPI_AbortRx_ISR;
000052  4833              LDR      r0,|L3.288|
000054  6420              STR      r0,[r4,#0x40]
                  |L3.86|
;;;2235       /* Wait HAL_SPI_STATE_ABORT state */
;;;2236       do
;;;2237       {
;;;2238         if (count == 0U)
000056  9802              LDR      r0,[sp,#8]
000058  b1b0              CBZ      r0,|L3.136|
;;;2239         {
;;;2240           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2241           break;
;;;2242         }
;;;2243         count--;
00005a  9802              LDR      r0,[sp,#8]
00005c  1e40              SUBS     r0,r0,#1
00005e  9002              STR      r0,[sp,#8]
;;;2244       } while (hspi->State != HAL_SPI_STATE_ABORT);
000060  f8940051          LDRB     r0,[r4,#0x51]
000064  2807              CMP      r0,#7
000066  d1f6              BNE      |L3.86|
                  |L3.104|
;;;2245       /* Reset Timeout Counter */
;;;2246       count = resetcount;
000068  9801              LDR      r0,[sp,#4]
00006a  9002              STR      r0,[sp,#8]
                  |L3.108|
;;;2247     }
;;;2248   
;;;2249     /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
;;;2250        before any call to DMA Abort functions */
;;;2251     /* DMA Tx Handle is valid */
;;;2252     if (hspi->hdmatx != NULL)
00006c  6ca0              LDR      r0,[r4,#0x48]
00006e  2700              MOVS     r7,#0
000070  b180              CBZ      r0,|L3.148|
;;;2253     {
;;;2254       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2255          Otherwise, set it to NULL */
;;;2256       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000072  6849              LDR      r1,[r1,#4]
000074  0789              LSLS     r1,r1,#30
000076  d50c              BPL      |L3.146|
;;;2257       {
;;;2258         hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
000078  492a              LDR      r1,|L3.292|
00007a  6341              STR      r1,[r0,#0x34]
00007c  e00a              B        |L3.148|
                  |L3.126|
00007e  6d60              LDR      r0,[r4,#0x54]         ;2223
000080  f0400040          ORR      r0,r0,#0x40           ;2223
000084  6560              STR      r0,[r4,#0x54]         ;2223
000086  e7df              B        |L3.72|
                  |L3.136|
000088  6d60              LDR      r0,[r4,#0x54]         ;2240
00008a  f0400040          ORR      r0,r0,#0x40           ;2240
00008e  6560              STR      r0,[r4,#0x54]         ;2240
000090  e7ea              B        |L3.104|
                  |L3.146|
;;;2259       }
;;;2260       else
;;;2261       {
;;;2262         hspi->hdmatx->XferAbortCallback = NULL;
000092  6347              STR      r7,[r0,#0x34]
                  |L3.148|
;;;2263       }
;;;2264     }
;;;2265     /* DMA Rx Handle is valid */
;;;2266     if (hspi->hdmarx != NULL)
000094  6ce0              LDR      r0,[r4,#0x4c]
000096  b138              CBZ      r0,|L3.168|
;;;2267     {
;;;2268       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2269          Otherwise, set it to NULL */
;;;2270       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
000098  6821              LDR      r1,[r4,#0]
00009a  6849              LDR      r1,[r1,#4]
00009c  07c9              LSLS     r1,r1,#31
00009e  d002              BEQ      |L3.166|
;;;2271       {
;;;2272         hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
0000a0  4921              LDR      r1,|L3.296|
0000a2  6341              STR      r1,[r0,#0x34]
0000a4  e000              B        |L3.168|
                  |L3.166|
;;;2273       }
;;;2274       else
;;;2275       {
;;;2276         hspi->hdmarx->XferAbortCallback = NULL;
0000a6  6347              STR      r7,[r0,#0x34]
                  |L3.168|
;;;2277       }
;;;2278     }
;;;2279   
;;;2280     /* Disable the SPI DMA Tx request if enabled */
;;;2281     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6840              LDR      r0,[r0,#4]
;;;2282     {
;;;2283       /* Abort the SPI DMA Tx Stream/Channel */
;;;2284       if (hspi->hdmatx != NULL)
;;;2285       {
;;;2286         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2287         if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
;;;2288         {
;;;2289           hspi->hdmatx->XferAbortCallback = NULL;
;;;2290           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000ac  f04f0840          MOV      r8,#0x40
0000b0  0780              LSLS     r0,r0,#30             ;2281
0000b2  d50a              BPL      |L3.202|
0000b4  6ca0              LDR      r0,[r4,#0x48]         ;2284
0000b6  b140              CBZ      r0,|L3.202|
0000b8  f7fffffe          BL       HAL_DMA_Abort_IT
0000bc  b120              CBZ      r0,|L3.200|
0000be  6ca0              LDR      r0,[r4,#0x48]         ;2289
0000c0  6347              STR      r7,[r0,#0x34]         ;2289
0000c2  f8c48054          STR      r8,[r4,#0x54]
0000c6  e000              B        |L3.202|
                  |L3.200|
;;;2291         }
;;;2292         else
;;;2293         {
;;;2294           abortcplt = 0U;
0000c8  2500              MOVS     r5,#0
                  |L3.202|
;;;2295         }
;;;2296       }
;;;2297     }
;;;2298     /* Disable the SPI DMA Rx request if enabled */
;;;2299     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6840              LDR      r0,[r0,#4]
0000ce  07c0              LSLS     r0,r0,#31
0000d0  d00a              BEQ      |L3.232|
;;;2300     {
;;;2301       /* Abort the SPI DMA Rx Stream/Channel */
;;;2302       if (hspi->hdmarx != NULL)
0000d2  6ce0              LDR      r0,[r4,#0x4c]
0000d4  b140              CBZ      r0,|L3.232|
;;;2303       {
;;;2304         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2305         if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
0000d6  f7fffffe          BL       HAL_DMA_Abort_IT
0000da  b120              CBZ      r0,|L3.230|
;;;2306         {
;;;2307           hspi->hdmarx->XferAbortCallback = NULL;
0000dc  6ce0              LDR      r0,[r4,#0x4c]
0000de  6347              STR      r7,[r0,#0x34]
;;;2308           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000e0  f8c48054          STR      r8,[r4,#0x54]
0000e4  e000              B        |L3.232|
                  |L3.230|
;;;2309         }
;;;2310         else
;;;2311         {
;;;2312           abortcplt = 0U;
0000e6  2500              MOVS     r5,#0
                  |L3.232|
;;;2313         }
;;;2314       }
;;;2315     }
;;;2316   
;;;2317     if (abortcplt == 1U)
0000e8  2d01              CMP      r5,#1
0000ea  d10f              BNE      |L3.268|
;;;2318     {
;;;2319       /* Reset Tx and Rx transfer counters */
;;;2320       hspi->RxXferCount = 0U;
0000ec  87e7              STRH     r7,[r4,#0x3e]
;;;2321       hspi->TxXferCount = 0U;
0000ee  86e7              STRH     r7,[r4,#0x36]
;;;2322   
;;;2323       /* Check error during Abort procedure */
;;;2324       if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
0000f0  6d60              LDR      r0,[r4,#0x54]
0000f2  2840              CMP      r0,#0x40
0000f4  d00d              BEQ      |L3.274|
;;;2325       {
;;;2326         /* return HAL_Error in case of error during Abort procedure */
;;;2327         errorcode = HAL_ERROR;
;;;2328       }
;;;2329       else
;;;2330       {
;;;2331         /* Reset errorCode */
;;;2332         hspi->ErrorCode = HAL_SPI_ERROR_NONE;
0000f6  6567              STR      r7,[r4,#0x54]
                  |L3.248|
;;;2333       }
;;;2334   
;;;2335       /* Clear the Error flags in the SR register */
;;;2336       __HAL_SPI_CLEAR_OVRFLAG(hspi);
0000f8  6820              LDR      r0,[r4,#0]
0000fa  68c1              LDR      r1,[r0,#0xc]
0000fc  6880              LDR      r0,[r0,#8]
0000fe  9000              STR      r0,[sp,#0]
;;;2337   
;;;2338       /* Restore hspi->State to Ready */
;;;2339       hspi->State = HAL_SPI_STATE_READY;
000100  2001              MOVS     r0,#1
000102  f8840051          STRB     r0,[r4,#0x51]
;;;2340   
;;;2341       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2342   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2343       hspi->AbortCpltCallback(hspi);
;;;2344   #else
;;;2345       HAL_SPI_AbortCpltCallback(hspi);
000106  4620              MOV      r0,r4
000108  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L3.268|
;;;2346   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2347     }
;;;2348   
;;;2349     return errorcode;
00010c  4630              MOV      r0,r6
;;;2350   }
00010e  e8bd83fe          POP      {r1-r9,pc}
                  |L3.274|
000112  2601              MOVS     r6,#1                 ;2327
000114  e7f0              B        |L3.248|
;;;2351   
                          ENDP

000116  0000              DCW      0x0000
                  |L3.280|
                          DCD      SystemCoreClock
                  |L3.284|
                          DCD      SPI_AbortTx_ISR
                  |L3.288|
                          DCD      SPI_AbortRx_ISR
                  |L3.292|
                          DCD      SPI_DMATxAbortCallback
                  |L3.296|
                          DCD      SPI_DMARxAbortCallback

                          AREA ||i.HAL_SPI_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAPause PROC
;;;2357     */
;;;2358   HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
000000  f8901050          LDRB     r1,[r0,#0x50]
;;;2359   {
;;;2360     /* Process Locked */
;;;2361     __HAL_LOCK(hspi);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L4.34|
000008  2101              MOVS     r1,#1
00000a  f8801050          STRB     r1,[r0,#0x50]
;;;2362   
;;;2363     /* Disable the SPI DMA Tx & Rx requests */
;;;2364     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0220203          BIC      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;2365   
;;;2366     /* Process Unlocked */
;;;2367     __HAL_UNLOCK(hspi);
000018  2100              MOVS     r1,#0
00001a  f8801050          STRB     r1,[r0,#0x50]
;;;2368   
;;;2369     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;2370   }
000020  4770              BX       lr
                  |L4.34|
000022  2002              MOVS     r0,#2                 ;2361
000024  4770              BX       lr
;;;2371   
                          ENDP


                          AREA ||i.HAL_SPI_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAResume PROC
;;;2377     */
;;;2378   HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
000000  f8901050          LDRB     r1,[r0,#0x50]
;;;2379   {
;;;2380     /* Process Locked */
;;;2381     __HAL_LOCK(hspi);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L5.34|
000008  2101              MOVS     r1,#1
00000a  f8801050          STRB     r1,[r0,#0x50]
;;;2382   
;;;2383     /* Enable the SPI DMA Tx & Rx requests */
;;;2384     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00000e  6801              LDR      r1,[r0,#0]
000010  684a              LDR      r2,[r1,#4]
000012  f0420203          ORR      r2,r2,#3
000016  604a              STR      r2,[r1,#4]
;;;2385   
;;;2386     /* Process Unlocked */
;;;2387     __HAL_UNLOCK(hspi);
000018  2100              MOVS     r1,#0
00001a  f8801050          STRB     r1,[r0,#0x50]
;;;2388   
;;;2389     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;2390   }
000020  4770              BX       lr
                  |L5.34|
000022  2002              MOVS     r0,#2                 ;2381
000024  4770              BX       lr
;;;2391   
                          ENDP


                          AREA ||i.HAL_SPI_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAStop PROC
;;;2397     */
;;;2398   HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
000000  b570              PUSH     {r4-r6,lr}
;;;2399   {
000002  4604              MOV      r4,r0
;;;2400     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2401     /* The Lock is not implemented on this API to allow the user application
;;;2402        to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or
;;;2403        HAL_SPI_TxRxCpltCallback():
;;;2404        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;2405        and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or
;;;2406        HAL_SPI_TxRxCpltCallback()
;;;2407        */
;;;2408   
;;;2409     /* Abort the SPI DMA tx Stream/Channel  */
;;;2410     if (hspi->hdmatx != NULL)
000006  6ca0              LDR      r0,[r4,#0x48]
000008  2800              CMP      r0,#0
00000a  d007              BEQ      |L6.28|
;;;2411     {
;;;2412       if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
00000c  f7fffffe          BL       HAL_DMA_Abort
000010  b120              CBZ      r0,|L6.28|
;;;2413       {
;;;2414         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;2415         errorcode = HAL_ERROR;
00001a  2501              MOVS     r5,#1
                  |L6.28|
;;;2416       }
;;;2417     }
;;;2418     /* Abort the SPI DMA rx Stream/Channel  */
;;;2419     if (hspi->hdmarx != NULL)
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  b138              CBZ      r0,|L6.48|
;;;2420     {
;;;2421       if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
000020  f7fffffe          BL       HAL_DMA_Abort
000024  b120              CBZ      r0,|L6.48|
;;;2422       {
;;;2423         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000026  6d60              LDR      r0,[r4,#0x54]
000028  f0400010          ORR      r0,r0,#0x10
00002c  6560              STR      r0,[r4,#0x54]
;;;2424         errorcode = HAL_ERROR;
00002e  2501              MOVS     r5,#1
                  |L6.48|
;;;2425       }
;;;2426     }
;;;2427   
;;;2428     /* Disable the SPI DMA Tx & Rx requests */
;;;2429     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000030  6820              LDR      r0,[r4,#0]
000032  6841              LDR      r1,[r0,#4]
000034  f0210103          BIC      r1,r1,#3
000038  6041              STR      r1,[r0,#4]
;;;2430     hspi->State = HAL_SPI_STATE_READY;
00003a  2001              MOVS     r0,#1
00003c  f8840051          STRB     r0,[r4,#0x51]
;;;2431     return errorcode;
000040  4628              MOV      r0,r5
;;;2432   }
000042  bd70              POP      {r4-r6,pc}
;;;2433   
                          ENDP


                          AREA ||i.HAL_SPI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DeInit PROC
;;;462      */
;;;463    HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;464    {
000002  4604              MOV      r4,r0
;;;465      /* Check the SPI handle allocation */
;;;466      if (hspi == NULL)
000004  2c00              CMP      r4,#0
000006  d010              BEQ      |L7.42|
;;;467      {
;;;468        return HAL_ERROR;
;;;469      }
;;;470    
;;;471      /* Check SPI Instance parameter */
;;;472      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;473    
;;;474      hspi->State = HAL_SPI_STATE_BUSY;
000008  2002              MOVS     r0,#2
00000a  f8840051          STRB     r0,[r4,#0x51]
;;;475    
;;;476      /* Disable the SPI Peripheral Clock */
;;;477      __HAL_SPI_DISABLE(hspi);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0210140          BIC      r1,r1,#0x40
000016  6001              STR      r1,[r0,#0]
;;;478    
;;;479    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;480      if (hspi->MspDeInitCallback == NULL)
;;;481      {
;;;482        hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
;;;483      }
;;;484    
;;;485      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;486      hspi->MspDeInitCallback(hspi);
;;;487    #else
;;;488      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;489      HAL_SPI_MspDeInit(hspi);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_SPI_MspDeInit
;;;490    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;491    
;;;492      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  3450              ADDS     r4,r4,#0x50
000022  6060              STR      r0,[r4,#4]
;;;493      hspi->State = HAL_SPI_STATE_RESET;
000024  7060              STRB     r0,[r4,#1]
;;;494    
;;;495      /* Release Lock */
;;;496      __HAL_UNLOCK(hspi);
000026  7020              STRB     r0,[r4,#0]
;;;497    
;;;498      return HAL_OK;
;;;499    }
000028  bd10              POP      {r4,pc}
                  |L7.42|
00002a  2001              MOVS     r0,#1                 ;468
00002c  bd10              POP      {r4,pc}
;;;500    
                          ENDP


                          AREA ||i.HAL_SPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_ErrorCallback PROC
;;;2637     */
;;;2638   __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2639   {
;;;2640     /* Prevent unused argument(s) compilation warning */
;;;2641     UNUSED(hspi);
;;;2642   
;;;2643     /* NOTE : This function should not be modified, when the callback is needed,
;;;2644               the HAL_SPI_ErrorCallback should be implemented in the user file
;;;2645      */
;;;2646     /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
;;;2647               and user can use HAL_SPI_GetError() API to check the latest error occurred
;;;2648      */
;;;2649   }
;;;2650   
                          ENDP


                          AREA ||i.HAL_SPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetError PROC
;;;2702     */
;;;2703   uint32_t HAL_SPI_GetError(const SPI_HandleTypeDef *hspi)
000000  6d40              LDR      r0,[r0,#0x54]
;;;2704   {
;;;2705     /* Return SPI ErrorCode */
;;;2706     return hspi->ErrorCode;
;;;2707   }
000002  4770              BX       lr
;;;2708   
                          ENDP


                          AREA ||i.HAL_SPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetState PROC
;;;2690     */
;;;2691   HAL_SPI_StateTypeDef HAL_SPI_GetState(const SPI_HandleTypeDef *hspi)
000000  f8900051          LDRB     r0,[r0,#0x51]
;;;2692   {
;;;2693     /* Return SPI handle state */
;;;2694     return hspi->State;
;;;2695   }
000004  4770              BX       lr
;;;2696   
                          ENDP


                          AREA ||i.HAL_SPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SPI_IRQHandler PROC
;;;2439     */
;;;2440   void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;2441   {
000002  4604              MOV      r4,r0
;;;2442     uint32_t itsource = hspi->Instance->CR2;
000004  6820              LDR      r0,[r4,#0]
000006  6842              LDR      r2,[r0,#4]
;;;2443     uint32_t itflag   = hspi->Instance->SR;
000008  6881              LDR      r1,[r0,#8]
;;;2444   
;;;2445     /* SPI in mode Receiver ----------------------------------------------------*/
;;;2446     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
00000a  43c9              MVNS     r1,r1
00000c  064b              LSLS     r3,r1,#25
00000e  d50a              BPL      |L11.38|
;;;2447         (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
000010  07cb              LSLS     r3,r1,#31
000012  d108              BNE      |L11.38|
000014  43d3              MVNS     r3,r2
000016  065b              LSLS     r3,r3,#25
000018  d405              BMI      |L11.38|
;;;2448     {
;;;2449       hspi->RxISR(hspi);
00001a  6c21              LDR      r1,[r4,#0x40]
00001c  b001              ADD      sp,sp,#4
00001e  4620              MOV      r0,r4
000020  e8bd4030          POP      {r4,r5,lr}
000024  4708              BX       r1
                  |L11.38|
;;;2450       return;
;;;2451     }
;;;2452   
;;;2453     /* SPI in mode Transmitter -------------------------------------------------*/
;;;2454     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
000026  078b              LSLS     r3,r1,#30
000028  d408              BMI      |L11.60|
00002a  43d3              MVNS     r3,r2
00002c  061b              LSLS     r3,r3,#24
00002e  d405              BMI      |L11.60|
;;;2455     {
;;;2456       hspi->TxISR(hspi);
000030  6c61              LDR      r1,[r4,#0x44]
000032  b001              ADD      sp,sp,#4
000034  4620              MOV      r0,r4
000036  e8bd4030          POP      {r4,r5,lr}
00003a  4708              BX       r1
                  |L11.60|
;;;2457       return;
;;;2458     }
;;;2459   
;;;2460     /* SPI in Error Treatment --------------------------------------------------*/
;;;2461     if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET))
00003c  068b              LSLS     r3,r1,#26
00003e  d501              BPL      |L11.68|
000040  064b              LSLS     r3,r1,#25
000042  d44a              BMI      |L11.218|
                  |L11.68|
;;;2462         && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
000044  43d3              MVNS     r3,r2
000046  069b              LSLS     r3,r3,#26
000048  d447              BMI      |L11.218|
;;;2463     {
;;;2464       /* SPI Overrun error interrupt occurred ----------------------------------*/
;;;2465       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
00004a  064b              LSLS     r3,r1,#25
00004c  d40a              BMI      |L11.100|
;;;2466       {
;;;2467         if (hspi->State != HAL_SPI_STATE_BUSY_TX)
00004e  f8943051          LDRB     r3,[r4,#0x51]
000052  2b03              CMP      r3,#3
000054  d042              BEQ      |L11.220|
;;;2468         {
;;;2469           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
000056  6d63              LDR      r3,[r4,#0x54]
000058  f0430304          ORR      r3,r3,#4
00005c  6563              STR      r3,[r4,#0x54]
;;;2470           __HAL_SPI_CLEAR_OVRFLAG(hspi);
00005e  68c3              LDR      r3,[r0,#0xc]
000060  6883              LDR      r3,[r0,#8]
000062  9300              STR      r3,[sp,#0]
                  |L11.100|
;;;2471         }
;;;2472         else
;;;2473         {
;;;2474           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2475           return;
;;;2476         }
;;;2477       }
;;;2478   
;;;2479       /* SPI Mode Fault error interrupt occurred -------------------------------*/
;;;2480       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
000064  0689              LSLS     r1,r1,#26
000066  d409              BMI      |L11.124|
;;;2481       {
;;;2482         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
000068  6d61              LDR      r1,[r4,#0x54]
00006a  f0410101          ORR      r1,r1,#1
00006e  6561              STR      r1,[r4,#0x54]
;;;2483         __HAL_SPI_CLEAR_MODFFLAG(hspi);
000070  6881              LDR      r1,[r0,#8]
000072  9100              STR      r1,[sp,#0]
000074  6801              LDR      r1,[r0,#0]
000076  f0210140          BIC      r1,r1,#0x40
00007a  6001              STR      r1,[r0,#0]
                  |L11.124|
;;;2484       }
;;;2485   
;;;2486       /* SPI Frame error interrupt occurred ------------------------------------*/
;;;2487   
;;;2488       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00007c  6d60              LDR      r0,[r4,#0x54]
00007e  2800              CMP      r0,#0
000080  d02b              BEQ      |L11.218|
;;;2489       {
;;;2490         /* Disable all interrupts */
;;;2491         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
000082  6820              LDR      r0,[r4,#0]
000084  6841              LDR      r1,[r0,#4]
000086  f02101e0          BIC      r1,r1,#0xe0
00008a  6041              STR      r1,[r0,#4]
;;;2492   
;;;2493         hspi->State = HAL_SPI_STATE_READY;
00008c  2001              MOVS     r0,#1
00008e  f8840051          STRB     r0,[r4,#0x51]
;;;2494         /* Disable the SPI DMA requests if enabled */
;;;2495         if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
000092  f0020002          AND      r0,r2,#2
000096  f0020101          AND      r1,r2,#1
00009a  4308              ORRS     r0,r0,r1
00009c  d022              BEQ      |L11.228|
;;;2496         {
;;;2497           CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
00009e  6820              LDR      r0,[r4,#0]
0000a0  6841              LDR      r1,[r0,#4]
0000a2  f0210103          BIC      r1,r1,#3
0000a6  6041              STR      r1,[r0,#4]
;;;2498   
;;;2499           /* Abort the SPI DMA Rx channel */
;;;2500           if (hspi->hdmarx != NULL)
;;;2501           {
;;;2502             /* Set the SPI DMA Abort callback :
;;;2503             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2504             hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
0000a8  4d10              LDR      r5,|L11.236|
0000aa  6ce0              LDR      r0,[r4,#0x4c]         ;2500
0000ac  b140              CBZ      r0,|L11.192|
0000ae  6345              STR      r5,[r0,#0x34]
;;;2505             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
0000b0  6ce0              LDR      r0,[r4,#0x4c]
0000b2  f7fffffe          BL       HAL_DMA_Abort_IT
0000b6  b118              CBZ      r0,|L11.192|
;;;2506             {
;;;2507               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000b8  6d60              LDR      r0,[r4,#0x54]
0000ba  f0400040          ORR      r0,r0,#0x40
0000be  6560              STR      r0,[r4,#0x54]
                  |L11.192|
;;;2508             }
;;;2509           }
;;;2510           /* Abort the SPI DMA Tx channel */
;;;2511           if (hspi->hdmatx != NULL)
0000c0  6ca0              LDR      r0,[r4,#0x48]
0000c2  2800              CMP      r0,#0
0000c4  d009              BEQ      |L11.218|
;;;2512           {
;;;2513             /* Set the SPI DMA Abort callback :
;;;2514             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2515             hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
0000c6  6345              STR      r5,[r0,#0x34]
;;;2516             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
0000c8  6ca0              LDR      r0,[r4,#0x48]
0000ca  f7fffffe          BL       HAL_DMA_Abort_IT
0000ce  2800              CMP      r0,#0
0000d0  d003              BEQ      |L11.218|
;;;2517             {
;;;2518               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000d2  6d60              LDR      r0,[r4,#0x54]
0000d4  f0400040          ORR      r0,r0,#0x40
0000d8  6560              STR      r0,[r4,#0x54]
                  |L11.218|
;;;2519             }
;;;2520           }
;;;2521         }
;;;2522         else
;;;2523         {
;;;2524           /* Call user error callback */
;;;2525   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2526           hspi->ErrorCallback(hspi);
;;;2527   #else
;;;2528           HAL_SPI_ErrorCallback(hspi);
;;;2529   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2530         }
;;;2531       }
;;;2532       return;
;;;2533     }
;;;2534   }
0000da  bd38              POP      {r3-r5,pc}
                  |L11.220|
0000dc  68c1              LDR      r1,[r0,#0xc]          ;2474
0000de  6880              LDR      r0,[r0,#8]            ;2474
0000e0  9000              STR      r0,[sp,#0]            ;2474
0000e2  bd38              POP      {r3-r5,pc}
                  |L11.228|
0000e4  4620              MOV      r0,r4                 ;2528
0000e6  f7fffffe          BL       HAL_SPI_ErrorCallback
0000ea  bd38              POP      {r3-r5,pc}
;;;2535   
                          ENDP

                  |L11.236|
                          DCD      SPI_DMAAbortOnError

                          AREA ||i.HAL_SPI_Init||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Init PROC
;;;334      */
;;;335    HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;336    {
;;;337      /* Check the SPI handle allocation */
;;;338      if (hspi == NULL)
000002  2800              CMP      r0,#0
000004  d00b              BEQ      |L12.30|
;;;339      {
;;;340        return HAL_ERROR;
;;;341      }
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;345      assert_param(IS_SPI_MODE(hspi->Init.Mode));
;;;346      assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
;;;347      assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
;;;348      assert_param(IS_SPI_NSS(hspi->Init.NSS));
;;;349      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;350      assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
;;;351      /* TI mode is not supported on this device.
;;;352         TIMode parameter is mandatory equal to SPI_TIMODE_DISABLE */
;;;353      assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
;;;354      if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
000006  6a41              LDR      r1,[r0,#0x24]
000008  2200              MOVS     r2,#0
00000a  b151              CBZ      r1,|L12.34|
;;;355      {
;;;356        assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
;;;357        assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
;;;358    
;;;359        if (hspi->Init.Mode == SPI_MODE_MASTER)
;;;360        {
;;;361          assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;362        }
;;;363        else
;;;364        {
;;;365          /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
;;;366          hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
;;;367        }
;;;368      }
;;;369      else
;;;370      {
;;;371        assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;372    
;;;373        /* Force polarity and phase to TI protocaol requirements */
;;;374        hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
00000c  6102              STR      r2,[r0,#0x10]
;;;375        hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
00000e  6142              STR      r2,[r0,#0x14]
                  |L12.16|
;;;376      }
;;;377    #if (USE_SPI_CRC != 0U)
;;;378      assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
;;;379      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000010  6a81              LDR      r1,[r0,#0x28]
000012  f44f5300          MOV      r3,#0x2000
;;;380      {
;;;381        assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
;;;382      }
;;;383    #else
;;;384      hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
;;;385    #endif /* USE_SPI_CRC */
;;;386    
;;;387      if (hspi->State == HAL_SPI_STATE_RESET)
000016  f8901051          LDRB     r1,[r0,#0x51]
00001a  b141              CBZ      r1,|L12.46|
00001c  e009              B        |L12.50|
                  |L12.30|
00001e  2001              MOVS     r0,#1                 ;340
;;;388      {
;;;389        /* Allocate lock resource and initialize it */
;;;390        hspi->Lock = HAL_UNLOCKED;
;;;391    
;;;392    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;393        /* Init the SPI Callback settings */
;;;394        hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
;;;395        hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
;;;396        hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
;;;397        hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
;;;398        hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
;;;399        hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
;;;400        hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;401        hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;402    
;;;403        if (hspi->MspInitCallback == NULL)
;;;404        {
;;;405          hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
;;;406        }
;;;407    
;;;408        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;409        hspi->MspInitCallback(hspi);
;;;410    #else
;;;411        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;412        //HAL_SPI_MspInit(hspi);
;;;413    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;414      }
;;;415    
;;;416      hspi->State = HAL_SPI_STATE_BUSY;
;;;417    
;;;418      /* Disable the selected SPI peripheral */
;;;419      __HAL_SPI_DISABLE(hspi);
;;;420    
;;;421      /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
;;;422      /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
;;;423      Communication speed, First bit and CRC calculation state */
;;;424      WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
;;;425                                      (hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
;;;426                                      (hspi->Init.DataSize & SPI_CR1_DFF) |
;;;427                                      (hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
;;;428                                      (hspi->Init.CLKPhase & SPI_CR1_CPHA) |
;;;429                                      (hspi->Init.NSS & SPI_CR1_SSM) |
;;;430                                      (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
;;;431                                      (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
;;;432                                      (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));
;;;433    
;;;434      /* Configure : NSS management */
;;;435      WRITE_REG(hspi->Instance->CR2, ((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE));
;;;436    
;;;437    #if (USE_SPI_CRC != 0U)
;;;438      /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
;;;439      /* Configure : CRC Polynomial */
;;;440      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;441      {
;;;442        WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
;;;443      }
;;;444    #endif /* USE_SPI_CRC */
;;;445    
;;;446    #if defined(SPI_I2SCFGR_I2SMOD)
;;;447      /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
;;;448      CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
;;;449    #endif /* SPI_I2SCFGR_I2SMOD */
;;;450    
;;;451      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;452      hspi->State     = HAL_SPI_STATE_READY;
;;;453    
;;;454      return HAL_OK;
;;;455    }
000020  bd10              POP      {r4,pc}
                  |L12.34|
000022  6841              LDR      r1,[r0,#4]            ;359
000024  f5b17f82          CMP      r1,#0x104             ;359
000028  d0f2              BEQ      |L12.16|
00002a  61c2              STR      r2,[r0,#0x1c]         ;366
00002c  e7f0              B        |L12.16|
                  |L12.46|
00002e  f8802050          STRB     r2,[r0,#0x50]         ;390
                  |L12.50|
000032  2102              MOVS     r1,#2                 ;416
000034  f8801051          STRB     r1,[r0,#0x51]         ;416
000038  6801              LDR      r1,[r0,#0]            ;419
00003a  680c              LDR      r4,[r1,#0]            ;419
00003c  f0240440          BIC      r4,r4,#0x40           ;419
000040  600c              STR      r4,[r1,#0]            ;419
000042  8881              LDRH     r1,[r0,#4]            ;424
000044  8904              LDRH     r4,[r0,#8]            ;424
000046  f4017182          AND      r1,r1,#0x104          ;424
00004a  f4044404          AND      r4,r4,#0x8400         ;424
00004e  4321              ORRS     r1,r1,r4              ;424
000050  8984              LDRH     r4,[r0,#0xc]          ;424
000052  f4046400          AND      r4,r4,#0x800          ;424
000056  4321              ORRS     r1,r1,r4              ;424
000058  7c04              LDRB     r4,[r0,#0x10]         ;424
00005a  f0040402          AND      r4,r4,#2              ;424
00005e  4321              ORRS     r1,r1,r4              ;424
000060  7d04              LDRB     r4,[r0,#0x14]         ;424
000062  f0040401          AND      r4,r4,#1              ;424
000066  4321              ORRS     r1,r1,r4              ;424
000068  8b04              LDRH     r4,[r0,#0x18]         ;424
00006a  f4047400          AND      r4,r4,#0x200          ;424
00006e  4321              ORRS     r1,r1,r4              ;424
000070  7f04              LDRB     r4,[r0,#0x1c]         ;424
000072  f0040438          AND      r4,r4,#0x38           ;424
000076  4321              ORRS     r1,r1,r4              ;424
000078  f8904020          LDRB     r4,[r0,#0x20]         ;424
00007c  f0040480          AND      r4,r4,#0x80           ;424
000080  4321              ORRS     r1,r1,r4              ;424
000082  8d04              LDRH     r4,[r0,#0x28]         ;424
000084  f4045400          AND      r4,r4,#0x2000         ;424
000088  4321              ORRS     r1,r1,r4              ;424
00008a  6804              LDR      r4,[r0,#0]            ;424
00008c  6021              STR      r1,[r4,#0]            ;424
00008e  6981              LDR      r1,[r0,#0x18]         ;435
000090  2404              MOVS     r4,#4                 ;435
000092  ea044111          AND      r1,r4,r1,LSR #16      ;435
000096  6804              LDR      r4,[r0,#0]            ;435
000098  6061              STR      r1,[r4,#4]            ;435
00009a  6a81              LDR      r1,[r0,#0x28]         ;440
00009c  4299              CMP      r1,r3                 ;440
00009e  d103              BNE      |L12.168|
0000a0  8d81              LDRH     r1,[r0,#0x2c]         ;442
0000a2  6803              LDR      r3,[r0,#0]            ;442
0000a4  b289              UXTH     r1,r1                 ;442
0000a6  6119              STR      r1,[r3,#0x10]         ;442
                  |L12.168|
0000a8  6801              LDR      r1,[r0,#0]            ;448
0000aa  69cb              LDR      r3,[r1,#0x1c]         ;448
0000ac  f4236300          BIC      r3,r3,#0x800          ;448
0000b0  61cb              STR      r3,[r1,#0x1c]         ;448
0000b2  6542              STR      r2,[r0,#0x54]         ;451
0000b4  2101              MOVS     r1,#1                 ;452
0000b6  f8801051          STRB     r1,[r0,#0x51]         ;452
0000ba  2000              MOVS     r0,#0                 ;454
0000bc  bd10              POP      {r4,pc}
;;;456    
                          ENDP


                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspDeInit PROC
;;;522      */
;;;523    __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;524    {
;;;525      /* Prevent unused argument(s) compilation warning */
;;;526      UNUSED(hspi);
;;;527    
;;;528      /* NOTE : This function should not be modified, when the callback is needed,
;;;529                the HAL_SPI_MspDeInit should be implemented in the user file
;;;530       */
;;;531    }
;;;532    
                          ENDP


                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspInit PROC
;;;506      */
;;;507    __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;508    {
;;;509      /* Prevent unused argument(s) compilation warning */
;;;510      UNUSED(hspi);
;;;511    
;;;512      /* NOTE : This function should not be modified, when the callback is needed,
;;;513                the HAL_SPI_MspInit should be implemented in the user file
;;;514       */
;;;515    }
;;;516    
                          ENDP


                          AREA ||i.HAL_SPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Receive PROC
;;;960      */
;;;961    HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;962    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
;;;963    #if (USE_SPI_CRC != 0U)
;;;964      __IO uint32_t tmpreg = 0U;
00000c  2700              MOVS     r7,#0
00000e  9701              STR      r7,[sp,#4]
;;;965    #endif /* USE_SPI_CRC */
;;;966      uint32_t tickstart;
;;;967    
;;;968      if (hspi->State != HAL_SPI_STATE_READY)
000010  f8940051          LDRB     r0,[r4,#0x51]
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L15.30|
;;;969      {
;;;970        return HAL_BUSY;
000018  2002              MOVS     r0,#2
                  |L15.26|
;;;971      }
;;;972    
;;;973      if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
;;;974      {
;;;975        hspi->State = HAL_SPI_STATE_BUSY_RX;
;;;976        /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;977        return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
;;;978      }
;;;979    
;;;980      /* Init tickstart for timeout management*/
;;;981      tickstart = HAL_GetTick();
;;;982    
;;;983      if ((pData == NULL) || (Size == 0U))
;;;984      {
;;;985        return HAL_ERROR;
;;;986      }
;;;987    
;;;988      /* Process Locked */
;;;989      __HAL_LOCK(hspi);
;;;990    
;;;991      /* Set the transaction information */
;;;992      hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;993      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;994      hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;995      hspi->RxXferSize  = Size;
;;;996      hspi->RxXferCount = Size;
;;;997    
;;;998      /*Init field not used in handle to zero */
;;;999      hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1000     hspi->TxXferSize  = 0U;
;;;1001     hspi->TxXferCount = 0U;
;;;1002     hspi->RxISR       = NULL;
;;;1003     hspi->TxISR       = NULL;
;;;1004   
;;;1005   #if (USE_SPI_CRC != 0U)
;;;1006     /* Reset CRC Calculation */
;;;1007     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1008     {
;;;1009       SPI_RESET_CRC(hspi);
;;;1010       /* this is done to handle the CRCNEXT before the latest data */
;;;1011       hspi->RxXferCount--;
;;;1012     }
;;;1013   #endif /* USE_SPI_CRC */
;;;1014   
;;;1015     /* Configure communication direction: 1Line */
;;;1016     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1017     {
;;;1018       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1019       __HAL_SPI_DISABLE(hspi);
;;;1020       SPI_1LINE_RX(hspi);
;;;1021     }
;;;1022   
;;;1023     /* Check if the SPI is already enabled */
;;;1024     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1025     {
;;;1026       /* Enable SPI peripheral */
;;;1027       __HAL_SPI_ENABLE(hspi);
;;;1028     }
;;;1029   
;;;1030     /* Receive data in 8 Bit mode */
;;;1031     if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
;;;1032     {
;;;1033       /* Transfer loop */
;;;1034       while (hspi->RxXferCount > 0U)
;;;1035       {
;;;1036         /* Check the RXNE flag */
;;;1037         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1038         {
;;;1039           /* read the received data */
;;;1040           (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1041           hspi->pRxBuffPtr += sizeof(uint8_t);
;;;1042           hspi->RxXferCount--;
;;;1043         }
;;;1044         else
;;;1045         {
;;;1046           /* Timeout management */
;;;1047           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1048           {
;;;1049             hspi->State = HAL_SPI_STATE_READY;
;;;1050             __HAL_UNLOCK(hspi);
;;;1051             return HAL_TIMEOUT;
;;;1052           }
;;;1053         }
;;;1054       }
;;;1055     }
;;;1056     else
;;;1057     {
;;;1058       /* Transfer loop */
;;;1059       while (hspi->RxXferCount > 0U)
;;;1060       {
;;;1061         /* Check the RXNE flag */
;;;1062         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1063         {
;;;1064           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1065           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1066           hspi->RxXferCount--;
;;;1067         }
;;;1068         else
;;;1069         {
;;;1070           /* Timeout management */
;;;1071           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1072           {
;;;1073             hspi->State = HAL_SPI_STATE_READY;
;;;1074             __HAL_UNLOCK(hspi);
;;;1075             return HAL_TIMEOUT;
;;;1076           }
;;;1077         }
;;;1078       }
;;;1079     }
;;;1080   
;;;1081   #if (USE_SPI_CRC != 0U)
;;;1082     /* Handle the CRC Transmission */
;;;1083     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1084     {
;;;1085       /* freeze the CRC before the latest data */
;;;1086       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1087   
;;;1088       /* Check if CRCNEXT is well reset by hardware */
;;;1089       if (READ_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT))
;;;1090       {
;;;1091         /* Workaround to force CRCNEXT bit to zero in case of CRCNEXT is not reset automatically by hardware */
;;;1092         CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1093       }
;;;1094       /* Read the latest data */
;;;1095       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1096       {
;;;1097         /* the latest data has not been received */
;;;1098         __HAL_UNLOCK(hspi);
;;;1099         return HAL_TIMEOUT;
;;;1100       }
;;;1101   
;;;1102       /* Receive last data in 16 Bit mode */
;;;1103       if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1104       {
;;;1105         *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1106       }
;;;1107       /* Receive last data in 8 Bit mode */
;;;1108       else
;;;1109       {
;;;1110         (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1111       }
;;;1112   
;;;1113       /* Wait the CRC data */
;;;1114       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1115       {
;;;1116         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1117         hspi->State = HAL_SPI_STATE_READY;
;;;1118         __HAL_UNLOCK(hspi);
;;;1119         return HAL_TIMEOUT;
;;;1120       }
;;;1121   
;;;1122       /* Read CRC to Flush DR and RXNE flag */
;;;1123       tmpreg = READ_REG(hspi->Instance->DR);
;;;1124       /* To avoid GCC warning */
;;;1125       UNUSED(tmpreg);
;;;1126     }
;;;1127   #endif /* USE_SPI_CRC */
;;;1128   
;;;1129     /* Check the end of the transaction */
;;;1130     if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1131     {
;;;1132       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1133     }
;;;1134   
;;;1135   #if (USE_SPI_CRC != 0U)
;;;1136     /* Check if CRC error occurred */
;;;1137     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;1138     {
;;;1139       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;1140       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;1141       {
;;;1142         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1143   
;;;1144         /* Reset CRC Calculation */
;;;1145         SPI_RESET_CRC(hspi);
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1150       }
;;;1151     }
;;;1152   #endif /* USE_SPI_CRC */
;;;1153   
;;;1154     hspi->State = HAL_SPI_STATE_READY;
;;;1155     /* Unlock the process */
;;;1156     __HAL_UNLOCK(hspi);
;;;1157     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;1158     {
;;;1159       return HAL_ERROR;
;;;1160     }
;;;1161     else
;;;1162     {
;;;1163       return HAL_OK;
;;;1164     }
;;;1165   }
00001a  e8bd9ffc          POP      {r2-r12,pc}
                  |L15.30|
00001e  6860              LDR      r0,[r4,#4]            ;973
000020  f04f0b04          MOV      r11,#4                ;975
000024  f5b07f82          CMP      r0,#0x104             ;973
000028  d101              BNE      |L15.46|
00002a  68a0              LDR      r0,[r4,#8]            ;973
00002c  b3a8              CBZ      r0,|L15.154|
                  |L15.46|
00002e  f7fffffe          BL       HAL_GetTick
000032  4606              MOV      r6,r0                 ;981
000034  f1ba0f00          CMP      r10,#0                ;983
000038  d03a              BEQ      |L15.176|
00003a  f1b90f00          CMP      r9,#0                 ;983
00003e  d037              BEQ      |L15.176|
000040  f8940050          LDRB     r0,[r4,#0x50]         ;989
000044  2801              CMP      r0,#1                 ;989
000046  d035              BEQ      |L15.180|
000048  f04f0801          MOV      r8,#1                 ;989
00004c  f8848050          STRB     r8,[r4,#0x50]         ;989
000050  f884b051          STRB     r11,[r4,#0x51]        ;992
000054  6567              STR      r7,[r4,#0x54]         ;993
000056  f8c4a038          STR      r10,[r4,#0x38]        ;994
00005a  f8a4903c          STRH     r9,[r4,#0x3c]         ;995
00005e  f8a4903e          STRH     r9,[r4,#0x3e]         ;996
000062  6327              STR      r7,[r4,#0x30]         ;999
000064  86a7              STRH     r7,[r4,#0x34]         ;1000
000066  86e7              STRH     r7,[r4,#0x36]         ;1001
000068  6427              STR      r7,[r4,#0x40]         ;1002
00006a  6467              STR      r7,[r4,#0x44]         ;1003
00006c  6aa0              LDR      r0,[r4,#0x28]         ;1007
00006e  f44f5900          MOV      r9,#0x2000            ;1007
000072  4548              CMP      r0,r9                 ;1007
000074  d10c              BNE      |L15.144|
000076  6820              LDR      r0,[r4,#0]            ;1009
000078  6801              LDR      r1,[r0,#0]            ;1009
00007a  f4215100          BIC      r1,r1,#0x2000         ;1009
00007e  6001              STR      r1,[r0,#0]            ;1009
000080  6820              LDR      r0,[r4,#0]            ;1009
000082  6801              LDR      r1,[r0,#0]            ;1009
000084  f4415100          ORR      r1,r1,#0x2000         ;1009
000088  6001              STR      r1,[r0,#0]            ;1009
00008a  8fe0              LDRH     r0,[r4,#0x3e]         ;1011
00008c  1e40              SUBS     r0,r0,#1              ;1011
00008e  87e0              STRH     r0,[r4,#0x3e]         ;1011
                  |L15.144|
000090  68a0              LDR      r0,[r4,#8]            ;1016
000092  f5b04f00          CMP      r0,#0x8000            ;1016
000096  d00f              BEQ      |L15.184|
000098  e018              B        |L15.204|
                  |L15.154|
00009a  e7ff              B        |L15.156|
                  |L15.156|
00009c  f884b051          STRB     r11,[r4,#0x51]        ;975
0000a0  464b              MOV      r3,r9                 ;977
0000a2  4652              MOV      r2,r10                ;977
0000a4  4651              MOV      r1,r10                ;977
0000a6  4620              MOV      r0,r4                 ;977
0000a8  9500              STR      r5,[sp,#0]            ;977
0000aa  f7fffffe          BL       HAL_SPI_TransmitReceive
0000ae  e7b4              B        |L15.26|
                  |L15.176|
0000b0  2001              MOVS     r0,#1                 ;985
0000b2  e7b2              B        |L15.26|
                  |L15.180|
0000b4  2002              MOVS     r0,#2                 ;989
0000b6  e7b0              B        |L15.26|
                  |L15.184|
0000b8  6820              LDR      r0,[r4,#0]            ;1019
0000ba  6801              LDR      r1,[r0,#0]            ;1019
0000bc  f0210140          BIC      r1,r1,#0x40           ;1019
0000c0  6001              STR      r1,[r0,#0]            ;1019
0000c2  6820              LDR      r0,[r4,#0]            ;1020
0000c4  6801              LDR      r1,[r0,#0]            ;1020
0000c6  f4214180          BIC      r1,r1,#0x4000         ;1020
0000ca  6001              STR      r1,[r0,#0]            ;1020
                  |L15.204|
0000cc  6820              LDR      r0,[r4,#0]            ;1024
0000ce  6801              LDR      r1,[r0,#0]            ;1024
0000d0  0649              LSLS     r1,r1,#25             ;1024
0000d2  d403              BMI      |L15.220|
0000d4  6801              LDR      r1,[r0,#0]            ;1027
0000d6  f0410140          ORR      r1,r1,#0x40           ;1027
0000da  6001              STR      r1,[r0,#0]            ;1027
                  |L15.220|
0000dc  68e0              LDR      r0,[r4,#0xc]          ;1031
0000de  b1b0              CBZ      r0,|L15.270|
0000e0  e035              B        |L15.334|
                  |L15.226|
0000e2  6820              LDR      r0,[r4,#0]            ;1037
0000e4  6881              LDR      r1,[r0,#8]            ;1037
0000e6  07c9              LSLS     r1,r1,#31             ;1037
0000e8  d009              BEQ      |L15.254|
0000ea  7b00              LDRB     r0,[r0,#0xc]          ;1040
0000ec  6ba1              LDR      r1,[r4,#0x38]         ;1040
0000ee  7008              STRB     r0,[r1,#0]            ;1040
0000f0  6ba0              LDR      r0,[r4,#0x38]         ;1041
0000f2  1c40              ADDS     r0,r0,#1              ;1041
0000f4  63a0              STR      r0,[r4,#0x38]         ;1041
0000f6  8fe0              LDRH     r0,[r4,#0x3e]         ;1042
0000f8  1e40              SUBS     r0,r0,#1              ;1042
0000fa  87e0              STRH     r0,[r4,#0x3e]         ;1042
0000fc  e007              B        |L15.270|
                  |L15.254|
0000fe  f7fffffe          BL       HAL_GetTick
000102  1b80              SUBS     r0,r0,r6              ;1047
000104  42a8              CMP      r0,r5                 ;1047
000106  d301              BCC      |L15.268|
000108  1c68              ADDS     r0,r5,#1              ;1047
00010a  d104              BNE      |L15.278|
                  |L15.268|
00010c  b11d              CBZ      r5,|L15.278|
                  |L15.270|
00010e  8fe0              LDRH     r0,[r4,#0x3e]         ;1034
000110  2800              CMP      r0,#0                 ;1034
000112  d1e6              BNE      |L15.226|
000114  e01e              B        |L15.340|
                  |L15.278|
000116  f8848051          STRB     r8,[r4,#0x51]         ;1049
00011a  f8847050          STRB     r7,[r4,#0x50]         ;1050
00011e  2003              MOVS     r0,#3                 ;1051
000120  e77b              B        |L15.26|
                  |L15.290|
000122  6820              LDR      r0,[r4,#0]            ;1062
000124  6881              LDR      r1,[r0,#8]            ;1062
000126  07c9              LSLS     r1,r1,#31             ;1062
000128  d009              BEQ      |L15.318|
00012a  68c0              LDR      r0,[r0,#0xc]          ;1064
00012c  6ba1              LDR      r1,[r4,#0x38]         ;1064
00012e  8008              STRH     r0,[r1,#0]            ;1064
000130  6ba0              LDR      r0,[r4,#0x38]         ;1065
000132  1c80              ADDS     r0,r0,#2              ;1065
000134  63a0              STR      r0,[r4,#0x38]         ;1065
000136  8fe0              LDRH     r0,[r4,#0x3e]         ;1066
000138  1e40              SUBS     r0,r0,#1              ;1066
00013a  87e0              STRH     r0,[r4,#0x3e]         ;1066
00013c  e007              B        |L15.334|
                  |L15.318|
00013e  f7fffffe          BL       HAL_GetTick
000142  1b80              SUBS     r0,r0,r6              ;1071
000144  42a8              CMP      r0,r5                 ;1071
000146  d301              BCC      |L15.332|
000148  1c68              ADDS     r0,r5,#1              ;1071
00014a  d11f              BNE      |L15.396|
                  |L15.332|
00014c  b1f5              CBZ      r5,|L15.396|
                  |L15.334|
00014e  8fe0              LDRH     r0,[r4,#0x3e]         ;1059
000150  2800              CMP      r0,#0                 ;1059
000152  d1e6              BNE      |L15.290|
                  |L15.340|
000154  6aa0              LDR      r0,[r4,#0x28]         ;1083
000156  4548              CMP      r0,r9                 ;1083
000158  d140              BNE      |L15.476|
00015a  6820              LDR      r0,[r4,#0]            ;1086
00015c  6801              LDR      r1,[r0,#0]            ;1086
00015e  f4415180          ORR      r1,r1,#0x1000         ;1086
000162  6001              STR      r1,[r0,#0]            ;1086
000164  6820              LDR      r0,[r4,#0]            ;1089
000166  6801              LDR      r1,[r0,#0]            ;1089
000168  04c9              LSLS     r1,r1,#19             ;1089
00016a  d503              BPL      |L15.372|
00016c  6801              LDR      r1,[r0,#0]            ;1092
00016e  f4215180          BIC      r1,r1,#0x1000         ;1092
000172  6001              STR      r1,[r0,#0]            ;1092
                  |L15.372|
000174  2201              MOVS     r2,#1                 ;1095
000176  462b              MOV      r3,r5                 ;1095
000178  4611              MOV      r1,r2                 ;1095
00017a  4620              MOV      r0,r4                 ;1095
00017c  9600              STR      r6,[sp,#0]            ;1095
00017e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000182  b148              CBZ      r0,|L15.408|
000184  f8847050          STRB     r7,[r4,#0x50]         ;1098
000188  2003              MOVS     r0,#3                 ;1099
00018a  e746              B        |L15.26|
                  |L15.396|
00018c  f8848051          STRB     r8,[r4,#0x51]         ;1073
000190  f8847050          STRB     r7,[r4,#0x50]         ;1074
000194  2003              MOVS     r0,#3                 ;1075
000196  e740              B        |L15.26|
                  |L15.408|
000198  68e0              LDR      r0,[r4,#0xc]          ;1103
00019a  f5b06f00          CMP      r0,#0x800             ;1103
00019e  d015              BEQ      |L15.460|
0001a0  6820              LDR      r0,[r4,#0]            ;1110
0001a2  7b00              LDRB     r0,[r0,#0xc]          ;1110
0001a4  6ba1              LDR      r1,[r4,#0x38]         ;1110
0001a6  7008              STRB     r0,[r1,#0]            ;1110
                  |L15.424|
0001a8  2201              MOVS     r2,#1                 ;1114
0001aa  462b              MOV      r3,r5                 ;1114
0001ac  4611              MOV      r1,r2                 ;1114
0001ae  4620              MOV      r0,r4                 ;1114
0001b0  9600              STR      r6,[sp,#0]            ;1114
0001b2  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
0001b6  b170              CBZ      r0,|L15.470|
0001b8  6d60              LDR      r0,[r4,#0x54]         ;1116
0001ba  f0400002          ORR      r0,r0,#2              ;1116
0001be  6560              STR      r0,[r4,#0x54]         ;1116
0001c0  f8848051          STRB     r8,[r4,#0x51]         ;1117
0001c4  f8847050          STRB     r7,[r4,#0x50]         ;1118
0001c8  2003              MOVS     r0,#3                 ;1119
0001ca  e726              B        |L15.26|
                  |L15.460|
0001cc  6820              LDR      r0,[r4,#0]            ;1105
0001ce  68c0              LDR      r0,[r0,#0xc]          ;1105
0001d0  6ba1              LDR      r1,[r4,#0x38]         ;1105
0001d2  8008              STRH     r0,[r1,#0]            ;1105
0001d4  e7e8              B        |L15.424|
                  |L15.470|
0001d6  6820              LDR      r0,[r4,#0]            ;1123
0001d8  68c0              LDR      r0,[r0,#0xc]          ;1123
0001da  9001              STR      r0,[sp,#4]            ;1123
                  |L15.476|
0001dc  4632              MOV      r2,r6                 ;1130
0001de  4629              MOV      r1,r5                 ;1130
0001e0  4620              MOV      r0,r4                 ;1130
0001e2  f7fffffe          BL       SPI_EndRxTransaction
0001e6  b108              CBZ      r0,|L15.492|
0001e8  2020              MOVS     r0,#0x20              ;1132
0001ea  6560              STR      r0,[r4,#0x54]         ;1132
                  |L15.492|
0001ec  6820              LDR      r0,[r4,#0]            ;1137
0001ee  6880              LDR      r0,[r0,#8]            ;1137
0001f0  43c0              MVNS     r0,r0                 ;1137
0001f2  06c0              LSLS     r0,r0,#27             ;1137
0001f4  d408              BMI      |L15.520|
0001f6  4620              MOV      r0,r4                 ;1140
0001f8  f7fffffe          BL       SPI_ISCRCErrorValid
0001fc  2801              CMP      r0,#1                 ;1140
0001fe  d00b              BEQ      |L15.536|
000200  6821              LDR      r1,[r4,#0]            ;1149
000202  f64f70ef          MOV      r0,#0xffef            ;1149
000206  6088              STR      r0,[r1,#8]            ;1149
                  |L15.520|
000208  f8848051          STRB     r8,[r4,#0x51]         ;1154
00020c  f8847050          STRB     r7,[r4,#0x50]         ;1156
000210  6d60              LDR      r0,[r4,#0x54]         ;1157
000212  b180              CBZ      r0,|L15.566|
000214  2001              MOVS     r0,#1                 ;1159
000216  e700              B        |L15.26|
                  |L15.536|
000218  6d60              LDR      r0,[r4,#0x54]         ;1142
00021a  f0400002          ORR      r0,r0,#2              ;1142
00021e  6560              STR      r0,[r4,#0x54]         ;1142
000220  6820              LDR      r0,[r4,#0]            ;1145
000222  6801              LDR      r1,[r0,#0]            ;1145
000224  f4215100          BIC      r1,r1,#0x2000         ;1145
000228  6001              STR      r1,[r0,#0]            ;1145
00022a  6820              LDR      r0,[r4,#0]            ;1145
00022c  6801              LDR      r1,[r0,#0]            ;1145
00022e  f4415100          ORR      r1,r1,#0x2000         ;1145
000232  6001              STR      r1,[r0,#0]            ;1145
000234  e7e8              B        |L15.520|
                  |L15.566|
000236  2000              MOVS     r0,#0                 ;1163
000238  e6ef              B        |L15.26|
;;;1166   
                          ENDP


                          AREA ||i.HAL_SPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_DMA PROC
;;;1800     */
;;;1801   HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1802   {
000002  4604              MOV      r4,r0
;;;1803     /* Check rx dma handle */
;;;1804     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1805   
;;;1806     if (hspi->State != HAL_SPI_STATE_READY)
000004  f8940051          LDRB     r0,[r4,#0x51]
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L16.16|
;;;1807     {
;;;1808       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1809     }
;;;1810   
;;;1811     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
;;;1812     {
;;;1813       hspi->State = HAL_SPI_STATE_BUSY_RX;
;;;1814   
;;;1815       /* Check tx dma handle */
;;;1816       assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1817   
;;;1818       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1819       return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
;;;1820     }
;;;1821   
;;;1822     if ((pData == NULL) || (Size == 0U))
;;;1823     {
;;;1824       return HAL_ERROR;
;;;1825     }
;;;1826   
;;;1827     /* Process Locked */
;;;1828     __HAL_LOCK(hspi);
;;;1829   
;;;1830     /* Set the transaction information */
;;;1831     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1832     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1833     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1834     hspi->RxXferSize  = Size;
;;;1835     hspi->RxXferCount = Size;
;;;1836   
;;;1837     /*Init field not used in handle to zero */
;;;1838     hspi->RxISR       = NULL;
;;;1839     hspi->TxISR       = NULL;
;;;1840     hspi->TxXferSize  = 0U;
;;;1841     hspi->TxXferCount = 0U;
;;;1842   
;;;1843     /* Configure communication direction : 1Line */
;;;1844     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1845     {
;;;1846       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1847       __HAL_SPI_DISABLE(hspi);
;;;1848       SPI_1LINE_RX(hspi);
;;;1849     }
;;;1850   
;;;1851   #if (USE_SPI_CRC != 0U)
;;;1852     /* Reset CRC Calculation */
;;;1853     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1854     {
;;;1855       SPI_RESET_CRC(hspi);
;;;1856     }
;;;1857   #endif /* USE_SPI_CRC */
;;;1858   
;;;1859     /* Set the SPI RxDMA Half transfer complete callback */
;;;1860     hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1861   
;;;1862     /* Set the SPI Rx DMA transfer complete callback */
;;;1863     hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
;;;1864   
;;;1865     /* Set the DMA error callback */
;;;1866     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1867   
;;;1868     /* Set the DMA AbortCpltCallback */
;;;1869     hspi->hdmarx->XferAbortCallback = NULL;
;;;1870   
;;;1871     /* Enable the Rx DMA Stream/Channel  */
;;;1872     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;1873                                    hspi->RxXferCount))
;;;1874     {
;;;1875       /* Update SPI error code */
;;;1876       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1877       /* Process Unlocked */
;;;1878       __HAL_UNLOCK(hspi);
;;;1879       return HAL_ERROR;
;;;1880     }
;;;1881   
;;;1882     /* Check if the SPI is already enabled */
;;;1883     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1884     {
;;;1885       /* Enable SPI peripheral */
;;;1886       __HAL_SPI_ENABLE(hspi);
;;;1887     }
;;;1888   
;;;1889     /* Process Unlocked */
;;;1890     __HAL_UNLOCK(hspi);
;;;1891   
;;;1892     /* Enable the SPI Error Interrupt Bit */
;;;1893     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1894   
;;;1895     /* Enable Rx DMA Request */
;;;1896     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1897   
;;;1898     return HAL_OK;
;;;1899   }
00000e  bd70              POP      {r4-r6,pc}
                  |L16.16|
000010  68a0              LDR      r0,[r4,#8]            ;1811
000012  2304              MOVS     r3,#4                 ;1813
000014  b918              CBNZ     r0,|L16.30|
000016  6865              LDR      r5,[r4,#4]            ;1811
000018  f5b57f82          CMP      r5,#0x104             ;1811
00001c  d017              BEQ      |L16.78|
                  |L16.30|
00001e  b1f9              CBZ      r1,|L16.96|
000020  b1f2              CBZ      r2,|L16.96|
000022  f8945050          LDRB     r5,[r4,#0x50]         ;1828
000026  2d01              CMP      r5,#1                 ;1828
000028  d01c              BEQ      |L16.100|
00002a  2501              MOVS     r5,#1                 ;1828
00002c  f8845050          STRB     r5,[r4,#0x50]         ;1828
000030  f8843051          STRB     r3,[r4,#0x51]         ;1831
000034  2500              MOVS     r5,#0                 ;1832
000036  6565              STR      r5,[r4,#0x54]         ;1832
000038  63a1              STR      r1,[r4,#0x38]         ;1833
00003a  87a2              STRH     r2,[r4,#0x3c]         ;1834
00003c  87e2              STRH     r2,[r4,#0x3e]         ;1835
00003e  6425              STR      r5,[r4,#0x40]         ;1838
000040  6465              STR      r5,[r4,#0x44]         ;1839
000042  86a5              STRH     r5,[r4,#0x34]         ;1840
000044  86e5              STRH     r5,[r4,#0x36]         ;1841
000046  f5b04f00          CMP      r0,#0x8000            ;1844
00004a  d00d              BEQ      |L16.104|
00004c  e016              B        |L16.124|
                  |L16.78|
00004e  f8843051          STRB     r3,[r4,#0x51]         ;1813
000052  4620              MOV      r0,r4                 ;1819
000054  e8bd4070          POP      {r4-r6,lr}            ;1819
000058  4613              MOV      r3,r2                 ;1819
00005a  460a              MOV      r2,r1                 ;1819
00005c  f7ffbffe          B.W      HAL_SPI_TransmitReceive_DMA
                  |L16.96|
000060  2001              MOVS     r0,#1                 ;1824
000062  bd70              POP      {r4-r6,pc}
                  |L16.100|
000064  2002              MOVS     r0,#2                 ;1828
000066  bd70              POP      {r4-r6,pc}
                  |L16.104|
000068  6820              LDR      r0,[r4,#0]            ;1847
00006a  6801              LDR      r1,[r0,#0]            ;1847
00006c  f0210140          BIC      r1,r1,#0x40           ;1847
000070  6001              STR      r1,[r0,#0]            ;1847
000072  6820              LDR      r0,[r4,#0]            ;1848
000074  6801              LDR      r1,[r0,#0]            ;1848
000076  f4214180          BIC      r1,r1,#0x4000         ;1848
00007a  6001              STR      r1,[r0,#0]            ;1848
                  |L16.124|
00007c  6aa0              LDR      r0,[r4,#0x28]         ;1853
00007e  f5b05f00          CMP      r0,#0x2000            ;1853
000082  d109              BNE      |L16.152|
000084  6820              LDR      r0,[r4,#0]            ;1855
000086  6801              LDR      r1,[r0,#0]            ;1855
000088  f4215100          BIC      r1,r1,#0x2000         ;1855
00008c  6001              STR      r1,[r0,#0]            ;1855
00008e  6820              LDR      r0,[r4,#0]            ;1855
000090  6801              LDR      r1,[r0,#0]            ;1855
000092  f4415100          ORR      r1,r1,#0x2000         ;1855
000096  6001              STR      r1,[r0,#0]            ;1855
                  |L16.152|
000098  6ce1              LDR      r1,[r4,#0x4c]         ;1860
00009a  4818              LDR      r0,|L16.252|
00009c  62c8              STR      r0,[r1,#0x2c]         ;1860
00009e  6ce1              LDR      r1,[r4,#0x4c]         ;1863
0000a0  4817              LDR      r0,|L16.256|
0000a2  6288              STR      r0,[r1,#0x28]         ;1863
0000a4  6ce1              LDR      r1,[r4,#0x4c]         ;1866
0000a6  4817              LDR      r0,|L16.260|
0000a8  6308              STR      r0,[r1,#0x30]         ;1866
0000aa  6ce0              LDR      r0,[r4,#0x4c]         ;1869
0000ac  6345              STR      r5,[r0,#0x34]         ;1869
0000ae  8fe3              LDRH     r3,[r4,#0x3e]         ;1872
0000b0  6821              LDR      r1,[r4,#0]            ;1872
0000b2  6ba2              LDR      r2,[r4,#0x38]         ;1872
0000b4  310c              ADDS     r1,r1,#0xc            ;1872
0000b6  6ce0              LDR      r0,[r4,#0x4c]         ;1872
0000b8  f7fffffe          BL       HAL_DMA_Start_IT
0000bc  b138              CBZ      r0,|L16.206|
0000be  6d60              LDR      r0,[r4,#0x54]         ;1876
0000c0  f0400010          ORR      r0,r0,#0x10           ;1876
0000c4  6560              STR      r0,[r4,#0x54]         ;1876
0000c6  f8845050          STRB     r5,[r4,#0x50]         ;1878
0000ca  2001              MOVS     r0,#1                 ;1879
0000cc  bd70              POP      {r4-r6,pc}
                  |L16.206|
0000ce  6820              LDR      r0,[r4,#0]            ;1883
0000d0  6801              LDR      r1,[r0,#0]            ;1883
0000d2  0649              LSLS     r1,r1,#25             ;1883
0000d4  d403              BMI      |L16.222|
0000d6  6801              LDR      r1,[r0,#0]            ;1886
0000d8  f0410140          ORR      r1,r1,#0x40           ;1886
0000dc  6001              STR      r1,[r0,#0]            ;1886
                  |L16.222|
0000de  f8845050          STRB     r5,[r4,#0x50]         ;1890
0000e2  6820              LDR      r0,[r4,#0]            ;1893
0000e4  6841              LDR      r1,[r0,#4]            ;1893
0000e6  f0410120          ORR      r1,r1,#0x20           ;1893
0000ea  6041              STR      r1,[r0,#4]            ;1893
0000ec  6820              LDR      r0,[r4,#0]            ;1896
0000ee  6841              LDR      r1,[r0,#4]            ;1896
0000f0  f0410101          ORR      r1,r1,#1              ;1896
0000f4  6041              STR      r1,[r0,#4]            ;1896
0000f6  2000              MOVS     r0,#0                 ;1898
0000f8  bd70              POP      {r4-r6,pc}
;;;1900   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L16.252|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L16.256|
                          DCD      SPI_DMAReceiveCplt
                  |L16.260|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_IT PROC
;;;1518     */
;;;1519   HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  b430              PUSH     {r4,r5}
;;;1520   {
;;;1521   
;;;1522     if (hspi->State != HAL_SPI_STATE_READY)
000002  f8903051          LDRB     r3,[r0,#0x51]
000006  2b01              CMP      r3,#1
000008  d002              BEQ      |L17.16|
;;;1523     {
;;;1524       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
                  |L17.12|
;;;1525     }
;;;1526   
;;;1527     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
;;;1528     {
;;;1529       hspi->State = HAL_SPI_STATE_BUSY_RX;
;;;1530       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1531       return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
;;;1532     }
;;;1533   
;;;1534   
;;;1535     if ((pData == NULL) || (Size == 0U))
;;;1536     {
;;;1537       return HAL_ERROR;
;;;1538     }
;;;1539   
;;;1540     /* Process Locked */
;;;1541     __HAL_LOCK(hspi);
;;;1542   
;;;1543     /* Set the transaction information */
;;;1544     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1545     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1546     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1547     hspi->RxXferSize  = Size;
;;;1548     hspi->RxXferCount = Size;
;;;1549   
;;;1550     /* Init field not used in handle to zero */
;;;1551     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1552     hspi->TxXferSize  = 0U;
;;;1553     hspi->TxXferCount = 0U;
;;;1554     hspi->TxISR       = NULL;
;;;1555   
;;;1556     /* Set the function for IT treatment */
;;;1557     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1558     {
;;;1559       hspi->RxISR = SPI_RxISR_16BIT;
;;;1560     }
;;;1561     else
;;;1562     {
;;;1563       hspi->RxISR = SPI_RxISR_8BIT;
;;;1564     }
;;;1565   
;;;1566     /* Configure communication direction : 1Line */
;;;1567     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1568     {
;;;1569       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1570       __HAL_SPI_DISABLE(hspi);
;;;1571       SPI_1LINE_RX(hspi);
;;;1572     }
;;;1573   
;;;1574   #if (USE_SPI_CRC != 0U)
;;;1575     /* Reset CRC Calculation */
;;;1576     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1577     {
;;;1578       SPI_RESET_CRC(hspi);
;;;1579     }
;;;1580   #endif /* USE_SPI_CRC */
;;;1581   
;;;1582     /* Note : The SPI must be enabled after unlocking current process
;;;1583               to avoid the risk of SPI interrupt handle execution before current
;;;1584               process unlock */
;;;1585   
;;;1586     /* Check if the SPI is already enabled */
;;;1587     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1588     {
;;;1589       /* Enable SPI peripheral */
;;;1590       __HAL_SPI_ENABLE(hspi);
;;;1591     }
;;;1592   
;;;1593     /* Process Unlocked */
;;;1594     __HAL_UNLOCK(hspi);
;;;1595     /* Enable RXNE and ERR interrupt */
;;;1596     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;1597   
;;;1598     return HAL_OK;
;;;1599   }
00000c  bc30              POP      {r4,r5}
00000e  4770              BX       lr
                  |L17.16|
000010  6884              LDR      r4,[r0,#8]            ;1527
000012  2304              MOVS     r3,#4                 ;1529
000014  b91c              CBNZ     r4,|L17.30|
000016  6845              LDR      r5,[r0,#4]            ;1527
000018  f5b57f82          CMP      r5,#0x104             ;1527
00001c  d018              BEQ      |L17.80|
                  |L17.30|
00001e  b1f1              CBZ      r1,|L17.94|
000020  b1ea              CBZ      r2,|L17.94|
000022  f8905050          LDRB     r5,[r0,#0x50]         ;1541
000026  2d01              CMP      r5,#1                 ;1541
000028  d01b              BEQ      |L17.98|
00002a  2501              MOVS     r5,#1                 ;1541
00002c  f8805050          STRB     r5,[r0,#0x50]         ;1541
000030  f8803051          STRB     r3,[r0,#0x51]         ;1544
000034  2300              MOVS     r3,#0                 ;1545
000036  6543              STR      r3,[r0,#0x54]         ;1545
000038  6381              STR      r1,[r0,#0x38]         ;1546
00003a  8782              STRH     r2,[r0,#0x3c]         ;1547
00003c  87c2              STRH     r2,[r0,#0x3e]         ;1548
00003e  6303              STR      r3,[r0,#0x30]         ;1551
000040  8683              STRH     r3,[r0,#0x34]         ;1552
000042  86c3              STRH     r3,[r0,#0x36]         ;1553
000044  6443              STR      r3,[r0,#0x44]         ;1554
000046  68c1              LDR      r1,[r0,#0xc]          ;1541
000048  b169              CBZ      r1,|L17.102|
00004a  491e              LDR      r1,|L17.196|
00004c  6401              STR      r1,[r0,#0x40]         ;1559
00004e  e00c              B        |L17.106|
                  |L17.80|
000050  f8803051          STRB     r3,[r0,#0x51]         ;1529
000054  4613              MOV      r3,r2                 ;1531
000056  bc30              POP      {r4,r5}               ;1531
000058  460a              MOV      r2,r1                 ;1531
00005a  f7ffbffe          B.W      HAL_SPI_TransmitReceive_IT
                  |L17.94|
00005e  2001              MOVS     r0,#1                 ;1537
000060  e7d4              B        |L17.12|
                  |L17.98|
000062  2002              MOVS     r0,#2                 ;1541
000064  e7d2              B        |L17.12|
                  |L17.102|
000066  4918              LDR      r1,|L17.200|
000068  6401              STR      r1,[r0,#0x40]         ;1563
                  |L17.106|
00006a  f5b44f00          CMP      r4,#0x8000            ;1567
00006e  d109              BNE      |L17.132|
000070  6801              LDR      r1,[r0,#0]            ;1570
000072  680a              LDR      r2,[r1,#0]            ;1570
000074  f0220240          BIC      r2,r2,#0x40           ;1570
000078  600a              STR      r2,[r1,#0]            ;1570
00007a  6801              LDR      r1,[r0,#0]            ;1571
00007c  680a              LDR      r2,[r1,#0]            ;1571
00007e  f4224280          BIC      r2,r2,#0x4000         ;1571
000082  600a              STR      r2,[r1,#0]            ;1571
                  |L17.132|
000084  6a81              LDR      r1,[r0,#0x28]         ;1576
000086  f5b15f00          CMP      r1,#0x2000            ;1576
00008a  d109              BNE      |L17.160|
00008c  6801              LDR      r1,[r0,#0]            ;1578
00008e  680a              LDR      r2,[r1,#0]            ;1578
000090  f4225200          BIC      r2,r2,#0x2000         ;1578
000094  600a              STR      r2,[r1,#0]            ;1578
000096  6801              LDR      r1,[r0,#0]            ;1578
000098  680a              LDR      r2,[r1,#0]            ;1578
00009a  f4425200          ORR      r2,r2,#0x2000         ;1578
00009e  600a              STR      r2,[r1,#0]            ;1578
                  |L17.160|
0000a0  6801              LDR      r1,[r0,#0]            ;1587
0000a2  680a              LDR      r2,[r1,#0]            ;1587
0000a4  0652              LSLS     r2,r2,#25             ;1587
0000a6  d403              BMI      |L17.176|
0000a8  680a              LDR      r2,[r1,#0]            ;1590
0000aa  f0420240          ORR      r2,r2,#0x40           ;1590
0000ae  600a              STR      r2,[r1,#0]            ;1590
                  |L17.176|
0000b0  f8803050          STRB     r3,[r0,#0x50]         ;1594
0000b4  6800              LDR      r0,[r0,#0]            ;1596
0000b6  6841              LDR      r1,[r0,#4]            ;1596
0000b8  f0410160          ORR      r1,r1,#0x60           ;1596
0000bc  6041              STR      r1,[r0,#4]            ;1596
0000be  2000              MOVS     r0,#0                 ;1598
0000c0  e7a4              B        |L17.12|
;;;1600   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L17.196|
                          DCD      SPI_RxISR_16BIT
                  |L17.200|
                          DCD      SPI_RxISR_8BIT

                          AREA ||i.HAL_SPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxCpltCallback PROC
;;;2557     */
;;;2558   __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2559   {
;;;2560     /* Prevent unused argument(s) compilation warning */
;;;2561     UNUSED(hspi);
;;;2562   
;;;2563     /* NOTE : This function should not be modified, when the callback is needed,
;;;2564               the HAL_SPI_RxCpltCallback should be implemented in the user file
;;;2565      */
;;;2566   }
;;;2567   
                          ENDP


                          AREA ||i.HAL_SPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxHalfCpltCallback PROC
;;;2605     */
;;;2606   __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2607   {
;;;2608     /* Prevent unused argument(s) compilation warning */
;;;2609     UNUSED(hspi);
;;;2610   
;;;2611     /* NOTE : This function should not be modified, when the callback is needed,
;;;2612               the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
;;;2613      */
;;;2614   }
;;;2615   
                          ENDP


                          AREA ||i.HAL_SPI_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Transmit PROC
;;;794      */
;;;795    HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;796    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461d              MOV      r5,r3
;;;797      uint32_t tickstart;
;;;798      uint16_t initial_TxXferCount;
;;;799    
;;;800      /* Check Direction parameter */
;;;801      assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;802    
;;;803      /* Init tickstart for timeout management*/
;;;804      tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4606              MOV      r6,r0
;;;805      initial_TxXferCount = Size;
;;;806    
;;;807      if (hspi->State != HAL_SPI_STATE_READY)
000012  f8940051          LDRB     r0,[r4,#0x51]
000016  2801              CMP      r0,#1
000018  d002              BEQ      |L20.32|
;;;808      {
;;;809        return HAL_BUSY;
00001a  2002              MOVS     r0,#2
                  |L20.28|
;;;810      }
;;;811    
;;;812      if ((pData == NULL) || (Size == 0U))
;;;813      {
;;;814        return HAL_ERROR;
;;;815      }
;;;816    
;;;817      /* Process Locked */
;;;818      __HAL_LOCK(hspi);
;;;819    
;;;820      /* Set the transaction information */
;;;821      hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;822      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;823      hspi->pTxBuffPtr  = (const uint8_t *)pData;
;;;824      hspi->TxXferSize  = Size;
;;;825      hspi->TxXferCount = Size;
;;;826    
;;;827      /*Init field not used in handle to zero */
;;;828      hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;829      hspi->RxXferSize  = 0U;
;;;830      hspi->RxXferCount = 0U;
;;;831      hspi->TxISR       = NULL;
;;;832      hspi->RxISR       = NULL;
;;;833    
;;;834      /* Configure communication direction : 1Line */
;;;835      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;836      {
;;;837        /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;838        __HAL_SPI_DISABLE(hspi);
;;;839        SPI_1LINE_TX(hspi);
;;;840      }
;;;841    
;;;842    #if (USE_SPI_CRC != 0U)
;;;843      /* Reset CRC Calculation */
;;;844      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;845      {
;;;846        SPI_RESET_CRC(hspi);
;;;847      }
;;;848    #endif /* USE_SPI_CRC */
;;;849    
;;;850      /* Check if the SPI is already enabled */
;;;851      if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;852      {
;;;853        /* Enable SPI peripheral */
;;;854        __HAL_SPI_ENABLE(hspi);
;;;855      }
;;;856    
;;;857      /* Transmit data in 16 Bit mode */
;;;858      if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;859      {
;;;860        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;861        {
;;;862          hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
;;;863          hspi->pTxBuffPtr += sizeof(uint16_t);
;;;864          hspi->TxXferCount--;
;;;865        }
;;;866        /* Transmit data in 16 Bit mode */
;;;867        while (hspi->TxXferCount > 0U)
;;;868        {
;;;869          /* Wait until TXE flag is set to send data */
;;;870          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;871          {
;;;872            hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
;;;873            hspi->pTxBuffPtr += sizeof(uint16_t);
;;;874            hspi->TxXferCount--;
;;;875          }
;;;876          else
;;;877          {
;;;878            /* Timeout management */
;;;879            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;880            {
;;;881              hspi->State = HAL_SPI_STATE_READY;
;;;882              __HAL_UNLOCK(hspi);
;;;883              return HAL_TIMEOUT;
;;;884            }
;;;885          }
;;;886        }
;;;887      }
;;;888      /* Transmit data in 8 Bit mode */
;;;889      else
;;;890      {
;;;891        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;892        {
;;;893          *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
;;;894          hspi->pTxBuffPtr += sizeof(uint8_t);
;;;895          hspi->TxXferCount--;
;;;896        }
;;;897        while (hspi->TxXferCount > 0U)
;;;898        {
;;;899          /* Wait until TXE flag is set to send data */
;;;900          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;901          {
;;;902            *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
;;;903            hspi->pTxBuffPtr += sizeof(uint8_t);
;;;904            hspi->TxXferCount--;
;;;905          }
;;;906          else
;;;907          {
;;;908            /* Timeout management */
;;;909            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;910            {
;;;911              hspi->State = HAL_SPI_STATE_READY;
;;;912              __HAL_UNLOCK(hspi);
;;;913              return HAL_TIMEOUT;
;;;914            }
;;;915          }
;;;916        }
;;;917      }
;;;918    #if (USE_SPI_CRC != 0U)
;;;919      /* Enable CRC Transmission */
;;;920      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;921      {
;;;922        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;923      }
;;;924    #endif /* USE_SPI_CRC */
;;;925    
;;;926      /* Check the end of the transaction */
;;;927      if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;928      {
;;;929        hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;930      }
;;;931    
;;;932      /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;933      if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;934      {
;;;935        __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;936      }
;;;937    
;;;938      hspi->State = HAL_SPI_STATE_READY;
;;;939      /* Process Unlocked */
;;;940      __HAL_UNLOCK(hspi);
;;;941    
;;;942      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;943      {
;;;944        return HAL_ERROR;
;;;945      }
;;;946      else
;;;947      {
;;;948        return HAL_OK;
;;;949      }
;;;950    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.32|
000020  f1b90f00          CMP      r9,#0                 ;812
000024  d01f              BEQ      |L20.102|
000026  ea5f000a          MOVS     r0,r10                ;812
00002a  d01c              BEQ      |L20.102|
00002c  f8940050          LDRB     r0,[r4,#0x50]         ;818
000030  2801              CMP      r0,#1                 ;818
000032  d01a              BEQ      |L20.106|
000034  f04f0801          MOV      r8,#1                 ;818
000038  f8848050          STRB     r8,[r4,#0x50]         ;818
00003c  2003              MOVS     r0,#3                 ;821
00003e  f8840051          STRB     r0,[r4,#0x51]         ;821
000042  2700              MOVS     r7,#0                 ;822
000044  6567              STR      r7,[r4,#0x54]         ;822
000046  f8c49030          STR      r9,[r4,#0x30]         ;823
00004a  f8a4a034          STRH     r10,[r4,#0x34]        ;824
00004e  f8a4a036          STRH     r10,[r4,#0x36]        ;825
000052  63a7              STR      r7,[r4,#0x38]         ;828
000054  87a7              STRH     r7,[r4,#0x3c]         ;829
000056  87e7              STRH     r7,[r4,#0x3e]         ;830
000058  6467              STR      r7,[r4,#0x44]         ;831
00005a  6427              STR      r7,[r4,#0x40]         ;832
00005c  68a0              LDR      r0,[r4,#8]            ;835
00005e  f5b04f00          CMP      r0,#0x8000            ;835
000062  d004              BEQ      |L20.110|
000064  e00d              B        |L20.130|
                  |L20.102|
000066  2001              MOVS     r0,#1                 ;814
000068  e7d8              B        |L20.28|
                  |L20.106|
00006a  2002              MOVS     r0,#2                 ;818
00006c  e7d6              B        |L20.28|
                  |L20.110|
00006e  6820              LDR      r0,[r4,#0]            ;838
000070  6801              LDR      r1,[r0,#0]            ;838
000072  f0210140          BIC      r1,r1,#0x40           ;838
000076  6001              STR      r1,[r0,#0]            ;838
000078  6820              LDR      r0,[r4,#0]            ;839
00007a  6801              LDR      r1,[r0,#0]            ;839
00007c  f4414180          ORR      r1,r1,#0x4000         ;839
000080  6001              STR      r1,[r0,#0]            ;839
                  |L20.130|
000082  6aa0              LDR      r0,[r4,#0x28]         ;844
000084  f44f5900          MOV      r9,#0x2000            ;844
000088  4548              CMP      r0,r9                 ;844
00008a  d109              BNE      |L20.160|
00008c  6820              LDR      r0,[r4,#0]            ;846
00008e  6801              LDR      r1,[r0,#0]            ;846
000090  f4215100          BIC      r1,r1,#0x2000         ;846
000094  6001              STR      r1,[r0,#0]            ;846
000096  6820              LDR      r0,[r4,#0]            ;846
000098  6801              LDR      r1,[r0,#0]            ;846
00009a  f4415100          ORR      r1,r1,#0x2000         ;846
00009e  6001              STR      r1,[r0,#0]            ;846
                  |L20.160|
0000a0  6820              LDR      r0,[r4,#0]            ;851
0000a2  6801              LDR      r1,[r0,#0]            ;851
0000a4  0649              LSLS     r1,r1,#25             ;851
0000a6  d403              BMI      |L20.176|
0000a8  6801              LDR      r1,[r0,#0]            ;854
0000aa  f0410140          ORR      r1,r1,#0x40           ;854
0000ae  6001              STR      r1,[r0,#0]            ;854
                  |L20.176|
0000b0  68e0              LDR      r0,[r4,#0xc]          ;858
0000b2  f5b06f00          CMP      r0,#0x800             ;858
0000b6  d005              BEQ      |L20.196|
0000b8  6860              LDR      r0,[r4,#4]            ;891
0000ba  b398              CBZ      r0,|L20.292|
0000bc  f1ba0f01          CMP      r10,#1                ;891
0000c0  d031              BEQ      |L20.294|
0000c2  e051              B        |L20.360|
                  |L20.196|
0000c4  6860              LDR      r0,[r4,#4]            ;860
0000c6  b110              CBZ      r0,|L20.206|
0000c8  f1ba0f01          CMP      r10,#1                ;860
0000cc  d120              BNE      |L20.272|
                  |L20.206|
0000ce  6b20              LDR      r0,[r4,#0x30]         ;862
0000d0  6821              LDR      r1,[r4,#0]            ;862
0000d2  8800              LDRH     r0,[r0,#0]            ;862
0000d4  60c8              STR      r0,[r1,#0xc]          ;862
0000d6  6b20              LDR      r0,[r4,#0x30]         ;863
0000d8  1c80              ADDS     r0,r0,#2              ;863
0000da  6320              STR      r0,[r4,#0x30]         ;863
0000dc  8ee0              LDRH     r0,[r4,#0x36]         ;864
0000de  1e40              SUBS     r0,r0,#1              ;864
0000e0  86e0              STRH     r0,[r4,#0x36]         ;864
0000e2  e015              B        |L20.272|
                  |L20.228|
0000e4  6820              LDR      r0,[r4,#0]            ;870
0000e6  6881              LDR      r1,[r0,#8]            ;870
0000e8  0789              LSLS     r1,r1,#30             ;870
0000ea  d509              BPL      |L20.256|
0000ec  6b21              LDR      r1,[r4,#0x30]         ;872
0000ee  8809              LDRH     r1,[r1,#0]            ;872
0000f0  60c1              STR      r1,[r0,#0xc]          ;872
0000f2  6b20              LDR      r0,[r4,#0x30]         ;873
0000f4  1c80              ADDS     r0,r0,#2              ;873
0000f6  6320              STR      r0,[r4,#0x30]         ;873
0000f8  8ee0              LDRH     r0,[r4,#0x36]         ;874
0000fa  1e40              SUBS     r0,r0,#1              ;874
0000fc  86e0              STRH     r0,[r4,#0x36]         ;874
0000fe  e007              B        |L20.272|
                  |L20.256|
000100  f7fffffe          BL       HAL_GetTick
000104  1b80              SUBS     r0,r0,r6              ;879
000106  42a8              CMP      r0,r5                 ;879
000108  d301              BCC      |L20.270|
00010a  1c68              ADDS     r0,r5,#1              ;879
00010c  d104              BNE      |L20.280|
                  |L20.270|
00010e  b11d              CBZ      r5,|L20.280|
                  |L20.272|
000110  8ee0              LDRH     r0,[r4,#0x36]         ;867
000112  2800              CMP      r0,#0                 ;867
000114  d1e6              BNE      |L20.228|
000116  e02a              B        |L20.366|
                  |L20.280|
000118  f8848051          STRB     r8,[r4,#0x51]         ;881
00011c  f8847050          STRB     r7,[r4,#0x50]         ;882
000120  2003              MOVS     r0,#3                 ;883
000122  e77b              B        |L20.28|
                  |L20.292|
000124  e7ff              B        |L20.294|
                  |L20.294|
000126  6b20              LDR      r0,[r4,#0x30]         ;893
000128  6821              LDR      r1,[r4,#0]            ;893
00012a  7800              LDRB     r0,[r0,#0]            ;893
00012c  7308              STRB     r0,[r1,#0xc]          ;893
00012e  6b20              LDR      r0,[r4,#0x30]         ;894
000130  1c40              ADDS     r0,r0,#1              ;894
000132  6320              STR      r0,[r4,#0x30]         ;894
000134  8ee0              LDRH     r0,[r4,#0x36]         ;895
000136  1e40              SUBS     r0,r0,#1              ;895
000138  86e0              STRH     r0,[r4,#0x36]         ;895
00013a  e015              B        |L20.360|
                  |L20.316|
00013c  6820              LDR      r0,[r4,#0]            ;900
00013e  6881              LDR      r1,[r0,#8]            ;900
000140  0789              LSLS     r1,r1,#30             ;900
000142  d509              BPL      |L20.344|
000144  6b21              LDR      r1,[r4,#0x30]         ;902
000146  7809              LDRB     r1,[r1,#0]            ;902
000148  7301              STRB     r1,[r0,#0xc]          ;902
00014a  6b20              LDR      r0,[r4,#0x30]         ;903
00014c  1c40              ADDS     r0,r0,#1              ;903
00014e  6320              STR      r0,[r4,#0x30]         ;903
000150  8ee0              LDRH     r0,[r4,#0x36]         ;904
000152  1e40              SUBS     r0,r0,#1              ;904
000154  86e0              STRH     r0,[r4,#0x36]         ;904
000156  e007              B        |L20.360|
                  |L20.344|
000158  f7fffffe          BL       HAL_GetTick
00015c  1b80              SUBS     r0,r0,r6              ;909
00015e  42a8              CMP      r0,r5                 ;909
000160  d301              BCC      |L20.358|
000162  1c68              ADDS     r0,r5,#1              ;909
000164  d116              BNE      |L20.404|
                  |L20.358|
000166  b1ad              CBZ      r5,|L20.404|
                  |L20.360|
000168  8ee0              LDRH     r0,[r4,#0x36]         ;897
00016a  2800              CMP      r0,#0                 ;897
00016c  d1e6              BNE      |L20.316|
                  |L20.366|
00016e  6aa0              LDR      r0,[r4,#0x28]         ;920
000170  4548              CMP      r0,r9                 ;920
000172  d104              BNE      |L20.382|
000174  6820              LDR      r0,[r4,#0]            ;922
000176  6801              LDR      r1,[r0,#0]            ;922
000178  f4415180          ORR      r1,r1,#0x1000         ;922
00017c  6001              STR      r1,[r0,#0]            ;922
                  |L20.382|
00017e  4632              MOV      r2,r6                 ;927
000180  4629              MOV      r1,r5                 ;927
000182  4620              MOV      r0,r4                 ;927
000184  f7fffffe          BL       SPI_EndRxTxTransaction
000188  b108              CBZ      r0,|L20.398|
00018a  2020              MOVS     r0,#0x20              ;929
00018c  6560              STR      r0,[r4,#0x54]         ;929
                  |L20.398|
00018e  68a0              LDR      r0,[r4,#8]            ;933
000190  b130              CBZ      r0,|L20.416|
000192  e009              B        |L20.424|
                  |L20.404|
000194  f8848051          STRB     r8,[r4,#0x51]         ;911
000198  f8847050          STRB     r7,[r4,#0x50]         ;912
00019c  2003              MOVS     r0,#3                 ;913
00019e  e73d              B        |L20.28|
                  |L20.416|
0001a0  6820              LDR      r0,[r4,#0]            ;935
0001a2  68c1              LDR      r1,[r0,#0xc]          ;935
0001a4  6880              LDR      r0,[r0,#8]            ;935
0001a6  9000              STR      r0,[sp,#0]            ;935
                  |L20.424|
0001a8  f8848051          STRB     r8,[r4,#0x51]         ;938
0001ac  f8847050          STRB     r7,[r4,#0x50]         ;940
0001b0  6d60              LDR      r0,[r4,#0x54]         ;942
0001b2  b108              CBZ      r0,|L20.440|
0001b4  2001              MOVS     r0,#1                 ;944
0001b6  e731              B        |L20.28|
                  |L20.440|
0001b8  2000              MOVS     r0,#0                 ;948
0001ba  e72f              B        |L20.28|
;;;951    
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TransmitReceive PROC
;;;1176     */
;;;1177   HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, const uint8_t *pTxData, uint8_t *pRxData,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1178                                             uint16_t Size, uint32_t Timeout)
;;;1179   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  9e10              LDR      r6,[sp,#0x40]
00000a  468a              MOV      r10,r1
00000c  461f              MOV      r7,r3
;;;1180     uint16_t             initial_TxXferCount;
;;;1181     uint32_t             tmp_mode;
;;;1182     HAL_SPI_StateTypeDef tmp_state;
;;;1183     uint32_t             tickstart;
;;;1184   #if (USE_SPI_CRC != 0U)
;;;1185     __IO uint32_t tmpreg = 0U;
00000e  f04f0900          MOV      r9,#0
000012  f8cd9008          STR      r9,[sp,#8]
;;;1186   #endif /* USE_SPI_CRC */
;;;1187   
;;;1188     /* Variable used to alternate Rx and Tx during transfer */
;;;1189     uint32_t             txallowed = 1U;
000016  2501              MOVS     r5,#1
;;;1190   
;;;1191     /* Check Direction parameter */
;;;1192     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1193   
;;;1194     /* Init tickstart for timeout management*/
;;;1195     tickstart = HAL_GetTick();
000018  f7fffffe          BL       HAL_GetTick
00001c  4680              MOV      r8,r0
;;;1196   
;;;1197     /* Init temporary variables */
;;;1198     tmp_state           = hspi->State;
00001e  f8940051          LDRB     r0,[r4,#0x51]
;;;1199     tmp_mode            = hspi->Init.Mode;
000022  6861              LDR      r1,[r4,#4]
;;;1200     initial_TxXferCount = Size;
;;;1201   
;;;1202     if (!((tmp_state == HAL_SPI_STATE_READY) || \
000024  2801              CMP      r0,#1
000026  d00a              BEQ      |L21.62|
000028  f5b17f82          CMP      r1,#0x104
00002c  d103              BNE      |L21.54|
00002e  68a1              LDR      r1,[r4,#8]
000030  b909              CBNZ     r1,|L21.54|
000032  2804              CMP      r0,#4
000034  d003              BEQ      |L21.62|
                  |L21.54|
;;;1203           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) &&
;;;1204            (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1205     {
;;;1206       return HAL_BUSY;
000036  2002              MOVS     r0,#2
                  |L21.56|
;;;1207     }
;;;1208   
;;;1209     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1210     {
;;;1211       return HAL_ERROR;
;;;1212     }
;;;1213   
;;;1214     /* Process Locked */
;;;1215     __HAL_LOCK(hspi);
;;;1216   
;;;1217     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1218     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1219     {
;;;1220       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1221     }
;;;1222   
;;;1223     /* Set the transaction information */
;;;1224     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1225     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1226     hspi->RxXferCount = Size;
;;;1227     hspi->RxXferSize  = Size;
;;;1228     hspi->pTxBuffPtr  = (const uint8_t *)pTxData;
;;;1229     hspi->TxXferCount = Size;
;;;1230     hspi->TxXferSize  = Size;
;;;1231   
;;;1232     /*Init field not used in handle to zero */
;;;1233     hspi->RxISR       = NULL;
;;;1234     hspi->TxISR       = NULL;
;;;1235   
;;;1236   #if (USE_SPI_CRC != 0U)
;;;1237     /* Reset CRC Calculation */
;;;1238     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1239     {
;;;1240       SPI_RESET_CRC(hspi);
;;;1241     }
;;;1242   #endif /* USE_SPI_CRC */
;;;1243   
;;;1244     /* Check if the SPI is already enabled */
;;;1245     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1246     {
;;;1247       /* Enable SPI peripheral */
;;;1248       __HAL_SPI_ENABLE(hspi);
;;;1249     }
;;;1250   
;;;1251     /* Transmit and Receive data in 16 Bit mode */
;;;1252     if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1253     {
;;;1254       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1255       {
;;;1256         hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
;;;1257         hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1258         hspi->TxXferCount--;
;;;1259   
;;;1260   #if (USE_SPI_CRC != 0U)
;;;1261         /* Enable CRC Transmission */
;;;1262         if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1263         {
;;;1264           SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1265         }
;;;1266   #endif /* USE_SPI_CRC */
;;;1267   
;;;1268       }
;;;1269       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1270       {
;;;1271         /* Check TXE flag */
;;;1272         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1273         {
;;;1274           hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
;;;1275           hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1276           hspi->TxXferCount--;
;;;1277           /* Next Data is a reception (Rx). Tx not allowed */
;;;1278           txallowed = 0U;
;;;1279   
;;;1280   #if (USE_SPI_CRC != 0U)
;;;1281           /* Enable CRC Transmission */
;;;1282           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1283           {
;;;1284             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1285           }
;;;1286   #endif /* USE_SPI_CRC */
;;;1287         }
;;;1288   
;;;1289         /* Check RXNE flag */
;;;1290         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1291         {
;;;1292           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1293           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1294           hspi->RxXferCount--;
;;;1295           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1296           txallowed = 1U;
;;;1297         }
;;;1298         if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
;;;1299         {
;;;1300           hspi->State = HAL_SPI_STATE_READY;
;;;1301           __HAL_UNLOCK(hspi);
;;;1302           return HAL_TIMEOUT;
;;;1303         }
;;;1304       }
;;;1305     }
;;;1306     /* Transmit and Receive data in 8 Bit mode */
;;;1307     else
;;;1308     {
;;;1309       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1310       {
;;;1311         *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
;;;1312         hspi->pTxBuffPtr += sizeof(uint8_t);
;;;1313         hspi->TxXferCount--;
;;;1314   
;;;1315   #if (USE_SPI_CRC != 0U)
;;;1316         /* Enable CRC Transmission */
;;;1317         if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1318         {
;;;1319           SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1320         }
;;;1321   #endif /* USE_SPI_CRC */
;;;1322       }
;;;1323       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1324       {
;;;1325         /* Check TXE flag */
;;;1326         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1327         {
;;;1328           *(__IO uint8_t *)&hspi->Instance->DR = *((const uint8_t *)hspi->pTxBuffPtr);
;;;1329           hspi->pTxBuffPtr++;
;;;1330           hspi->TxXferCount--;
;;;1331           /* Next Data is a reception (Rx). Tx not allowed */
;;;1332           txallowed = 0U;
;;;1333   
;;;1334   #if (USE_SPI_CRC != 0U)
;;;1335           /* Enable CRC Transmission */
;;;1336           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1337           {
;;;1338             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1339           }
;;;1340   #endif /* USE_SPI_CRC */
;;;1341         }
;;;1342   
;;;1343         /* Wait until RXNE flag is reset */
;;;1344         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1345         {
;;;1346           (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
;;;1347           hspi->pRxBuffPtr++;
;;;1348           hspi->RxXferCount--;
;;;1349           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1350           txallowed = 1U;
;;;1351         }
;;;1352         if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
;;;1353         {
;;;1354           hspi->State = HAL_SPI_STATE_READY;
;;;1355           __HAL_UNLOCK(hspi);
;;;1356           return HAL_TIMEOUT;
;;;1357         }
;;;1358       }
;;;1359     }
;;;1360   
;;;1361   #if (USE_SPI_CRC != 0U)
;;;1362     /* Read CRC from DR to close CRC calculation process */
;;;1363     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1364     {
;;;1365       /* Wait until TXE flag */
;;;1366       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1367       {
;;;1368         /* Error on the CRC reception */
;;;1369         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1370         hspi->State = HAL_SPI_STATE_READY;
;;;1371         __HAL_UNLOCK(hspi);
;;;1372         return HAL_TIMEOUT;
;;;1373       }
;;;1374       /* Read CRC */
;;;1375       tmpreg = READ_REG(hspi->Instance->DR);
;;;1376       /* To avoid GCC warning */
;;;1377       UNUSED(tmpreg);
;;;1378     }
;;;1379   
;;;1380     /* Check if CRC error occurred */
;;;1381     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;1382     {
;;;1383       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;1384       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;1385       {
;;;1386         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1387   
;;;1388         /* Reset CRC Calculation */
;;;1389         SPI_RESET_CRC(hspi);
;;;1390         __HAL_UNLOCK(hspi);
;;;1391         return HAL_ERROR;
;;;1392       }
;;;1393       else
;;;1394       {
;;;1395         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1396       }
;;;1397     }
;;;1398   #endif /* USE_SPI_CRC */
;;;1399   
;;;1400     /* Check the end of the transaction */
;;;1401     if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1402     {
;;;1403       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1404       __HAL_UNLOCK(hspi);
;;;1405       return HAL_ERROR;
;;;1406     }
;;;1407   
;;;1408     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;1409     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;1410     {
;;;1411       __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;1412     }
;;;1413   
;;;1414   
;;;1415     hspi->State = HAL_SPI_STATE_READY;
;;;1416     /* Unlock the process */
;;;1417     __HAL_UNLOCK(hspi);
;;;1418   
;;;1419     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;1420     {
;;;1421       return HAL_ERROR;
;;;1422     }
;;;1423     else
;;;1424     {
;;;1425       return HAL_OK;
;;;1426     }
;;;1427   }
000038  b007              ADD      sp,sp,#0x1c
00003a  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.62|
00003e  f1ba0f00          CMP      r10,#0                ;1209
000042  d042              BEQ      |L21.202|
000044  9805              LDR      r0,[sp,#0x14]         ;1209
000046  b3e8              CBZ      r0,|L21.196|
000048  0038              MOVS     r0,r7                 ;1209
00004a  d03e              BEQ      |L21.202|
00004c  f8940050          LDRB     r0,[r4,#0x50]         ;1215
000050  2801              CMP      r0,#1                 ;1215
000052  d03c              BEQ      |L21.206|
000054  f04f0b01          MOV      r11,#1                ;1215
000058  f884b050          STRB     r11,[r4,#0x50]        ;1215
00005c  f8940051          LDRB     r0,[r4,#0x51]         ;1218
000060  2804              CMP      r0,#4                 ;1218
000062  d002              BEQ      |L21.106|
000064  2005              MOVS     r0,#5                 ;1220
000066  f8840051          STRB     r0,[r4,#0x51]         ;1220
                  |L21.106|
00006a  f8c49054          STR      r9,[r4,#0x54]         ;1224
00006e  9805              LDR      r0,[sp,#0x14]         ;1225
000070  63a0              STR      r0,[r4,#0x38]         ;1225
000072  87e7              STRH     r7,[r4,#0x3e]         ;1226
000074  87a7              STRH     r7,[r4,#0x3c]         ;1227
000076  f8c4a030          STR      r10,[r4,#0x30]        ;1228
00007a  86e7              STRH     r7,[r4,#0x36]         ;1229
00007c  86a7              STRH     r7,[r4,#0x34]         ;1230
00007e  f8c49040          STR      r9,[r4,#0x40]         ;1233
000082  f8c49044          STR      r9,[r4,#0x44]         ;1234
000086  6aa0              LDR      r0,[r4,#0x28]         ;1238
000088  f44f5a00          MOV      r10,#0x2000           ;1238
00008c  4550              CMP      r0,r10                ;1238
00008e  d109              BNE      |L21.164|
000090  6820              LDR      r0,[r4,#0]            ;1240
000092  6801              LDR      r1,[r0,#0]            ;1240
000094  f4215100          BIC      r1,r1,#0x2000         ;1240
000098  6001              STR      r1,[r0,#0]            ;1240
00009a  6820              LDR      r0,[r4,#0]            ;1240
00009c  6801              LDR      r1,[r0,#0]            ;1240
00009e  f4415100          ORR      r1,r1,#0x2000         ;1240
0000a2  6001              STR      r1,[r0,#0]            ;1240
                  |L21.164|
0000a4  6820              LDR      r0,[r4,#0]            ;1245
0000a6  6801              LDR      r1,[r0,#0]            ;1245
0000a8  0649              LSLS     r1,r1,#25             ;1245
0000aa  d403              BMI      |L21.180|
0000ac  6801              LDR      r1,[r0,#0]            ;1248
0000ae  f0410140          ORR      r1,r1,#0x40           ;1248
0000b2  6001              STR      r1,[r0,#0]            ;1248
                  |L21.180|
0000b4  68e0              LDR      r0,[r4,#0xc]          ;1252
0000b6  f5b06f00          CMP      r0,#0x800             ;1252
0000ba  d00a              BEQ      |L21.210|
0000bc  6860              LDR      r0,[r4,#4]            ;1309
0000be  b3e8              CBZ      r0,|L21.316|
0000c0  2f01              CMP      r7,#1                 ;1309
0000c2  e000              B        |L21.198|
                  |L21.196|
0000c4  e001              B        |L21.202|
                  |L21.198|
0000c6  d062              BEQ      |L21.398|
0000c8  e0ab              B        |L21.546|
                  |L21.202|
0000ca  2001              MOVS     r0,#1                 ;1211
0000cc  e7b4              B        |L21.56|
                  |L21.206|
0000ce  2002              MOVS     r0,#2                 ;1215
0000d0  e7b2              B        |L21.56|
                  |L21.210|
0000d2  6860              LDR      r0,[r4,#4]            ;1254
0000d4  b108              CBZ      r0,|L21.218|
0000d6  2f01              CMP      r7,#1                 ;1254
0000d8  d152              BNE      |L21.384|
                  |L21.218|
0000da  6b20              LDR      r0,[r4,#0x30]         ;1256
0000dc  6821              LDR      r1,[r4,#0]            ;1256
0000de  8800              LDRH     r0,[r0,#0]            ;1256
0000e0  60c8              STR      r0,[r1,#0xc]          ;1256
0000e2  6b20              LDR      r0,[r4,#0x30]         ;1257
0000e4  1c80              ADDS     r0,r0,#2              ;1257
0000e6  6320              STR      r0,[r4,#0x30]         ;1257
0000e8  8ee0              LDRH     r0,[r4,#0x36]         ;1258
0000ea  1e40              SUBS     r0,r0,#1              ;1258
0000ec  86e0              STRH     r0,[r4,#0x36]         ;1258
0000ee  8ee0              LDRH     r0,[r4,#0x36]         ;1262
0000f0  bbf0              CBNZ     r0,|L21.368|
0000f2  6aa0              LDR      r0,[r4,#0x28]         ;1262
0000f4  4550              CMP      r0,r10                ;1262
0000f6  d143              BNE      |L21.384|
0000f8  6820              LDR      r0,[r4,#0]            ;1264
0000fa  6801              LDR      r1,[r0,#0]            ;1264
0000fc  f4415180          ORR      r1,r1,#0x1000         ;1264
000100  6001              STR      r1,[r0,#0]            ;1264
000102  e03d              B        |L21.384|
                  |L21.260|
000104  6820              LDR      r0,[r4,#0]            ;1272
000106  6881              LDR      r1,[r0,#8]            ;1272
000108  0789              LSLS     r1,r1,#30             ;1272
00010a  d519              BPL      |L21.320|
00010c  8ee1              LDRH     r1,[r4,#0x36]         ;1272
00010e  b1b9              CBZ      r1,|L21.320|
000110  2d01              CMP      r5,#1                 ;1272
000112  d115              BNE      |L21.320|
000114  6b21              LDR      r1,[r4,#0x30]         ;1274
000116  8809              LDRH     r1,[r1,#0]            ;1274
000118  60c1              STR      r1,[r0,#0xc]          ;1274
00011a  6b20              LDR      r0,[r4,#0x30]         ;1275
00011c  1c80              ADDS     r0,r0,#2              ;1275
00011e  6320              STR      r0,[r4,#0x30]         ;1275
000120  8ee0              LDRH     r0,[r4,#0x36]         ;1276
000122  1e40              SUBS     r0,r0,#1              ;1276
000124  86e0              STRH     r0,[r4,#0x36]         ;1276
000126  2500              MOVS     r5,#0                 ;1278
000128  8ee0              LDRH     r0,[r4,#0x36]         ;1282
00012a  b948              CBNZ     r0,|L21.320|
00012c  6aa0              LDR      r0,[r4,#0x28]         ;1282
00012e  4550              CMP      r0,r10                ;1282
000130  d106              BNE      |L21.320|
000132  6820              LDR      r0,[r4,#0]            ;1284
000134  6801              LDR      r1,[r0,#0]            ;1284
000136  f4415180          ORR      r1,r1,#0x1000         ;1284
00013a  e000              B        |L21.318|
                  |L21.316|
00013c  e027              B        |L21.398|
                  |L21.318|
00013e  6001              STR      r1,[r0,#0]            ;1284
                  |L21.320|
000140  6820              LDR      r0,[r4,#0]            ;1290
000142  6881              LDR      r1,[r0,#8]            ;1290
000144  07c9              LSLS     r1,r1,#31             ;1290
000146  d00b              BEQ      |L21.352|
000148  8fe1              LDRH     r1,[r4,#0x3e]         ;1290
00014a  b149              CBZ      r1,|L21.352|
00014c  68c0              LDR      r0,[r0,#0xc]          ;1292
00014e  6ba1              LDR      r1,[r4,#0x38]         ;1292
000150  8008              STRH     r0,[r1,#0]            ;1292
000152  6ba0              LDR      r0,[r4,#0x38]         ;1293
000154  1c80              ADDS     r0,r0,#2              ;1293
000156  63a0              STR      r0,[r4,#0x38]         ;1293
000158  8fe0              LDRH     r0,[r4,#0x3e]         ;1294
00015a  1e40              SUBS     r0,r0,#1              ;1294
00015c  87e0              STRH     r0,[r4,#0x3e]         ;1294
00015e  2501              MOVS     r5,#1                 ;1296
                  |L21.352|
000160  f7fffffe          BL       HAL_GetTick
000164  eba00008          SUB      r0,r0,r8              ;1298
000168  42b0              CMP      r0,r6                 ;1298
00016a  d309              BCC      |L21.384|
00016c  1c70              ADDS     r0,r6,#1              ;1298
00016e  e000              B        |L21.370|
                  |L21.368|
000170  e006              B        |L21.384|
                  |L21.370|
000172  d005              BEQ      |L21.384|
000174  f884b051          STRB     r11,[r4,#0x51]        ;1300
000178  f8849050          STRB     r9,[r4,#0x50]         ;1301
00017c  2003              MOVS     r0,#3                 ;1302
00017e  e75b              B        |L21.56|
                  |L21.384|
000180  8ee0              LDRH     r0,[r4,#0x36]         ;1269
000182  2800              CMP      r0,#0                 ;1269
000184  d1be              BNE      |L21.260|
000186  8fe0              LDRH     r0,[r4,#0x3e]         ;1269
000188  2800              CMP      r0,#0                 ;1269
00018a  d1bb              BNE      |L21.260|
00018c  e04f              B        |L21.558|
                  |L21.398|
00018e  6b20              LDR      r0,[r4,#0x30]         ;1311
000190  6821              LDR      r1,[r4,#0]            ;1311
000192  7800              LDRB     r0,[r0,#0]            ;1311
000194  7308              STRB     r0,[r1,#0xc]          ;1311
000196  6b20              LDR      r0,[r4,#0x30]         ;1312
000198  1c40              ADDS     r0,r0,#1              ;1312
00019a  6320              STR      r0,[r4,#0x30]         ;1312
00019c  8ee0              LDRH     r0,[r4,#0x36]         ;1313
00019e  1e40              SUBS     r0,r0,#1              ;1313
0001a0  86e0              STRH     r0,[r4,#0x36]         ;1313
0001a2  8ee0              LDRH     r0,[r4,#0x36]         ;1317
0001a4  bbe8              CBNZ     r0,|L21.546|
0001a6  6aa0              LDR      r0,[r4,#0x28]         ;1317
0001a8  4550              CMP      r0,r10                ;1317
0001aa  d13a              BNE      |L21.546|
0001ac  6820              LDR      r0,[r4,#0]            ;1319
0001ae  6801              LDR      r1,[r0,#0]            ;1319
0001b0  f4415180          ORR      r1,r1,#0x1000         ;1319
0001b4  6001              STR      r1,[r0,#0]            ;1319
0001b6  e034              B        |L21.546|
                  |L21.440|
0001b8  6820              LDR      r0,[r4,#0]            ;1326
0001ba  6881              LDR      r1,[r0,#8]            ;1326
0001bc  0789              LSLS     r1,r1,#30             ;1326
0001be  d517              BPL      |L21.496|
0001c0  8ee1              LDRH     r1,[r4,#0x36]         ;1326
0001c2  b1a9              CBZ      r1,|L21.496|
0001c4  2d01              CMP      r5,#1                 ;1326
0001c6  d113              BNE      |L21.496|
0001c8  6b21              LDR      r1,[r4,#0x30]         ;1328
0001ca  7809              LDRB     r1,[r1,#0]            ;1328
0001cc  7301              STRB     r1,[r0,#0xc]          ;1328
0001ce  6b20              LDR      r0,[r4,#0x30]         ;1329
0001d0  1c40              ADDS     r0,r0,#1              ;1329
0001d2  6320              STR      r0,[r4,#0x30]         ;1329
0001d4  8ee0              LDRH     r0,[r4,#0x36]         ;1330
0001d6  1e40              SUBS     r0,r0,#1              ;1330
0001d8  86e0              STRH     r0,[r4,#0x36]         ;1330
0001da  2500              MOVS     r5,#0                 ;1332
0001dc  8ee0              LDRH     r0,[r4,#0x36]         ;1336
0001de  b938              CBNZ     r0,|L21.496|
0001e0  6aa0              LDR      r0,[r4,#0x28]         ;1336
0001e2  4550              CMP      r0,r10                ;1336
0001e4  d104              BNE      |L21.496|
0001e6  6820              LDR      r0,[r4,#0]            ;1338
0001e8  6801              LDR      r1,[r0,#0]            ;1338
0001ea  f4415180          ORR      r1,r1,#0x1000         ;1338
0001ee  6001              STR      r1,[r0,#0]            ;1338
                  |L21.496|
0001f0  6820              LDR      r0,[r4,#0]            ;1344
0001f2  6881              LDR      r1,[r0,#8]            ;1344
0001f4  07c9              LSLS     r1,r1,#31             ;1344
0001f6  d00b              BEQ      |L21.528|
0001f8  8fe1              LDRH     r1,[r4,#0x3e]         ;1344
0001fa  b149              CBZ      r1,|L21.528|
0001fc  68c0              LDR      r0,[r0,#0xc]          ;1346
0001fe  6ba1              LDR      r1,[r4,#0x38]         ;1346
000200  7008              STRB     r0,[r1,#0]            ;1346
000202  6ba0              LDR      r0,[r4,#0x38]         ;1347
000204  1c40              ADDS     r0,r0,#1              ;1347
000206  63a0              STR      r0,[r4,#0x38]         ;1347
000208  8fe0              LDRH     r0,[r4,#0x3e]         ;1348
00020a  1e40              SUBS     r0,r0,#1              ;1348
00020c  87e0              STRH     r0,[r4,#0x3e]         ;1348
00020e  2501              MOVS     r5,#1                 ;1350
                  |L21.528|
000210  f7fffffe          BL       HAL_GetTick
000214  eba00008          SUB      r0,r0,r8              ;1352
000218  42b0              CMP      r0,r6                 ;1352
00021a  d301              BCC      |L21.544|
00021c  1c70              ADDS     r0,r6,#1              ;1352
00021e  d11c              BNE      |L21.602|
                  |L21.544|
000220  b1de              CBZ      r6,|L21.602|
                  |L21.546|
000222  8ee0              LDRH     r0,[r4,#0x36]         ;1323
000224  2800              CMP      r0,#0                 ;1323
000226  d1c7              BNE      |L21.440|
000228  8fe0              LDRH     r0,[r4,#0x3e]         ;1323
00022a  2800              CMP      r0,#0                 ;1323
00022c  d1c4              BNE      |L21.440|
                  |L21.558|
00022e  6aa0              LDR      r0,[r4,#0x28]         ;1363
000230  4550              CMP      r0,r10                ;1363
000232  d11b              BNE      |L21.620|
000234  2201              MOVS     r2,#1                 ;1366
000236  4633              MOV      r3,r6                 ;1366
000238  4611              MOV      r1,r2                 ;1366
00023a  4620              MOV      r0,r4                 ;1366
00023c  f8cd8000          STR      r8,[sp,#0]            ;1366
000240  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000244  b178              CBZ      r0,|L21.614|
000246  6d60              LDR      r0,[r4,#0x54]         ;1369
000248  f0400002          ORR      r0,r0,#2              ;1369
00024c  6560              STR      r0,[r4,#0x54]         ;1369
00024e  f884b051          STRB     r11,[r4,#0x51]        ;1370
000252  f8849050          STRB     r9,[r4,#0x50]         ;1371
000256  2003              MOVS     r0,#3                 ;1372
000258  e6ee              B        |L21.56|
                  |L21.602|
00025a  f884b051          STRB     r11,[r4,#0x51]        ;1354
00025e  f8849050          STRB     r9,[r4,#0x50]         ;1355
000262  2003              MOVS     r0,#3                 ;1356
000264  e6e8              B        |L21.56|
                  |L21.614|
000266  6820              LDR      r0,[r4,#0]            ;1375
000268  68c0              LDR      r0,[r0,#0xc]          ;1375
00026a  9002              STR      r0,[sp,#8]            ;1375
                  |L21.620|
00026c  6820              LDR      r0,[r4,#0]            ;1381
00026e  6880              LDR      r0,[r0,#8]            ;1381
000270  43c0              MVNS     r0,r0                 ;1381
000272  06c0              LSLS     r0,r0,#27             ;1381
000274  d408              BMI      |L21.648|
000276  4620              MOV      r0,r4                 ;1384
000278  f7fffffe          BL       SPI_ISCRCErrorValid
00027c  2801              CMP      r0,#1                 ;1384
00027e  d00f              BEQ      |L21.672|
000280  6821              LDR      r1,[r4,#0]            ;1395
000282  f64f70ef          MOV      r0,#0xffef            ;1395
000286  6088              STR      r0,[r1,#8]            ;1395
                  |L21.648|
000288  4642              MOV      r2,r8                 ;1401
00028a  4631              MOV      r1,r6                 ;1401
00028c  4620              MOV      r0,r4                 ;1401
00028e  f7fffffe          BL       SPI_EndRxTxTransaction
000292  b1b8              CBZ      r0,|L21.708|
000294  2020              MOVS     r0,#0x20              ;1403
000296  6560              STR      r0,[r4,#0x54]         ;1403
000298  f8849050          STRB     r9,[r4,#0x50]         ;1404
00029c  2001              MOVS     r0,#1                 ;1405
00029e  e6cb              B        |L21.56|
                  |L21.672|
0002a0  6d60              LDR      r0,[r4,#0x54]         ;1386
0002a2  f0400002          ORR      r0,r0,#2              ;1386
0002a6  6560              STR      r0,[r4,#0x54]         ;1386
0002a8  6820              LDR      r0,[r4,#0]            ;1389
0002aa  6801              LDR      r1,[r0,#0]            ;1389
0002ac  f4215100          BIC      r1,r1,#0x2000         ;1389
0002b0  6001              STR      r1,[r0,#0]            ;1389
0002b2  6820              LDR      r0,[r4,#0]            ;1389
0002b4  6801              LDR      r1,[r0,#0]            ;1389
0002b6  f4415100          ORR      r1,r1,#0x2000         ;1389
0002ba  6001              STR      r1,[r0,#0]            ;1389
0002bc  f8849050          STRB     r9,[r4,#0x50]         ;1390
0002c0  2001              MOVS     r0,#1                 ;1391
0002c2  e6b9              B        |L21.56|
                  |L21.708|
0002c4  68a0              LDR      r0,[r4,#8]            ;1409
0002c6  b918              CBNZ     r0,|L21.720|
0002c8  6820              LDR      r0,[r4,#0]            ;1411
0002ca  68c1              LDR      r1,[r0,#0xc]          ;1411
0002cc  6880              LDR      r0,[r0,#8]            ;1411
0002ce  9001              STR      r0,[sp,#4]            ;1411
                  |L21.720|
0002d0  f884b051          STRB     r11,[r4,#0x51]        ;1415
0002d4  f8849050          STRB     r9,[r4,#0x50]         ;1417
0002d8  6d60              LDR      r0,[r4,#0x54]         ;1419
0002da  b108              CBZ      r0,|L21.736|
0002dc  2001              MOVS     r0,#1                 ;1421
0002de  e6ab              B        |L21.56|
                  |L21.736|
0002e0  2000              MOVS     r0,#0                 ;1425
0002e2  e6a9              B        |L21.56|
;;;1428   
                          ENDP


                          AREA ||i.HAL_SPI_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_DMA PROC
;;;1910     */
;;;1911   HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, const uint8_t *pTxData, uint8_t *pRxData,
000000  b570              PUSH     {r4-r6,lr}
;;;1912                                                 uint16_t Size)
;;;1913   {
000002  4604              MOV      r4,r0
;;;1914     uint32_t             tmp_mode;
;;;1915     HAL_SPI_StateTypeDef tmp_state;
;;;1916   
;;;1917     /* Check rx & tx dma handles */
;;;1918     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
;;;1919     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1920   
;;;1921     /* Check Direction parameter */
;;;1922     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1923   
;;;1924     /* Init temporary variables */
;;;1925     tmp_state           = hspi->State;
000004  f8940051          LDRB     r0,[r4,#0x51]
;;;1926     tmp_mode            = hspi->Init.Mode;
000008  6865              LDR      r5,[r4,#4]
;;;1927   
;;;1928     if (!((tmp_state == HAL_SPI_STATE_READY) ||
00000a  2801              CMP      r0,#1
00000c  d008              BEQ      |L22.32|
00000e  f5b57f82          CMP      r5,#0x104
000012  d103              BNE      |L22.28|
000014  68a5              LDR      r5,[r4,#8]
000016  b90d              CBNZ     r5,|L22.28|
000018  2804              CMP      r0,#4
00001a  d001              BEQ      |L22.32|
                  |L22.28|
;;;1929           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) &&
;;;1930            (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1931     {
;;;1932       return HAL_BUSY;
00001c  2002              MOVS     r0,#2
;;;1933     }
;;;1934   
;;;1935     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1936     {
;;;1937       return HAL_ERROR;
;;;1938     }
;;;1939   
;;;1940     /* Process locked */
;;;1941     __HAL_LOCK(hspi);
;;;1942   
;;;1943     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1944     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1945     {
;;;1946       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1947     }
;;;1948   
;;;1949     /* Set the transaction information */
;;;1950     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1951     hspi->pTxBuffPtr  = (const uint8_t *)pTxData;
;;;1952     hspi->TxXferSize  = Size;
;;;1953     hspi->TxXferCount = Size;
;;;1954     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1955     hspi->RxXferSize  = Size;
;;;1956     hspi->RxXferCount = Size;
;;;1957   
;;;1958     /* Init field not used in handle to zero */
;;;1959     hspi->RxISR       = NULL;
;;;1960     hspi->TxISR       = NULL;
;;;1961   
;;;1962   #if (USE_SPI_CRC != 0U)
;;;1963     /* Reset CRC Calculation */
;;;1964     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1965     {
;;;1966       SPI_RESET_CRC(hspi);
;;;1967     }
;;;1968   #endif /* USE_SPI_CRC */
;;;1969   
;;;1970     /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
;;;1971     if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;1972     {
;;;1973       /* Set the SPI Rx DMA Half transfer complete callback */
;;;1974       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1975       hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
;;;1976     }
;;;1977     else
;;;1978     {
;;;1979       /* Set the SPI Tx/Rx DMA Half transfer complete callback */
;;;1980       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
;;;1981       hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
;;;1982     }
;;;1983   
;;;1984     /* Set the DMA error callback */
;;;1985     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1986   
;;;1987     /* Set the DMA AbortCpltCallback */
;;;1988     hspi->hdmarx->XferAbortCallback = NULL;
;;;1989   
;;;1990     /* Enable the Rx DMA Stream/Channel  */
;;;1991     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;1992                                    hspi->RxXferCount))
;;;1993     {
;;;1994       /* Update SPI error code */
;;;1995       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1996       /* Process Unlocked */
;;;1997       __HAL_UNLOCK(hspi);
;;;1998       return HAL_ERROR;
;;;1999     }
;;;2000   
;;;2001     /* Enable Rx DMA Request */
;;;2002     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;2003   
;;;2004     /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
;;;2005     is performed in DMA reception complete callback  */
;;;2006     hspi->hdmatx->XferHalfCpltCallback = NULL;
;;;2007     hspi->hdmatx->XferCpltCallback     = NULL;
;;;2008     hspi->hdmatx->XferErrorCallback    = NULL;
;;;2009     hspi->hdmatx->XferAbortCallback    = NULL;
;;;2010   
;;;2011     /* Enable the Tx DMA Stream/Channel  */
;;;2012     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;2013                                    hspi->TxXferCount))
;;;2014     {
;;;2015       /* Update SPI error code */
;;;2016       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;2017       /* Process Unlocked */
;;;2018       __HAL_UNLOCK(hspi);
;;;2019       return HAL_ERROR;
;;;2020     }
;;;2021   
;;;2022     /* Check if the SPI is already enabled */
;;;2023     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;2024     {
;;;2025       /* Enable SPI peripheral */
;;;2026       __HAL_SPI_ENABLE(hspi);
;;;2027     }
;;;2028   
;;;2029     /* Process Unlocked */
;;;2030     __HAL_UNLOCK(hspi);
;;;2031   
;;;2032     /* Enable the SPI Error Interrupt Bit */
;;;2033     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;2034   
;;;2035     /* Enable Tx DMA Request */
;;;2036     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;2037   
;;;2038     return HAL_OK;
;;;2039   }
00001e  bd70              POP      {r4-r6,pc}
                  |L22.32|
000020  b1f1              CBZ      r1,|L22.96|
000022  b1ea              CBZ      r2,|L22.96|
000024  b1e3              CBZ      r3,|L22.96|
000026  f8940050          LDRB     r0,[r4,#0x50]         ;1941
00002a  2801              CMP      r0,#1                 ;1941
00002c  d01a              BEQ      |L22.100|
00002e  2001              MOVS     r0,#1                 ;1941
000030  f8840050          STRB     r0,[r4,#0x50]         ;1941
000034  f8940051          LDRB     r0,[r4,#0x51]         ;1944
000038  2804              CMP      r0,#4                 ;1944
00003a  d002              BEQ      |L22.66|
00003c  2005              MOVS     r0,#5                 ;1946
00003e  f8840051          STRB     r0,[r4,#0x51]         ;1946
                  |L22.66|
000042  2500              MOVS     r5,#0                 ;1950
000044  6565              STR      r5,[r4,#0x54]         ;1950
000046  6321              STR      r1,[r4,#0x30]         ;1951
000048  86a3              STRH     r3,[r4,#0x34]         ;1952
00004a  86e3              STRH     r3,[r4,#0x36]         ;1953
00004c  63a2              STR      r2,[r4,#0x38]         ;1954
00004e  87a3              STRH     r3,[r4,#0x3c]         ;1955
000050  87e3              STRH     r3,[r4,#0x3e]         ;1956
000052  6425              STR      r5,[r4,#0x40]         ;1959
000054  6465              STR      r5,[r4,#0x44]         ;1960
000056  6aa0              LDR      r0,[r4,#0x28]         ;1964
000058  f5b05f00          CMP      r0,#0x2000            ;1964
00005c  d004              BEQ      |L22.104|
00005e  e00d              B        |L22.124|
                  |L22.96|
000060  2001              MOVS     r0,#1                 ;1937
000062  bd70              POP      {r4-r6,pc}
                  |L22.100|
000064  2002              MOVS     r0,#2                 ;1941
000066  bd70              POP      {r4-r6,pc}
                  |L22.104|
000068  6820              LDR      r0,[r4,#0]            ;1966
00006a  6801              LDR      r1,[r0,#0]            ;1966
00006c  f4215100          BIC      r1,r1,#0x2000         ;1966
000070  6001              STR      r1,[r0,#0]            ;1966
000072  6820              LDR      r0,[r4,#0]            ;1966
000074  6801              LDR      r1,[r0,#0]            ;1966
000076  f4415100          ORR      r1,r1,#0x2000         ;1966
00007a  6001              STR      r1,[r0,#0]            ;1966
                  |L22.124|
00007c  f8940051          LDRB     r0,[r4,#0x51]         ;1971
000080  2804              CMP      r0,#4                 ;1971
000082  d01a              BEQ      |L22.186|
000084  6ce1              LDR      r1,[r4,#0x4c]         ;1980
000086  482a              LDR      r0,|L22.304|
000088  62c8              STR      r0,[r1,#0x2c]         ;1980
00008a  6ce1              LDR      r1,[r4,#0x4c]         ;1981
00008c  4829              LDR      r0,|L22.308|
00008e  6288              STR      r0,[r1,#0x28]         ;1981
                  |L22.144|
000090  6ce1              LDR      r1,[r4,#0x4c]         ;1985
000092  4829              LDR      r0,|L22.312|
000094  6308              STR      r0,[r1,#0x30]         ;1985
000096  6ce0              LDR      r0,[r4,#0x4c]         ;1988
000098  6345              STR      r5,[r0,#0x34]         ;1988
00009a  8fe3              LDRH     r3,[r4,#0x3e]         ;1991
00009c  6821              LDR      r1,[r4,#0]            ;1991
00009e  6ba2              LDR      r2,[r4,#0x38]         ;1991
0000a0  310c              ADDS     r1,r1,#0xc            ;1991
0000a2  6ce0              LDR      r0,[r4,#0x4c]         ;1991
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  b170              CBZ      r0,|L22.200|
0000aa  6d60              LDR      r0,[r4,#0x54]         ;1995
0000ac  f0400010          ORR      r0,r0,#0x10           ;1995
0000b0  6560              STR      r0,[r4,#0x54]         ;1995
0000b2  f8845050          STRB     r5,[r4,#0x50]         ;1997
0000b6  2001              MOVS     r0,#1                 ;1998
0000b8  bd70              POP      {r4-r6,pc}
                  |L22.186|
0000ba  6ce1              LDR      r1,[r4,#0x4c]         ;1974
0000bc  481f              LDR      r0,|L22.316|
0000be  62c8              STR      r0,[r1,#0x2c]         ;1974
0000c0  6ce1              LDR      r1,[r4,#0x4c]         ;1975
0000c2  481f              LDR      r0,|L22.320|
0000c4  6288              STR      r0,[r1,#0x28]         ;1975
0000c6  e7e3              B        |L22.144|
                  |L22.200|
0000c8  6820              LDR      r0,[r4,#0]            ;2002
0000ca  6841              LDR      r1,[r0,#4]            ;2002
0000cc  f0410101          ORR      r1,r1,#1              ;2002
0000d0  6041              STR      r1,[r0,#4]            ;2002
0000d2  6ca0              LDR      r0,[r4,#0x48]         ;2006
0000d4  62c5              STR      r5,[r0,#0x2c]         ;2006
0000d6  6ca0              LDR      r0,[r4,#0x48]         ;2007
0000d8  6285              STR      r5,[r0,#0x28]         ;2007
0000da  6ca0              LDR      r0,[r4,#0x48]         ;2008
0000dc  6305              STR      r5,[r0,#0x30]         ;2008
0000de  6ca0              LDR      r0,[r4,#0x48]         ;2009
0000e0  6345              STR      r5,[r0,#0x34]         ;2009
0000e2  8ee3              LDRH     r3,[r4,#0x36]         ;2012
0000e4  6822              LDR      r2,[r4,#0]            ;2012
0000e6  6b21              LDR      r1,[r4,#0x30]         ;2012
0000e8  320c              ADDS     r2,r2,#0xc            ;2012
0000ea  6ca0              LDR      r0,[r4,#0x48]         ;2012
0000ec  f7fffffe          BL       HAL_DMA_Start_IT
0000f0  b138              CBZ      r0,|L22.258|
0000f2  6d60              LDR      r0,[r4,#0x54]         ;2016
0000f4  f0400010          ORR      r0,r0,#0x10           ;2016
0000f8  6560              STR      r0,[r4,#0x54]         ;2016
0000fa  f8845050          STRB     r5,[r4,#0x50]         ;2018
0000fe  2001              MOVS     r0,#1                 ;2019
000100  bd70              POP      {r4-r6,pc}
                  |L22.258|
000102  6820              LDR      r0,[r4,#0]            ;2023
000104  6801              LDR      r1,[r0,#0]            ;2023
000106  0649              LSLS     r1,r1,#25             ;2023
000108  d403              BMI      |L22.274|
00010a  6801              LDR      r1,[r0,#0]            ;2026
00010c  f0410140          ORR      r1,r1,#0x40           ;2026
000110  6001              STR      r1,[r0,#0]            ;2026
                  |L22.274|
000112  f8845050          STRB     r5,[r4,#0x50]         ;2030
000116  6820              LDR      r0,[r4,#0]            ;2033
000118  6841              LDR      r1,[r0,#4]            ;2033
00011a  f0410120          ORR      r1,r1,#0x20           ;2033
00011e  6041              STR      r1,[r0,#4]            ;2033
000120  6820              LDR      r0,[r4,#0]            ;2036
000122  6841              LDR      r1,[r0,#4]            ;2036
000124  f0410102          ORR      r1,r1,#2              ;2036
000128  6041              STR      r1,[r0,#4]            ;2036
00012a  2000              MOVS     r0,#0                 ;2038
00012c  bd70              POP      {r4-r6,pc}
;;;2040   
                          ENDP

00012e  0000              DCW      0x0000
                  |L22.304|
                          DCD      SPI_DMAHalfTransmitReceiveCplt
                  |L22.308|
                          DCD      SPI_DMATransmitReceiveCplt
                  |L22.312|
                          DCD      SPI_DMAError
                  |L22.316|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L22.320|
                          DCD      SPI_DMAReceiveCplt

                          AREA ||i.HAL_SPI_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_IT PROC
;;;1609     */
;;;1610   HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, const uint8_t *pTxData, uint8_t *pRxData,
000000  b530              PUSH     {r4,r5,lr}
;;;1611                                                uint16_t Size)
;;;1612   {
;;;1613     uint32_t             tmp_mode;
;;;1614     HAL_SPI_StateTypeDef tmp_state;
;;;1615   
;;;1616     /* Check Direction parameter */
;;;1617     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
;;;1618   
;;;1619     /* Init temporary variables */
;;;1620     tmp_state           = hspi->State;
000002  f8904051          LDRB     r4,[r0,#0x51]
;;;1621     tmp_mode            = hspi->Init.Mode;
000006  6845              LDR      r5,[r0,#4]
;;;1622   
;;;1623     if (!((tmp_state == HAL_SPI_STATE_READY) || \
000008  2c01              CMP      r4,#1
00000a  d008              BEQ      |L23.30|
00000c  f5b57f82          CMP      r5,#0x104
000010  d103              BNE      |L23.26|
000012  6885              LDR      r5,[r0,#8]
000014  b90d              CBNZ     r5,|L23.26|
000016  2c04              CMP      r4,#4
000018  d001              BEQ      |L23.30|
                  |L23.26|
;;;1624           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) &&
;;;1625            (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1626     {
;;;1627       return HAL_BUSY;
00001a  2002              MOVS     r0,#2
;;;1628     }
;;;1629   
;;;1630     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1631     {
;;;1632       return HAL_ERROR;
;;;1633     }
;;;1634   
;;;1635     /* Process locked */
;;;1636     __HAL_LOCK(hspi);
;;;1637   
;;;1638     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1639     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1640     {
;;;1641       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1642     }
;;;1643   
;;;1644     /* Set the transaction information */
;;;1645     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1646     hspi->pTxBuffPtr  = (const uint8_t *)pTxData;
;;;1647     hspi->TxXferSize  = Size;
;;;1648     hspi->TxXferCount = Size;
;;;1649     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1650     hspi->RxXferSize  = Size;
;;;1651     hspi->RxXferCount = Size;
;;;1652   
;;;1653     /* Set the function for IT treatment */
;;;1654     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1655     {
;;;1656       hspi->RxISR     = SPI_2linesRxISR_16BIT;
;;;1657       hspi->TxISR     = SPI_2linesTxISR_16BIT;
;;;1658     }
;;;1659     else
;;;1660     {
;;;1661       hspi->RxISR     = SPI_2linesRxISR_8BIT;
;;;1662       hspi->TxISR     = SPI_2linesTxISR_8BIT;
;;;1663     }
;;;1664   
;;;1665   #if (USE_SPI_CRC != 0U)
;;;1666     /* Reset CRC Calculation */
;;;1667     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1668     {
;;;1669       SPI_RESET_CRC(hspi);
;;;1670     }
;;;1671   #endif /* USE_SPI_CRC */
;;;1672   
;;;1673   
;;;1674     /* Check if the SPI is already enabled */
;;;1675     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1676     {
;;;1677       /* Enable SPI peripheral */
;;;1678       __HAL_SPI_ENABLE(hspi);
;;;1679     }
;;;1680   
;;;1681     /* Process Unlocked */
;;;1682     __HAL_UNLOCK(hspi);
;;;1683     /* Enable TXE, RXNE and ERR interrupt */
;;;1684     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;1685   
;;;1686     return HAL_OK;
;;;1687   }
00001c  bd30              POP      {r4,r5,pc}
                  |L23.30|
00001e  b1f1              CBZ      r1,|L23.94|
000020  b1ea              CBZ      r2,|L23.94|
000022  b1e3              CBZ      r3,|L23.94|
000024  f8904050          LDRB     r4,[r0,#0x50]         ;1636
000028  2c01              CMP      r4,#1                 ;1636
00002a  d01a              BEQ      |L23.98|
00002c  2401              MOVS     r4,#1                 ;1636
00002e  f8804050          STRB     r4,[r0,#0x50]         ;1636
000032  f8904051          LDRB     r4,[r0,#0x51]         ;1639
000036  2c04              CMP      r4,#4                 ;1639
000038  d002              BEQ      |L23.64|
00003a  2405              MOVS     r4,#5                 ;1641
00003c  f8804051          STRB     r4,[r0,#0x51]         ;1641
                  |L23.64|
000040  2400              MOVS     r4,#0                 ;1645
000042  6544              STR      r4,[r0,#0x54]         ;1645
000044  6301              STR      r1,[r0,#0x30]         ;1646
000046  8683              STRH     r3,[r0,#0x34]         ;1647
000048  86c3              STRH     r3,[r0,#0x36]         ;1648
00004a  6382              STR      r2,[r0,#0x38]         ;1649
00004c  8783              STRH     r3,[r0,#0x3c]         ;1650
00004e  87c3              STRH     r3,[r0,#0x3e]         ;1651
000050  68c1              LDR      r1,[r0,#0xc]          ;1654
000052  b141              CBZ      r1,|L23.102|
000054  4915              LDR      r1,|L23.172|
000056  6401              STR      r1,[r0,#0x40]         ;1656
000058  4915              LDR      r1,|L23.176|
00005a  6441              STR      r1,[r0,#0x44]         ;1657
00005c  e007              B        |L23.110|
                  |L23.94|
00005e  2001              MOVS     r0,#1                 ;1632
000060  bd30              POP      {r4,r5,pc}
                  |L23.98|
000062  2002              MOVS     r0,#2                 ;1636
000064  bd30              POP      {r4,r5,pc}
                  |L23.102|
000066  4913              LDR      r1,|L23.180|
000068  6401              STR      r1,[r0,#0x40]         ;1661
00006a  4913              LDR      r1,|L23.184|
00006c  6441              STR      r1,[r0,#0x44]         ;1662
                  |L23.110|
00006e  6a81              LDR      r1,[r0,#0x28]         ;1667
000070  f5b15f00          CMP      r1,#0x2000            ;1667
000074  d109              BNE      |L23.138|
000076  6801              LDR      r1,[r0,#0]            ;1669
000078  680a              LDR      r2,[r1,#0]            ;1669
00007a  f4225200          BIC      r2,r2,#0x2000         ;1669
00007e  600a              STR      r2,[r1,#0]            ;1669
000080  6801              LDR      r1,[r0,#0]            ;1669
000082  680a              LDR      r2,[r1,#0]            ;1669
000084  f4425200          ORR      r2,r2,#0x2000         ;1669
000088  600a              STR      r2,[r1,#0]            ;1669
                  |L23.138|
00008a  6801              LDR      r1,[r0,#0]            ;1675
00008c  680a              LDR      r2,[r1,#0]            ;1675
00008e  0652              LSLS     r2,r2,#25             ;1675
000090  d403              BMI      |L23.154|
000092  680a              LDR      r2,[r1,#0]            ;1678
000094  f0420240          ORR      r2,r2,#0x40           ;1678
000098  600a              STR      r2,[r1,#0]            ;1678
                  |L23.154|
00009a  f8804050          STRB     r4,[r0,#0x50]         ;1682
00009e  6800              LDR      r0,[r0,#0]            ;1684
0000a0  6841              LDR      r1,[r0,#4]            ;1684
0000a2  f04101e0          ORR      r1,r1,#0xe0           ;1684
0000a6  6041              STR      r1,[r0,#4]            ;1684
0000a8  2000              MOVS     r0,#0                 ;1686
0000aa  bd30              POP      {r4,r5,pc}
;;;1688   
                          ENDP

                  |L23.172|
                          DCD      SPI_2linesRxISR_16BIT
                  |L23.176|
                          DCD      SPI_2linesTxISR_16BIT
                  |L23.180|
                          DCD      SPI_2linesRxISR_8BIT
                  |L23.184|
                          DCD      SPI_2linesTxISR_8BIT

                          AREA ||i.HAL_SPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_DMA PROC
;;;1696     */
;;;1697   HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, const uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1698   {
000002  4604              MOV      r4,r0
;;;1699   
;;;1700     /* Check tx dma handle */
;;;1701     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
;;;1702   
;;;1703     /* Check Direction parameter */
;;;1704     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1705   
;;;1706     if (hspi->State != HAL_SPI_STATE_READY)
000004  f8940051          LDRB     r0,[r4,#0x51]
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L24.16|
;;;1707     {
;;;1708       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1709     }
;;;1710   
;;;1711     if ((pData == NULL) || (Size == 0U))
;;;1712     {
;;;1713       return HAL_ERROR;
;;;1714     }
;;;1715   
;;;1716     /* Process Locked */
;;;1717     __HAL_LOCK(hspi);
;;;1718   
;;;1719     /* Set the transaction information */
;;;1720     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1721     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1722     hspi->pTxBuffPtr  = (const uint8_t *)pData;
;;;1723     hspi->TxXferSize  = Size;
;;;1724     hspi->TxXferCount = Size;
;;;1725   
;;;1726     /* Init field not used in handle to zero */
;;;1727     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1728     hspi->TxISR       = NULL;
;;;1729     hspi->RxISR       = NULL;
;;;1730     hspi->RxXferSize  = 0U;
;;;1731     hspi->RxXferCount = 0U;
;;;1732   
;;;1733     /* Configure communication direction : 1Line */
;;;1734     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1735     {
;;;1736       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1737       __HAL_SPI_DISABLE(hspi);
;;;1738       SPI_1LINE_TX(hspi);
;;;1739     }
;;;1740   
;;;1741   #if (USE_SPI_CRC != 0U)
;;;1742     /* Reset CRC Calculation */
;;;1743     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1744     {
;;;1745       SPI_RESET_CRC(hspi);
;;;1746     }
;;;1747   #endif /* USE_SPI_CRC */
;;;1748   
;;;1749     /* Set the SPI TxDMA Half transfer complete callback */
;;;1750     hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
;;;1751   
;;;1752     /* Set the SPI TxDMA transfer complete callback */
;;;1753     hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
;;;1754   
;;;1755     /* Set the DMA error callback */
;;;1756     hspi->hdmatx->XferErrorCallback = SPI_DMAError;
;;;1757   
;;;1758     /* Set the DMA AbortCpltCallback */
;;;1759     hspi->hdmatx->XferAbortCallback = NULL;
;;;1760   
;;;1761     /* Enable the Tx DMA Stream/Channel */
;;;1762     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;1763                                    hspi->TxXferCount))
;;;1764     {
;;;1765       /* Update SPI error code */
;;;1766       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1767       /* Process Unlocked */
;;;1768       __HAL_UNLOCK(hspi);
;;;1769       return HAL_ERROR;
;;;1770     }
;;;1771   
;;;1772     /* Check if the SPI is already enabled */
;;;1773     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1774     {
;;;1775       /* Enable SPI peripheral */
;;;1776       __HAL_SPI_ENABLE(hspi);
;;;1777     }
;;;1778   
;;;1779     /* Process Unlocked */
;;;1780     __HAL_UNLOCK(hspi);
;;;1781   
;;;1782     /* Enable the SPI Error Interrupt Bit */
;;;1783     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1784   
;;;1785     /* Enable Tx DMA Request */
;;;1786     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1787   
;;;1788     return HAL_OK;
;;;1789   }
00000e  bd70              POP      {r4-r6,pc}
                  |L24.16|
000010  b1c9              CBZ      r1,|L24.70|
000012  b1c2              CBZ      r2,|L24.70|
000014  f8940050          LDRB     r0,[r4,#0x50]         ;1717
000018  2801              CMP      r0,#1                 ;1717
00001a  d016              BEQ      |L24.74|
00001c  2001              MOVS     r0,#1                 ;1717
00001e  f8840050          STRB     r0,[r4,#0x50]         ;1717
000022  2003              MOVS     r0,#3                 ;1720
000024  f8840051          STRB     r0,[r4,#0x51]         ;1720
000028  2500              MOVS     r5,#0                 ;1721
00002a  6565              STR      r5,[r4,#0x54]         ;1721
00002c  6321              STR      r1,[r4,#0x30]         ;1722
00002e  86a2              STRH     r2,[r4,#0x34]         ;1723
000030  86e2              STRH     r2,[r4,#0x36]         ;1724
000032  63a5              STR      r5,[r4,#0x38]         ;1727
000034  6465              STR      r5,[r4,#0x44]         ;1728
000036  6425              STR      r5,[r4,#0x40]         ;1729
000038  87a5              STRH     r5,[r4,#0x3c]         ;1730
00003a  87e5              STRH     r5,[r4,#0x3e]         ;1731
00003c  68a0              LDR      r0,[r4,#8]            ;1734
00003e  f5b04f00          CMP      r0,#0x8000            ;1734
000042  d004              BEQ      |L24.78|
000044  e00d              B        |L24.98|
                  |L24.70|
000046  2001              MOVS     r0,#1                 ;1713
000048  bd70              POP      {r4-r6,pc}
                  |L24.74|
00004a  2002              MOVS     r0,#2                 ;1717
00004c  bd70              POP      {r4-r6,pc}
                  |L24.78|
00004e  6820              LDR      r0,[r4,#0]            ;1737
000050  6801              LDR      r1,[r0,#0]            ;1737
000052  f0210140          BIC      r1,r1,#0x40           ;1737
000056  6001              STR      r1,[r0,#0]            ;1737
000058  6820              LDR      r0,[r4,#0]            ;1738
00005a  6801              LDR      r1,[r0,#0]            ;1738
00005c  f4414180          ORR      r1,r1,#0x4000         ;1738
000060  6001              STR      r1,[r0,#0]            ;1738
                  |L24.98|
000062  6aa0              LDR      r0,[r4,#0x28]         ;1743
000064  f5b05f00          CMP      r0,#0x2000            ;1743
000068  d109              BNE      |L24.126|
00006a  6820              LDR      r0,[r4,#0]            ;1745
00006c  6801              LDR      r1,[r0,#0]            ;1745
00006e  f4215100          BIC      r1,r1,#0x2000         ;1745
000072  6001              STR      r1,[r0,#0]            ;1745
000074  6820              LDR      r0,[r4,#0]            ;1745
000076  6801              LDR      r1,[r0,#0]            ;1745
000078  f4415100          ORR      r1,r1,#0x2000         ;1745
00007c  6001              STR      r1,[r0,#0]            ;1745
                  |L24.126|
00007e  6ca1              LDR      r1,[r4,#0x48]         ;1750
000080  4817              LDR      r0,|L24.224|
000082  62c8              STR      r0,[r1,#0x2c]         ;1750
000084  6ca1              LDR      r1,[r4,#0x48]         ;1753
000086  4817              LDR      r0,|L24.228|
000088  6288              STR      r0,[r1,#0x28]         ;1753
00008a  6ca1              LDR      r1,[r4,#0x48]         ;1756
00008c  4816              LDR      r0,|L24.232|
00008e  6308              STR      r0,[r1,#0x30]         ;1756
000090  6ca0              LDR      r0,[r4,#0x48]         ;1759
000092  6345              STR      r5,[r0,#0x34]         ;1759
000094  8ee3              LDRH     r3,[r4,#0x36]         ;1762
000096  6822              LDR      r2,[r4,#0]            ;1762
000098  6b21              LDR      r1,[r4,#0x30]         ;1762
00009a  320c              ADDS     r2,r2,#0xc            ;1762
00009c  6ca0              LDR      r0,[r4,#0x48]         ;1762
00009e  f7fffffe          BL       HAL_DMA_Start_IT
0000a2  b138              CBZ      r0,|L24.180|
0000a4  6d60              LDR      r0,[r4,#0x54]         ;1766
0000a6  f0400010          ORR      r0,r0,#0x10           ;1766
0000aa  6560              STR      r0,[r4,#0x54]         ;1766
0000ac  f8845050          STRB     r5,[r4,#0x50]         ;1768
0000b0  2001              MOVS     r0,#1                 ;1769
0000b2  bd70              POP      {r4-r6,pc}
                  |L24.180|
0000b4  6820              LDR      r0,[r4,#0]            ;1773
0000b6  6801              LDR      r1,[r0,#0]            ;1773
0000b8  0649              LSLS     r1,r1,#25             ;1773
0000ba  d403              BMI      |L24.196|
0000bc  6801              LDR      r1,[r0,#0]            ;1776
0000be  f0410140          ORR      r1,r1,#0x40           ;1776
0000c2  6001              STR      r1,[r0,#0]            ;1776
                  |L24.196|
0000c4  f8845050          STRB     r5,[r4,#0x50]         ;1780
0000c8  6820              LDR      r0,[r4,#0]            ;1783
0000ca  6841              LDR      r1,[r0,#4]            ;1783
0000cc  f0410120          ORR      r1,r1,#0x20           ;1783
0000d0  6041              STR      r1,[r0,#4]            ;1783
0000d2  6820              LDR      r0,[r4,#0]            ;1786
0000d4  6841              LDR      r1,[r0,#4]            ;1786
0000d6  f0410102          ORR      r1,r1,#2              ;1786
0000da  6041              STR      r1,[r0,#4]            ;1786
0000dc  2000              MOVS     r0,#0                 ;1788
0000de  bd70              POP      {r4-r6,pc}
;;;1790   
                          ENDP

                  |L24.224|
                          DCD      SPI_DMAHalfTransmitCplt
                  |L24.228|
                          DCD      SPI_DMATransmitCplt
                  |L24.232|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_IT PROC
;;;1436     */
;;;1437   HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, const uint8_t *pData, uint16_t Size)
000000  2900              CMP      r1,#0
;;;1438   {
000002  d006              BEQ      |L25.18|
;;;1439   
;;;1440     /* Check Direction parameter */
;;;1441     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
;;;1442   
;;;1443   
;;;1444     if ((pData == NULL) || (Size == 0U))
000004  b12a              CBZ      r2,|L25.18|
;;;1445     {
;;;1446       return HAL_ERROR;
;;;1447     }
;;;1448   
;;;1449     if (hspi->State != HAL_SPI_STATE_READY)
000006  f8903051          LDRB     r3,[r0,#0x51]
00000a  2b01              CMP      r3,#1
00000c  d003              BEQ      |L25.22|
;;;1450     {
;;;1451       return HAL_BUSY;
00000e  2002              MOVS     r0,#2
;;;1452     }
;;;1453   
;;;1454     /* Process Locked */
;;;1455     __HAL_LOCK(hspi);
;;;1456   
;;;1457     /* Set the transaction information */
;;;1458     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1459     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1460     hspi->pTxBuffPtr  = (const uint8_t *)pData;
;;;1461     hspi->TxXferSize  = Size;
;;;1462     hspi->TxXferCount = Size;
;;;1463   
;;;1464     /* Init field not used in handle to zero */
;;;1465     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1466     hspi->RxXferSize  = 0U;
;;;1467     hspi->RxXferCount = 0U;
;;;1468     hspi->RxISR       = NULL;
;;;1469   
;;;1470     /* Set the function for IT treatment */
;;;1471     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1472     {
;;;1473       hspi->TxISR = SPI_TxISR_16BIT;
;;;1474     }
;;;1475     else
;;;1476     {
;;;1477       hspi->TxISR = SPI_TxISR_8BIT;
;;;1478     }
;;;1479   
;;;1480     /* Configure communication direction : 1Line */
;;;1481     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1482     {
;;;1483       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1484       __HAL_SPI_DISABLE(hspi);
;;;1485       SPI_1LINE_TX(hspi);
;;;1486     }
;;;1487   
;;;1488   #if (USE_SPI_CRC != 0U)
;;;1489     /* Reset CRC Calculation */
;;;1490     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1491     {
;;;1492       SPI_RESET_CRC(hspi);
;;;1493     }
;;;1494   #endif /* USE_SPI_CRC */
;;;1495   
;;;1496     /* Check if the SPI is already enabled */
;;;1497     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1498     {
;;;1499       /* Enable SPI peripheral */
;;;1500       __HAL_SPI_ENABLE(hspi);
;;;1501     }
;;;1502   
;;;1503     /* Process Unlocked */
;;;1504     __HAL_UNLOCK(hspi);
;;;1505     /* Enable TXE and ERR interrupt */
;;;1506     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
;;;1507   
;;;1508     return HAL_OK;
;;;1509   }
000010  4770              BX       lr
                  |L25.18|
000012  2001              MOVS     r0,#1                 ;1446
000014  4770              BX       lr
                  |L25.22|
000016  f8903050          LDRB     r3,[r0,#0x50]         ;1455
00001a  2b01              CMP      r3,#1                 ;1455
00001c  d013              BEQ      |L25.70|
00001e  2301              MOVS     r3,#1                 ;1455
000020  f8803050          STRB     r3,[r0,#0x50]         ;1455
000024  2303              MOVS     r3,#3                 ;1458
000026  f8803051          STRB     r3,[r0,#0x51]         ;1458
00002a  2300              MOVS     r3,#0                 ;1459
00002c  6543              STR      r3,[r0,#0x54]         ;1459
00002e  6301              STR      r1,[r0,#0x30]         ;1460
000030  8682              STRH     r2,[r0,#0x34]         ;1461
000032  86c2              STRH     r2,[r0,#0x36]         ;1462
000034  6383              STR      r3,[r0,#0x38]         ;1465
000036  8783              STRH     r3,[r0,#0x3c]         ;1466
000038  87c3              STRH     r3,[r0,#0x3e]         ;1467
00003a  6403              STR      r3,[r0,#0x40]         ;1468
00003c  68c1              LDR      r1,[r0,#0xc]          ;1455
00003e  b121              CBZ      r1,|L25.74|
000040  4919              LDR      r1,|L25.168|
000042  6441              STR      r1,[r0,#0x44]         ;1473
000044  e003              B        |L25.78|
                  |L25.70|
000046  2002              MOVS     r0,#2                 ;1455
000048  4770              BX       lr
                  |L25.74|
00004a  4918              LDR      r1,|L25.172|
00004c  6441              STR      r1,[r0,#0x44]         ;1477
                  |L25.78|
00004e  6881              LDR      r1,[r0,#8]            ;1481
000050  f5b14f00          CMP      r1,#0x8000            ;1481
000054  d109              BNE      |L25.106|
000056  6801              LDR      r1,[r0,#0]            ;1484
000058  680a              LDR      r2,[r1,#0]            ;1484
00005a  f0220240          BIC      r2,r2,#0x40           ;1484
00005e  600a              STR      r2,[r1,#0]            ;1484
000060  6801              LDR      r1,[r0,#0]            ;1485
000062  680a              LDR      r2,[r1,#0]            ;1485
000064  f4424280          ORR      r2,r2,#0x4000         ;1485
000068  600a              STR      r2,[r1,#0]            ;1485
                  |L25.106|
00006a  6a81              LDR      r1,[r0,#0x28]         ;1490
00006c  f5b15f00          CMP      r1,#0x2000            ;1490
000070  d109              BNE      |L25.134|
000072  6801              LDR      r1,[r0,#0]            ;1492
000074  680a              LDR      r2,[r1,#0]            ;1492
000076  f4225200          BIC      r2,r2,#0x2000         ;1492
00007a  600a              STR      r2,[r1,#0]            ;1492
00007c  6801              LDR      r1,[r0,#0]            ;1492
00007e  680a              LDR      r2,[r1,#0]            ;1492
000080  f4425200          ORR      r2,r2,#0x2000         ;1492
000084  600a              STR      r2,[r1,#0]            ;1492
                  |L25.134|
000086  6801              LDR      r1,[r0,#0]            ;1497
000088  680a              LDR      r2,[r1,#0]            ;1497
00008a  0652              LSLS     r2,r2,#25             ;1497
00008c  d403              BMI      |L25.150|
00008e  680a              LDR      r2,[r1,#0]            ;1500
000090  f0420240          ORR      r2,r2,#0x40           ;1500
000094  600a              STR      r2,[r1,#0]            ;1500
                  |L25.150|
000096  f8803050          STRB     r3,[r0,#0x50]         ;1504
00009a  6800              LDR      r0,[r0,#0]            ;1506
00009c  6841              LDR      r1,[r0,#4]            ;1506
00009e  f04101a0          ORR      r1,r1,#0xa0           ;1506
0000a2  6041              STR      r1,[r0,#4]            ;1506
0000a4  2000              MOVS     r0,#0                 ;1508
0000a6  4770              BX       lr
;;;1510   
                          ENDP

                  |L25.168|
                          DCD      SPI_TxISR_16BIT
                  |L25.172|
                          DCD      SPI_TxISR_8BIT

                          AREA ||i.HAL_SPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxCpltCallback PROC
;;;2541     */
;;;2542   __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2543   {
;;;2544     /* Prevent unused argument(s) compilation warning */
;;;2545     UNUSED(hspi);
;;;2546   
;;;2547     /* NOTE : This function should not be modified, when the callback is needed,
;;;2548               the HAL_SPI_TxCpltCallback should be implemented in the user file
;;;2549      */
;;;2550   }
;;;2551   
                          ENDP


                          AREA ||i.HAL_SPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxHalfCpltCallback PROC
;;;2589     */
;;;2590   __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2591   {
;;;2592     /* Prevent unused argument(s) compilation warning */
;;;2593     UNUSED(hspi);
;;;2594   
;;;2595     /* NOTE : This function should not be modified, when the callback is needed,
;;;2596               the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
;;;2597      */
;;;2598   }
;;;2599   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxCpltCallback PROC
;;;2573     */
;;;2574   __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2575   {
;;;2576     /* Prevent unused argument(s) compilation warning */
;;;2577     UNUSED(hspi);
;;;2578   
;;;2579     /* NOTE : This function should not be modified, when the callback is needed,
;;;2580               the HAL_SPI_TxRxCpltCallback should be implemented in the user file
;;;2581      */
;;;2582   }
;;;2583   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxHalfCpltCallback PROC
;;;2621     */
;;;2622   __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2623   {
;;;2624     /* Prevent unused argument(s) compilation warning */
;;;2625     UNUSED(hspi);
;;;2626   
;;;2627     /* NOTE : This function should not be modified, when the callback is needed,
;;;2628               the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
;;;2629      */
;;;2630   }
;;;2631   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_16BIT||, CODE, READONLY, ALIGN=2

                  SPI_2linesRxISR_16BIT PROC
;;;3293     */
;;;3294   static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3295   {
;;;3296     /* Receive data in 16 Bit mode */
;;;3297     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000002  68c9              LDR      r1,[r1,#0xc]
000004  6b82              LDR      r2,[r0,#0x38]
000006  8011              STRH     r1,[r2,#0]
;;;3298     hspi->pRxBuffPtr += sizeof(uint16_t);
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c89              ADDS     r1,r1,#2
00000c  6381              STR      r1,[r0,#0x38]
;;;3299     hspi->RxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3300   
;;;3301     if (hspi->RxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d10f              BNE      |L30.58|
;;;3302     {
;;;3303   #if (USE_SPI_CRC != 0U)
;;;3304       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d009              BEQ      |L30.54|
;;;3305       {
;;;3306         hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
;;;3307         return;
;;;3308       }
;;;3309   #endif /* USE_SPI_CRC */
;;;3310   
;;;3311       /* Disable RXNE interrupt */
;;;3312       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f0220240          BIC      r2,r2,#0x40
00002a  604a              STR      r2,[r1,#4]
;;;3313   
;;;3314       if (hspi->TxXferCount == 0U)
00002c  8ec1              LDRH     r1,[r0,#0x36]
00002e  2900              CMP      r1,#0
000030  d103              BNE      |L30.58|
;;;3315       {
;;;3316         SPI_CloseRxTx_ISR(hspi);
000032  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L30.54|
000036  4901              LDR      r1,|L30.60|
000038  6401              STR      r1,[r0,#0x40]         ;3306
                  |L30.58|
;;;3317       }
;;;3318     }
;;;3319   }
00003a  4770              BX       lr
;;;3320   
                          ENDP

                  |L30.60|
                          DCD      SPI_2linesRxISR_16BITCRC

                          AREA ||i.SPI_2linesRxISR_16BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_16BITCRC PROC
;;;3327     */
;;;3328   static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3329   {
;;;3330     __IO uint32_t tmpreg = 0U;
;;;3331   
;;;3332     /* Read 16bit CRC to flush Data Register */
;;;3333     tmpreg = READ_REG(hspi->Instance->DR);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  9201              STR      r2,[sp,#4]
;;;3334     /* To avoid GCC warning */
;;;3335     UNUSED(tmpreg);
;;;3336   
;;;3337     /* Disable RXNE interrupt */
;;;3338     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
000008  684a              LDR      r2,[r1,#4]
00000a  f0220240          BIC      r2,r2,#0x40
00000e  604a              STR      r2,[r1,#4]
;;;3339   
;;;3340     SPI_CloseRxTx_ISR(hspi);
000010  b002              ADD      sp,sp,#8
000012  f7ffbffe          B.W      SPI_CloseRxTx_ISR
;;;3341   }
;;;3342   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_2linesRxISR_8BIT||, CODE, READONLY, ALIGN=2

                  SPI_2linesRxISR_8BIT PROC
;;;3194     */
;;;3195   static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3196   {
;;;3197     /* Receive data in 8bit mode */
;;;3198     *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
000002  7b09              LDRB     r1,[r1,#0xc]
000004  6b82              LDR      r2,[r0,#0x38]
000006  7011              STRB     r1,[r2,#0]
;;;3199     hspi->pRxBuffPtr++;
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c49              ADDS     r1,r1,#1
00000c  6381              STR      r1,[r0,#0x38]
;;;3200     hspi->RxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3201   
;;;3202     /* Check end of the reception */
;;;3203     if (hspi->RxXferCount == 0U)
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  2900              CMP      r1,#0
000018  d10f              BNE      |L32.58|
;;;3204     {
;;;3205   #if (USE_SPI_CRC != 0U)
;;;3206       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d009              BEQ      |L32.54|
;;;3207       {
;;;3208         hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
;;;3209         return;
;;;3210       }
;;;3211   #endif /* USE_SPI_CRC */
;;;3212   
;;;3213       /* Disable RXNE  and ERR interrupt */
;;;3214       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f0220260          BIC      r2,r2,#0x60
00002a  604a              STR      r2,[r1,#4]
;;;3215   
;;;3216       if (hspi->TxXferCount == 0U)
00002c  8ec1              LDRH     r1,[r0,#0x36]
00002e  2900              CMP      r1,#0
000030  d103              BNE      |L32.58|
;;;3217       {
;;;3218         SPI_CloseRxTx_ISR(hspi);
000032  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L32.54|
000036  4901              LDR      r1,|L32.60|
000038  6401              STR      r1,[r0,#0x40]         ;3208
                  |L32.58|
;;;3219       }
;;;3220     }
;;;3221   }
00003a  4770              BX       lr
;;;3222   
                          ENDP

                  |L32.60|
                          DCD      SPI_2linesRxISR_8BITCRC

                          AREA ||i.SPI_2linesRxISR_8BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_8BITCRC PROC
;;;3229     */
;;;3230   static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3231   {
;;;3232     __IO uint8_t  *ptmpreg8;
;;;3233     __IO uint8_t  tmpreg8 = 0;
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
;;;3234   
;;;3235     /* Initialize the 8bit temporary pointer */
;;;3236     ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
000006  6801              LDR      r1,[r0,#0]
000008  f101020c          ADD      r2,r1,#0xc
;;;3237     /* Read 8bit CRC to flush Data Register */
;;;3238     tmpreg8 = *ptmpreg8;
00000c  7812              LDRB     r2,[r2,#0]
00000e  9201              STR      r2,[sp,#4]
;;;3239     /* To avoid GCC warning */
;;;3240     UNUSED(tmpreg8);
000010  f89d2004          LDRB     r2,[sp,#4]
;;;3241   
;;;3242     /* Disable RXNE and ERR interrupt */
;;;3243     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000014  684a              LDR      r2,[r1,#4]
000016  f0220260          BIC      r2,r2,#0x60
00001a  604a              STR      r2,[r1,#4]
;;;3244   
;;;3245     if (hspi->TxXferCount == 0U)
00001c  8ec1              LDRH     r1,[r0,#0x36]
00001e  2900              CMP      r1,#0
000020  d102              BNE      |L33.40|
;;;3246     {
;;;3247       SPI_CloseRxTx_ISR(hspi);
000022  b002              ADD      sp,sp,#8
000024  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L33.40|
;;;3248     }
;;;3249   }
000028  b002              ADD      sp,sp,#8
00002a  4770              BX       lr
;;;3250   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_2linesTxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_16BIT PROC
;;;3349     */
;;;3350   static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;3351   {
;;;3352     /* Transmit data in 16 Bit mode */
;;;3353     hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  8809              LDRH     r1,[r1,#0]
000006  60d1              STR      r1,[r2,#0xc]
;;;3354     hspi->pTxBuffPtr += sizeof(uint16_t);
000008  6b01              LDR      r1,[r0,#0x30]
00000a  1c89              ADDS     r1,r1,#2
00000c  6301              STR      r1,[r0,#0x30]
;;;3355     hspi->TxXferCount--;
00000e  8ec1              LDRH     r1,[r0,#0x36]
000010  1e49              SUBS     r1,r1,#1
000012  86c1              STRH     r1,[r0,#0x36]
;;;3356   
;;;3357     /* Enable CRC Transmission */
;;;3358     if (hspi->TxXferCount == 0U)
000014  8ec1              LDRH     r1,[r0,#0x36]
000016  2900              CMP      r1,#0
000018  d117              BNE      |L34.74|
;;;3359     {
;;;3360   #if (USE_SPI_CRC != 0U)
;;;3361       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d009              BEQ      |L34.54|
;;;3362       {
;;;3363         /* Set CRC Next Bit to send CRC */
;;;3364         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3365         /* Disable TXE interrupt */
;;;3366         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3367         return;
;;;3368       }
;;;3369   #endif /* USE_SPI_CRC */
;;;3370   
;;;3371       /* Disable TXE interrupt */
;;;3372       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f0220280          BIC      r2,r2,#0x80
00002a  604a              STR      r2,[r1,#4]
;;;3373   
;;;3374       if (hspi->RxXferCount == 0U)
00002c  8fc1              LDRH     r1,[r0,#0x3e]
00002e  2900              CMP      r1,#0
000030  d10b              BNE      |L34.74|
;;;3375       {
;;;3376         SPI_CloseRxTx_ISR(hspi);
000032  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L34.54|
000036  6801              LDR      r1,[r0,#0]            ;3364
000038  680a              LDR      r2,[r1,#0]            ;3364
00003a  f4425280          ORR      r2,r2,#0x1000         ;3364
00003e  600a              STR      r2,[r1,#0]            ;3364
000040  6800              LDR      r0,[r0,#0]            ;3366
000042  6841              LDR      r1,[r0,#4]            ;3366
000044  f0210180          BIC      r1,r1,#0x80           ;3366
000048  6041              STR      r1,[r0,#4]            ;3366
                  |L34.74|
;;;3377       }
;;;3378     }
;;;3379   }
00004a  4770              BX       lr
;;;3380   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_8BIT PROC
;;;3257     */
;;;3258   static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;3259   {
;;;3260     *(__IO uint8_t *)&hspi->Instance->DR = *((const uint8_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  7809              LDRB     r1,[r1,#0]
000006  7311              STRB     r1,[r2,#0xc]
;;;3261     hspi->pTxBuffPtr++;
000008  6b01              LDR      r1,[r0,#0x30]
00000a  1c49              ADDS     r1,r1,#1
00000c  6301              STR      r1,[r0,#0x30]
;;;3262     hspi->TxXferCount--;
00000e  8ec1              LDRH     r1,[r0,#0x36]
000010  1e49              SUBS     r1,r1,#1
000012  86c1              STRH     r1,[r0,#0x36]
;;;3263   
;;;3264     /* Check the end of the transmission */
;;;3265     if (hspi->TxXferCount == 0U)
000014  8ec1              LDRH     r1,[r0,#0x36]
000016  2900              CMP      r1,#0
000018  d117              BNE      |L35.74|
;;;3266     {
;;;3267   #if (USE_SPI_CRC != 0U)
;;;3268       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d009              BEQ      |L35.54|
;;;3269       {
;;;3270         /* Set CRC Next Bit to send CRC */
;;;3271         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3272         /* Disable TXE interrupt */
;;;3273         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3274         return;
;;;3275       }
;;;3276   #endif /* USE_SPI_CRC */
;;;3277   
;;;3278       /* Disable TXE interrupt */
;;;3279       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
000022  6801              LDR      r1,[r0,#0]
000024  684a              LDR      r2,[r1,#4]
000026  f0220280          BIC      r2,r2,#0x80
00002a  604a              STR      r2,[r1,#4]
;;;3280   
;;;3281       if (hspi->RxXferCount == 0U)
00002c  8fc1              LDRH     r1,[r0,#0x3e]
00002e  2900              CMP      r1,#0
000030  d10b              BNE      |L35.74|
;;;3282       {
;;;3283         SPI_CloseRxTx_ISR(hspi);
000032  f7ffbffe          B.W      SPI_CloseRxTx_ISR
                  |L35.54|
000036  6801              LDR      r1,[r0,#0]            ;3271
000038  680a              LDR      r2,[r1,#0]            ;3271
00003a  f4425280          ORR      r2,r2,#0x1000         ;3271
00003e  600a              STR      r2,[r1,#0]            ;3271
000040  6800              LDR      r0,[r0,#0]            ;3273
000042  6841              LDR      r1,[r0,#4]            ;3273
000044  f0210180          BIC      r1,r1,#0x80           ;3273
000048  6041              STR      r1,[r0,#4]            ;3273
                  |L35.74|
;;;3284       }
;;;3285     }
;;;3286   }
00004a  4770              BX       lr
;;;3287   
                          ENDP


                          AREA ||i.SPI_AbortRx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortRx_ISR PROC
;;;3936     */
;;;3937   static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
000000  b50c              PUSH     {r2,r3,lr}
;;;3938   {
;;;3939     __IO uint32_t tmpreg = 0U;
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
;;;3940     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4913              LDR      r1,|L36.84|
000008  f64552c0          MOV      r2,#0x5dc0
00000c  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000e  fbb1f1f2          UDIV     r1,r1,r2
000012  2264              MOVS     r2,#0x64
000014  4351              MULS     r1,r2,r1
000016  9100              STR      r1,[sp,#0]
;;;3941   
;;;3942     /* Wait until TXE flag is set */
;;;3943     do
;;;3944     {
;;;3945       if (count == 0U)
;;;3946       {
;;;3947         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;3948         break;
;;;3949       }
;;;3950       count--;
;;;3951     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000018  6801              LDR      r1,[r0,#0]
                  |L36.26|
00001a  9a00              LDR      r2,[sp,#0]            ;3945
00001c  b1aa              CBZ      r2,|L36.74|
00001e  9a00              LDR      r2,[sp,#0]            ;3950
000020  1e52              SUBS     r2,r2,#1              ;3950
000022  9200              STR      r2,[sp,#0]            ;3950
000024  688a              LDR      r2,[r1,#8]
000026  0792              LSLS     r2,r2,#30
000028  d5f7              BPL      |L36.26|
                  |L36.42|
;;;3952   
;;;3953     /* Disable SPI Peripheral */
;;;3954     __HAL_SPI_DISABLE(hspi);
00002a  680a              LDR      r2,[r1,#0]
00002c  f0220240          BIC      r2,r2,#0x40
000030  600a              STR      r2,[r1,#0]
;;;3955   
;;;3956     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;3957     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
000032  6801              LDR      r1,[r0,#0]
000034  684a              LDR      r2,[r1,#4]
000036  f02202e0          BIC      r2,r2,#0xe0
00003a  604a              STR      r2,[r1,#4]
;;;3958   
;;;3959     /* Flush Data Register by a blank read */
;;;3960     tmpreg = READ_REG(hspi->Instance->DR);
00003c  6801              LDR      r1,[r0,#0]
00003e  68c9              LDR      r1,[r1,#0xc]
000040  9101              STR      r1,[sp,#4]
;;;3961     /* To avoid GCC warning */
;;;3962     UNUSED(tmpreg);
;;;3963   
;;;3964     hspi->State = HAL_SPI_STATE_ABORT;
000042  2107              MOVS     r1,#7
000044  f8801051          STRB     r1,[r0,#0x51]
;;;3965   }
000048  bd0c              POP      {r2,r3,pc}
                  |L36.74|
00004a  6d42              LDR      r2,[r0,#0x54]         ;3947
00004c  f0420240          ORR      r2,r2,#0x40           ;3947
000050  6542              STR      r2,[r0,#0x54]         ;3947
000052  e7ea              B        |L36.42|
;;;3966   
                          ENDP

                  |L36.84|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_AbortTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_AbortTx_ISR PROC
;;;3972     */
;;;3973   static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3974   {
;;;3975     /* Disable TXEIE interrupt */
;;;3976     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
000002  684a              LDR      r2,[r1,#4]
000004  f0220280          BIC      r2,r2,#0x80
000008  604a              STR      r2,[r1,#4]
;;;3977   
;;;3978     /* Disable SPI Peripheral */
;;;3979     __HAL_SPI_DISABLE(hspi);
00000a  6801              LDR      r1,[r0,#0]
00000c  680a              LDR      r2,[r1,#0]
00000e  f0220240          BIC      r2,r2,#0x40
000012  600a              STR      r2,[r1,#0]
;;;3980   
;;;3981     hspi->State = HAL_SPI_STATE_ABORT;
000014  2107              MOVS     r1,#7
000016  f8801051          STRB     r1,[r0,#0x51]
;;;3982   }
00001a  4770              BX       lr
;;;3983   
                          ENDP


                          AREA ||i.SPI_CloseRxTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseRxTx_ISR PROC
;;;3695     */
;;;3696   static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
000000  b51c              PUSH     {r2-r4,lr}
;;;3697   {
000002  4604              MOV      r4,r0
;;;3698     uint32_t tickstart;
;;;3699     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4835              LDR      r0,|L38.220|
000006  f64551c0          MOV      r1,#0x5dc0
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  9001              STR      r0,[sp,#4]
;;;3700   
;;;3701     /* Init tickstart for timeout management */
;;;3702     tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4602              MOV      r2,r0
;;;3703   
;;;3704     /* Disable ERR interrupt */
;;;3705     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001c  6820              LDR      r0,[r4,#0]
00001e  6841              LDR      r1,[r0,#4]
000020  f0210120          BIC      r1,r1,#0x20
000024  6041              STR      r1,[r0,#4]
                  |L38.38|
;;;3706   
;;;3707     /* Wait until TXE flag is set */
;;;3708     do
;;;3709     {
;;;3710       if (count == 0U)
000026  9801              LDR      r0,[sp,#4]
000028  b190              CBZ      r0,|L38.80|
;;;3711       {
;;;3712         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3713         break;
;;;3714       }
;;;3715       count--;
00002a  9801              LDR      r0,[sp,#4]
00002c  1e40              SUBS     r0,r0,#1
00002e  9001              STR      r0,[sp,#4]
;;;3716     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000030  6820              LDR      r0,[r4,#0]
000032  6880              LDR      r0,[r0,#8]
000034  0780              LSLS     r0,r0,#30
000036  d5f6              BPL      |L38.38|
                  |L38.56|
;;;3717   
;;;3718     /* Check the end of the transaction */
;;;3719     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000038  2164              MOVS     r1,#0x64
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       SPI_EndRxTxTransaction
000040  b118              CBZ      r0,|L38.74|
;;;3720     {
;;;3721       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000042  6d60              LDR      r0,[r4,#0x54]
000044  f0400020          ORR      r0,r0,#0x20
000048  6560              STR      r0,[r4,#0x54]
                  |L38.74|
;;;3722     }
;;;3723   
;;;3724     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3725     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
00004a  68a0              LDR      r0,[r4,#8]
00004c  b128              CBZ      r0,|L38.90|
00004e  e008              B        |L38.98|
                  |L38.80|
000050  6d60              LDR      r0,[r4,#0x54]         ;3712
000052  f0400020          ORR      r0,r0,#0x20           ;3712
000056  6560              STR      r0,[r4,#0x54]         ;3712
000058  e7ee              B        |L38.56|
                  |L38.90|
;;;3726     {
;;;3727       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00005a  6820              LDR      r0,[r4,#0]
00005c  68c1              LDR      r1,[r0,#0xc]
00005e  6880              LDR      r0,[r0,#8]
000060  9000              STR      r0,[sp,#0]
                  |L38.98|
;;;3728     }
;;;3729   
;;;3730   #if (USE_SPI_CRC != 0U)
;;;3731     /* Check if CRC error occurred */
;;;3732     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
000062  6820              LDR      r0,[r4,#0]
000064  6880              LDR      r0,[r0,#8]
;;;3733     {
;;;3734       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;3735       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;3736       {
;;;3737         hspi->State = HAL_SPI_STATE_READY;
000066  f04f0101          MOV      r1,#1
00006a  43c0              MVNS     r0,r0                 ;3732
00006c  06c0              LSLS     r0,r0,#27             ;3732
00006e  d41d              BMI      |L38.172|
000070  4620              MOV      r0,r4                 ;3735
000072  f7fffffe          BL       SPI_ISCRCErrorValid
000076  2801              CMP      r0,#1                 ;3735
000078  d004              BEQ      |L38.132|
;;;3738         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3739   
;;;3740         /* Reset CRC Calculation */
;;;3741         SPI_RESET_CRC(hspi);
;;;3742   
;;;3743         /* Call user error callback */
;;;3744   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3745         hspi->ErrorCallback(hspi);
;;;3746   #else
;;;3747         HAL_SPI_ErrorCallback(hspi);
;;;3748   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3749       }
;;;3750       else
;;;3751       {
;;;3752         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
00007a  6821              LDR      r1,[r4,#0]
00007c  f64f70ef          MOV      r0,#0xffef
000080  6088              STR      r0,[r1,#8]
;;;3753       }
;;;3754     }
;;;3755     else
;;;3756     {
;;;3757   #endif /* USE_SPI_CRC */
;;;3758       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
;;;3759       {
;;;3760         if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;3761         {
;;;3762           hspi->State = HAL_SPI_STATE_READY;
;;;3763           /* Call user Rx complete callback */
;;;3764   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3765           hspi->RxCpltCallback(hspi);
;;;3766   #else
;;;3767           HAL_SPI_RxCpltCallback(hspi);
;;;3768   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3769         }
;;;3770         else
;;;3771         {
;;;3772           hspi->State = HAL_SPI_STATE_READY;
;;;3773           /* Call user TxRx complete callback */
;;;3774   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3775           hspi->TxRxCpltCallback(hspi);
;;;3776   #else
;;;3777           HAL_SPI_TxRxCpltCallback(hspi);
;;;3778   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3779         }
;;;3780       }
;;;3781       else
;;;3782       {
;;;3783         hspi->State = HAL_SPI_STATE_READY;
;;;3784         /* Call user error callback */
;;;3785   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3786         hspi->ErrorCallback(hspi);
;;;3787   #else
;;;3788         HAL_SPI_ErrorCallback(hspi);
;;;3789   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3790       }
;;;3791   #if (USE_SPI_CRC != 0U)
;;;3792     }
;;;3793   #endif /* USE_SPI_CRC */
;;;3794   }
000082  bd1c              POP      {r2-r4,pc}
                  |L38.132|
000084  f8841051          STRB     r1,[r4,#0x51]         ;3737
000088  6d60              LDR      r0,[r4,#0x54]         ;3738
00008a  f0400002          ORR      r0,r0,#2              ;3738
00008e  6560              STR      r0,[r4,#0x54]         ;3738
000090  6820              LDR      r0,[r4,#0]            ;3741
000092  6801              LDR      r1,[r0,#0]            ;3741
000094  f4215100          BIC      r1,r1,#0x2000         ;3741
000098  6001              STR      r1,[r0,#0]            ;3741
00009a  6820              LDR      r0,[r4,#0]            ;3741
00009c  6801              LDR      r1,[r0,#0]            ;3741
00009e  f4415100          ORR      r1,r1,#0x2000         ;3741
0000a2  6001              STR      r1,[r0,#0]            ;3741
0000a4  4620              MOV      r0,r4                 ;3747
0000a6  f7fffffe          BL       HAL_SPI_ErrorCallback
0000aa  bd1c              POP      {r2-r4,pc}
                  |L38.172|
0000ac  6d60              LDR      r0,[r4,#0x54]         ;3758
0000ae  b128              CBZ      r0,|L38.188|
0000b0  f8841051          STRB     r1,[r4,#0x51]         ;3783
0000b4  4620              MOV      r0,r4                 ;3788
0000b6  f7fffffe          BL       HAL_SPI_ErrorCallback
0000ba  bd1c              POP      {r2-r4,pc}
                  |L38.188|
0000bc  f8940051          LDRB     r0,[r4,#0x51]         ;3760
0000c0  2804              CMP      r0,#4                 ;3760
0000c2  d005              BEQ      |L38.208|
0000c4  f8841051          STRB     r1,[r4,#0x51]         ;3772
0000c8  4620              MOV      r0,r4                 ;3777
0000ca  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000ce  bd1c              POP      {r2-r4,pc}
                  |L38.208|
0000d0  f8841051          STRB     r1,[r4,#0x51]         ;3762
0000d4  4620              MOV      r0,r4                 ;3767
0000d6  f7fffffe          BL       HAL_SPI_RxCpltCallback
0000da  bd1c              POP      {r2-r4,pc}
;;;3795   
                          ENDP

                  |L38.220|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_CloseRx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRx_ISR PROC
;;;3801     */
;;;3802   static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;3803   {
000002  4604              MOV      r4,r0
;;;3804     /* Disable RXNE and ERR interrupt */
;;;3805     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6841              LDR      r1,[r0,#4]
000008  f0210160          BIC      r1,r1,#0x60
00000c  6041              STR      r1,[r0,#4]
;;;3806   
;;;3807     /* Check the end of the transaction */
;;;3808     if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
00000e  f7fffffe          BL       HAL_GetTick
000012  4602              MOV      r2,r0
000014  2164              MOVS     r1,#0x64
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_EndRxTransaction
00001c  b118              CBZ      r0,|L39.38|
;;;3809     {
;;;3810       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00001e  6d60              LDR      r0,[r4,#0x54]
000020  f0400020          ORR      r0,r0,#0x20
000024  6560              STR      r0,[r4,#0x54]
                  |L39.38|
;;;3811     }
;;;3812   
;;;3813     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3814     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000026  68a0              LDR      r0,[r4,#8]
000028  b918              CBNZ     r0,|L39.50|
;;;3815     {
;;;3816       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  6880              LDR      r0,[r0,#8]
000030  9000              STR      r0,[sp,#0]
                  |L39.50|
;;;3817     }
;;;3818     hspi->State = HAL_SPI_STATE_READY;
000032  2001              MOVS     r0,#1
000034  f8840051          STRB     r0,[r4,#0x51]
;;;3819   
;;;3820   #if (USE_SPI_CRC != 0U)
;;;3821     /* Check if CRC error occurred */
;;;3822     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  43c0              MVNS     r0,r0
00003e  06c0              LSLS     r0,r0,#27
000040  d41b              BMI      |L39.122|
;;;3823     {
;;;3824       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;3825       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       SPI_ISCRCErrorValid
000048  2801              CMP      r0,#1
00004a  d004              BEQ      |L39.86|
;;;3826       {
;;;3827         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3828   
;;;3829         /* Reset CRC Calculation */
;;;3830         SPI_RESET_CRC(hspi);
;;;3831   
;;;3832         /* Call user error callback */
;;;3833   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3834         hspi->ErrorCallback(hspi);
;;;3835   #else
;;;3836         HAL_SPI_ErrorCallback(hspi);
;;;3837   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3838       }
;;;3839       else
;;;3840       {
;;;3841         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
00004c  6821              LDR      r1,[r4,#0]
00004e  f64f70ef          MOV      r0,#0xffef
000052  6088              STR      r0,[r1,#8]
;;;3842       }
;;;3843     }
;;;3844     else
;;;3845     {
;;;3846   #endif /* USE_SPI_CRC */
;;;3847       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
;;;3848       {
;;;3849         /* Call user Rx complete callback */
;;;3850   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3851         hspi->RxCpltCallback(hspi);
;;;3852   #else
;;;3853         HAL_SPI_RxCpltCallback(hspi);
;;;3854   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3855       }
;;;3856       else
;;;3857       {
;;;3858         /* Call user error callback */
;;;3859   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3860         hspi->ErrorCallback(hspi);
;;;3861   #else
;;;3862         HAL_SPI_ErrorCallback(hspi);
;;;3863   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3864       }
;;;3865   #if (USE_SPI_CRC != 0U)
;;;3866     }
;;;3867   #endif /* USE_SPI_CRC */
;;;3868   }
000054  bd38              POP      {r3-r5,pc}
                  |L39.86|
000056  6d60              LDR      r0,[r4,#0x54]         ;3827
000058  f0400002          ORR      r0,r0,#2              ;3827
00005c  6560              STR      r0,[r4,#0x54]         ;3827
00005e  6820              LDR      r0,[r4,#0]            ;3830
000060  6801              LDR      r1,[r0,#0]            ;3830
000062  f4215100          BIC      r1,r1,#0x2000         ;3830
000066  6001              STR      r1,[r0,#0]            ;3830
000068  6820              LDR      r0,[r4,#0]            ;3830
00006a  6801              LDR      r1,[r0,#0]            ;3830
00006c  f4415100          ORR      r1,r1,#0x2000         ;3830
000070  6001              STR      r1,[r0,#0]            ;3830
000072  4620              MOV      r0,r4                 ;3836
000074  f7fffffe          BL       HAL_SPI_ErrorCallback
000078  bd38              POP      {r3-r5,pc}
                  |L39.122|
00007a  6d60              LDR      r0,[r4,#0x54]         ;3847
00007c  b118              CBZ      r0,|L39.134|
00007e  4620              MOV      r0,r4                 ;3862
000080  f7fffffe          BL       HAL_SPI_ErrorCallback
000084  bd38              POP      {r3-r5,pc}
                  |L39.134|
000086  4620              MOV      r0,r4                 ;3853
000088  f7fffffe          BL       HAL_SPI_RxCpltCallback
00008c  bd38              POP      {r3-r5,pc}
;;;3869   
                          ENDP


                          AREA ||i.SPI_CloseTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseTx_ISR PROC
;;;3875     */
;;;3876   static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
000000  b51c              PUSH     {r2-r4,lr}
;;;3877   {
000002  4604              MOV      r4,r0
;;;3878     uint32_t tickstart;
;;;3879     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  481d              LDR      r0,|L40.124|
000006  f64551c0          MOV      r1,#0x5dc0
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  2164              MOVS     r1,#0x64
000012  4348              MULS     r0,r1,r0
000014  9001              STR      r0,[sp,#4]
;;;3880   
;;;3881     /* Init tickstart for timeout management*/
;;;3882     tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4602              MOV      r2,r0
;;;3883   
;;;3884     /* Wait until TXE flag is set */
;;;3885     do
;;;3886     {
;;;3887       if (count == 0U)
;;;3888       {
;;;3889         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3890         break;
;;;3891       }
;;;3892       count--;
;;;3893     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
00001c  6820              LDR      r0,[r4,#0]
                  |L40.30|
00001e  9901              LDR      r1,[sp,#4]            ;3887
000020  b1a9              CBZ      r1,|L40.78|
000022  9901              LDR      r1,[sp,#4]            ;3892
000024  1e49              SUBS     r1,r1,#1              ;3892
000026  9101              STR      r1,[sp,#4]            ;3892
000028  6881              LDR      r1,[r0,#8]
00002a  0789              LSLS     r1,r1,#30
00002c  d5f7              BPL      |L40.30|
                  |L40.46|
;;;3894   
;;;3895     /* Disable TXE and ERR interrupt */
;;;3896     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
00002e  6841              LDR      r1,[r0,#4]
000030  f02101a0          BIC      r1,r1,#0xa0
000034  6041              STR      r1,[r0,#4]
;;;3897   
;;;3898     /* Check the end of the transaction */
;;;3899     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000036  2164              MOVS     r1,#0x64
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       SPI_EndRxTxTransaction
00003e  b118              CBZ      r0,|L40.72|
;;;3900     {
;;;3901       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000040  6d60              LDR      r0,[r4,#0x54]
000042  f0400020          ORR      r0,r0,#0x20
000046  6560              STR      r0,[r4,#0x54]
                  |L40.72|
;;;3902     }
;;;3903   
;;;3904     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3905     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000048  68a0              LDR      r0,[r4,#8]
00004a  b128              CBZ      r0,|L40.88|
00004c  e008              B        |L40.96|
                  |L40.78|
00004e  6d61              LDR      r1,[r4,#0x54]         ;3889
000050  f0410120          ORR      r1,r1,#0x20           ;3889
000054  6561              STR      r1,[r4,#0x54]         ;3889
000056  e7ea              B        |L40.46|
                  |L40.88|
;;;3906     {
;;;3907       __HAL_SPI_CLEAR_OVRFLAG(hspi);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  6880              LDR      r0,[r0,#8]
00005e  9000              STR      r0,[sp,#0]
                  |L40.96|
;;;3908     }
;;;3909   
;;;3910     hspi->State = HAL_SPI_STATE_READY;
000060  2001              MOVS     r0,#1
000062  f8840051          STRB     r0,[r4,#0x51]
;;;3911     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000066  6d60              LDR      r0,[r4,#0x54]
000068  b118              CBZ      r0,|L40.114|
;;;3912     {
;;;3913       /* Call user error callback */
;;;3914   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3915       hspi->ErrorCallback(hspi);
;;;3916   #else
;;;3917       HAL_SPI_ErrorCallback(hspi);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3918   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3919     }
;;;3920     else
;;;3921     {
;;;3922       /* Call user Rx complete callback */
;;;3923   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3924       hspi->TxCpltCallback(hspi);
;;;3925   #else
;;;3926       HAL_SPI_TxCpltCallback(hspi);
;;;3927   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3928     }
;;;3929   }
000070  bd1c              POP      {r2-r4,pc}
                  |L40.114|
000072  4620              MOV      r0,r4                 ;3926
000074  f7fffffe          BL       HAL_SPI_TxCpltCallback
000078  bd1c              POP      {r2-r4,pc}
;;;3930   
                          ENDP

00007a  0000              DCW      0x0000
                  |L40.124|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  SPI_DMAAbortOnError PROC
;;;3050     */
;;;3051   static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3052   {
;;;3053     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a40              LDR      r0,[r0,#0x24]
;;;3054     hspi->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  87c1              STRH     r1,[r0,#0x3e]
;;;3055     hspi->TxXferCount = 0U;
000008  86c1              STRH     r1,[r0,#0x36]
;;;3056   
;;;3057     /* Call user error callback */
;;;3058   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3059     hspi->ErrorCallback(hspi);
;;;3060   #else
;;;3061     HAL_SPI_ErrorCallback(hspi);
00000a  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3062   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3063   }
00000e  bd10              POP      {r4,pc}
;;;3064   
                          ENDP


                          AREA ||i.SPI_DMAError||, CODE, READONLY, ALIGN=1

                  SPI_DMAError PROC
;;;3027     */
;;;3028   static void SPI_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3029   {
;;;3030     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a40              LDR      r0,[r0,#0x24]
;;;3031   
;;;3032     /* Stop the disable DMA transfer on SPI side */
;;;3033     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000004  6801              LDR      r1,[r0,#0]
000006  684a              LDR      r2,[r1,#4]
000008  f0220203          BIC      r2,r2,#3
00000c  604a              STR      r2,[r1,#4]
;;;3034   
;;;3035     SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
00000e  6d41              LDR      r1,[r0,#0x54]
000010  f0410110          ORR      r1,r1,#0x10
000014  6541              STR      r1,[r0,#0x54]
;;;3036     hspi->State = HAL_SPI_STATE_READY;
000016  2101              MOVS     r1,#1
000018  f8801051          STRB     r1,[r0,#0x51]
;;;3037     /* Call user error callback */
;;;3038   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3039     hspi->ErrorCallback(hspi);
;;;3040   #else
;;;3041     HAL_SPI_ErrorCallback(hspi);
00001c  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3042   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3043   }
000020  bd10              POP      {r4,pc}
;;;3044   
                          ENDP


                          AREA ||i.SPI_DMAHalfReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfReceiveCplt PROC
;;;2991     */
;;;2992   static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2993   {
;;;2994     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a40              LDR      r0,[r0,#0x24]
;;;2995   
;;;2996     /* Call user Rx half complete callback */
;;;2997   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2998     hspi->RxHalfCpltCallback(hspi);
;;;2999   #else
;;;3000     HAL_SPI_RxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_RxHalfCpltCallback
;;;3001   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3002   }
000008  bd10              POP      {r4,pc}
;;;3003   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitCplt PROC
;;;2973     */
;;;2974   static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2975   {
;;;2976     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a40              LDR      r0,[r0,#0x24]
;;;2977   
;;;2978     /* Call user Tx half complete callback */
;;;2979   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2980     hspi->TxHalfCpltCallback(hspi);
;;;2981   #else
;;;2982     HAL_SPI_TxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_TxHalfCpltCallback
;;;2983   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2984   }
000008  bd10              POP      {r4,pc}
;;;2985   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitReceiveCplt PROC
;;;3009     */
;;;3010   static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;3011   {
;;;3012     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a40              LDR      r0,[r0,#0x24]
;;;3013   
;;;3014     /* Call user TxRx half complete callback */
;;;3015   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3016     hspi->TxRxHalfCpltCallback(hspi);
;;;3017   #else
;;;3018     HAL_SPI_TxRxHalfCpltCallback(hspi);
000004  f7fffffe          BL       HAL_SPI_TxRxHalfCpltCallback
;;;3019   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3020   }
000008  bd10              POP      {r4,pc}
;;;3021   
                          ENDP


                          AREA ||i.SPI_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAReceiveCplt PROC
;;;2784     */
;;;2785   static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;2786   {
000004  4606              MOV      r6,r0
;;;2787     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000006  6a74              LDR      r4,[r6,#0x24]
;;;2788     uint32_t tickstart;
;;;2789   #if (USE_SPI_CRC != 0U)
;;;2790     __IO uint32_t tmpreg = 0U;
000008  2700              MOVS     r7,#0
00000a  9701              STR      r7,[sp,#4]
;;;2791   #endif /* USE_SPI_CRC */
;;;2792   
;;;2793     /* Init tickstart for timeout management*/
;;;2794     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;2795   
;;;2796     /* DMA Normal Mode */
;;;2797     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
000012  6830              LDR      r0,[r6,#0]
000014  6800              LDR      r0,[r0,#0]
000016  0680              LSLS     r0,r0,#26
000018  d458              BMI      |L46.204|
;;;2798     {
;;;2799       /* Disable ERR interrupt */
;;;2800       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6841              LDR      r1,[r0,#4]
00001e  f0210120          BIC      r1,r1,#0x20
000022  6041              STR      r1,[r0,#4]
;;;2801   
;;;2802   #if (USE_SPI_CRC != 0U)
;;;2803       /* CRC handling */
;;;2804       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000024  6aa0              LDR      r0,[r4,#0x28]
000026  f5b05f00          CMP      r0,#0x2000
00002a  d10e              BNE      |L46.74|
;;;2805       {
;;;2806         /* Wait until RXNE flag */
;;;2807         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00002c  2201              MOVS     r2,#1
00002e  2364              MOVS     r3,#0x64
000030  4611              MOV      r1,r2
000032  4620              MOV      r0,r4
000034  9500              STR      r5,[sp,#0]
000036  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00003a  b118              CBZ      r0,|L46.68|
;;;2808         {
;;;2809           /* Error on the CRC reception */
;;;2810           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00003c  6d60              LDR      r0,[r4,#0x54]
00003e  f0400002          ORR      r0,r0,#2
000042  6560              STR      r0,[r4,#0x54]
                  |L46.68|
;;;2811         }
;;;2812         /* Read CRC */
;;;2813         tmpreg = READ_REG(hspi->Instance->DR);
000044  6820              LDR      r0,[r4,#0]
000046  68c0              LDR      r0,[r0,#0xc]
000048  9001              STR      r0,[sp,#4]
                  |L46.74|
;;;2814         /* To avoid GCC warning */
;;;2815         UNUSED(tmpreg);
;;;2816       }
;;;2817   #endif /* USE_SPI_CRC */
;;;2818   
;;;2819       /* Check if we are in Master RX 2 line mode */
;;;2820       if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00004a  68a0              LDR      r0,[r4,#8]
00004c  b918              CBNZ     r0,|L46.86|
00004e  6860              LDR      r0,[r4,#4]
000050  f5b07f82          CMP      r0,#0x104
000054  d025              BEQ      |L46.162|
                  |L46.86|
;;;2821       {
;;;2822         /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
;;;2823         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2824       }
;;;2825       else
;;;2826       {
;;;2827         /* Normal case */
;;;2828         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000056  6820              LDR      r0,[r4,#0]
000058  6841              LDR      r1,[r0,#4]
00005a  f0210101          BIC      r1,r1,#1
00005e  6041              STR      r1,[r0,#4]
                  |L46.96|
;;;2829       }
;;;2830   
;;;2831       /* Check the end of the transaction */
;;;2832       if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000060  462a              MOV      r2,r5
000062  2164              MOVS     r1,#0x64
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       SPI_EndRxTransaction
00006a  b108              CBZ      r0,|L46.112|
;;;2833       {
;;;2834         hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
00006c  2020              MOVS     r0,#0x20
00006e  6560              STR      r0,[r4,#0x54]
                  |L46.112|
;;;2835       }
;;;2836   
;;;2837       hspi->RxXferCount = 0U;
000070  87e7              STRH     r7,[r4,#0x3e]
;;;2838       hspi->State = HAL_SPI_STATE_READY;
000072  2001              MOVS     r0,#1
000074  f8840051          STRB     r0,[r4,#0x51]
;;;2839   
;;;2840   #if (USE_SPI_CRC != 0U)
;;;2841       /* Check if CRC error occurred */
;;;2842       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
000078  6820              LDR      r0,[r4,#0]
00007a  6880              LDR      r0,[r0,#8]
00007c  43c0              MVNS     r0,r0
00007e  06c0              LSLS     r0,r0,#27
000080  d408              BMI      |L46.148|
;;;2843       {
;;;2844         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;2845         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       SPI_ISCRCErrorValid
000088  2801              CMP      r0,#1
00008a  d010              BEQ      |L46.174|
;;;2846         {
;;;2847           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2848   
;;;2849           /* Reset CRC Calculation */
;;;2850           SPI_RESET_CRC(hspi);
;;;2851         }
;;;2852         else
;;;2853         {
;;;2854           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
00008c  6821              LDR      r1,[r4,#0]
00008e  f64f70ef          MOV      r0,#0xffef
000092  6088              STR      r0,[r1,#8]
                  |L46.148|
;;;2855         }
;;;2856       }
;;;2857   #endif /* USE_SPI_CRC */
;;;2858   
;;;2859       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000094  6d60              LDR      r0,[r4,#0x54]
000096  b1c8              CBZ      r0,|L46.204|
;;;2860       {
;;;2861         /* Call user error callback */
;;;2862   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2863         hspi->ErrorCallback(hspi);
;;;2864   #else
;;;2865         HAL_SPI_ErrorCallback(hspi);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L46.158|
;;;2866   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2867         return;
;;;2868       }
;;;2869     }
;;;2870     /* Call user Rx complete callback */
;;;2871   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2872     hspi->RxCpltCallback(hspi);
;;;2873   #else
;;;2874     HAL_SPI_RxCpltCallback(hspi);
;;;2875   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2876   }
00009e  e8bd81fc          POP      {r2-r8,pc}
                  |L46.162|
0000a2  6820              LDR      r0,[r4,#0]            ;2823
0000a4  6841              LDR      r1,[r0,#4]            ;2823
0000a6  f0210103          BIC      r1,r1,#3              ;2823
0000aa  6041              STR      r1,[r0,#4]            ;2823
0000ac  e7d8              B        |L46.96|
                  |L46.174|
0000ae  6d60              LDR      r0,[r4,#0x54]         ;2847
0000b0  f0400002          ORR      r0,r0,#2              ;2847
0000b4  6560              STR      r0,[r4,#0x54]         ;2847
0000b6  6820              LDR      r0,[r4,#0]            ;2850
0000b8  6801              LDR      r1,[r0,#0]            ;2850
0000ba  f4215100          BIC      r1,r1,#0x2000         ;2850
0000be  6001              STR      r1,[r0,#0]            ;2850
0000c0  6820              LDR      r0,[r4,#0]            ;2850
0000c2  6801              LDR      r1,[r0,#0]            ;2850
0000c4  f4415100          ORR      r1,r1,#0x2000         ;2850
0000c8  6001              STR      r1,[r0,#0]            ;2850
0000ca  e7e3              B        |L46.148|
                  |L46.204|
0000cc  4620              MOV      r0,r4                 ;2874
0000ce  f7fffffe          BL       HAL_SPI_RxCpltCallback
0000d2  e7e4              B        |L46.158|
;;;2877   
                          ENDP


                          AREA ||i.SPI_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMARxAbortCallback PROC
;;;3136     */
;;;3137   static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b538              PUSH     {r3-r5,lr}
;;;3138   {
;;;3139     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a44              LDR      r4,[r0,#0x24]
;;;3140   
;;;3141     /* Disable SPI Peripheral */
;;;3142     __HAL_SPI_DISABLE(hspi);
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0210140          BIC      r1,r1,#0x40
00000c  6001              STR      r1,[r0,#0]
;;;3143   
;;;3144     hspi->hdmarx->XferAbortCallback = NULL;
00000e  6ce0              LDR      r0,[r4,#0x4c]
000010  2500              MOVS     r5,#0
000012  6345              STR      r5,[r0,#0x34]
;;;3145   
;;;3146     /* Disable Rx DMA Request */
;;;3147     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000014  6820              LDR      r0,[r4,#0]
000016  6841              LDR      r1,[r0,#4]
000018  f0210101          BIC      r1,r1,#1
00001c  6041              STR      r1,[r0,#4]
;;;3148   
;;;3149     /* Check Busy flag */
;;;3150     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
00001e  f7fffffe          BL       HAL_GetTick
000022  4602              MOV      r2,r0
000024  2164              MOVS     r1,#0x64
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       SPI_EndRxTxTransaction
00002c  b118              CBZ      r0,|L47.54|
;;;3151     {
;;;3152       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
00002e  6d60              LDR      r0,[r4,#0x54]
000030  f0400040          ORR      r0,r0,#0x40
000034  6560              STR      r0,[r4,#0x54]
                  |L47.54|
;;;3153     }
;;;3154   
;;;3155     /* Check if an Abort process is still ongoing */
;;;3156     if (hspi->hdmatx != NULL)
000036  6ca0              LDR      r0,[r4,#0x48]
000038  b110              CBZ      r0,|L47.64|
;;;3157     {
;;;3158       if (hspi->hdmatx->XferAbortCallback != NULL)
00003a  6b40              LDR      r0,[r0,#0x34]
00003c  2800              CMP      r0,#0
00003e  d10f              BNE      |L47.96|
                  |L47.64|
;;;3159       {
;;;3160         return;
;;;3161       }
;;;3162     }
;;;3163   
;;;3164     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3165     hspi->RxXferCount = 0U;
000040  87e5              STRH     r5,[r4,#0x3e]
;;;3166     hspi->TxXferCount = 0U;
000042  86e5              STRH     r5,[r4,#0x36]
;;;3167   
;;;3168     /* Check no error during Abort procedure */
;;;3169     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
000044  6d60              LDR      r0,[r4,#0x54]
000046  2840              CMP      r0,#0x40
000048  d000              BEQ      |L47.76|
;;;3170     {
;;;3171       /* Reset errorCode */
;;;3172       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00004a  6565              STR      r5,[r4,#0x54]
                  |L47.76|
;;;3173     }
;;;3174   
;;;3175     /* Clear the Error flags in the SR register */
;;;3176     __HAL_SPI_CLEAR_OVRFLAG(hspi);
00004c  6820              LDR      r0,[r4,#0]
00004e  68c1              LDR      r1,[r0,#0xc]
000050  6880              LDR      r0,[r0,#8]
000052  9000              STR      r0,[sp,#0]
;;;3177   
;;;3178     /* Restore hspi->State to Ready */
;;;3179     hspi->State  = HAL_SPI_STATE_READY;
000054  2001              MOVS     r0,#1
000056  f8840051          STRB     r0,[r4,#0x51]
;;;3180   
;;;3181     /* Call user Abort complete callback */
;;;3182   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3183     hspi->AbortCpltCallback(hspi);
;;;3184   #else
;;;3185     HAL_SPI_AbortCpltCallback(hspi);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L47.96|
;;;3186   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3187   }
000060  bd38              POP      {r3-r5,pc}
;;;3188   
                          ENDP


                          AREA ||i.SPI_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitCplt PROC
;;;2727     */
;;;2728   static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b538              PUSH     {r3-r5,lr}
;;;2729   {
000002  4605              MOV      r5,r0
;;;2730     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2731     uint32_t tickstart;
;;;2732   
;;;2733     /* Init tickstart for timeout management*/
;;;2734     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4602              MOV      r2,r0
;;;2735   
;;;2736     /* DMA Normal Mode */
;;;2737     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  0680              LSLS     r0,r0,#26
000012  d423              BMI      |L48.92|
;;;2738     {
;;;2739       /* Disable ERR interrupt */
;;;2740       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000014  6820              LDR      r0,[r4,#0]
000016  6841              LDR      r1,[r0,#4]
000018  f0210120          BIC      r1,r1,#0x20
00001c  6041              STR      r1,[r0,#4]
;;;2741   
;;;2742       /* Disable Tx DMA Request */
;;;2743       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
00001e  6820              LDR      r0,[r4,#0]
000020  6841              LDR      r1,[r0,#4]
000022  f0210102          BIC      r1,r1,#2
000026  6041              STR      r1,[r0,#4]
;;;2744   
;;;2745       /* Check the end of the transaction */
;;;2746       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000028  2164              MOVS     r1,#0x64
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_EndRxTxTransaction
000030  b118              CBZ      r0,|L48.58|
;;;2747       {
;;;2748         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000032  6d60              LDR      r0,[r4,#0x54]
000034  f0400020          ORR      r0,r0,#0x20
000038  6560              STR      r0,[r4,#0x54]
                  |L48.58|
;;;2749       }
;;;2750   
;;;2751       /* Clear overrun flag in 2 Lines communication mode because received data is not read */
;;;2752       if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
00003a  68a0              LDR      r0,[r4,#8]
00003c  2100              MOVS     r1,#0
00003e  b918              CBNZ     r0,|L48.72|
;;;2753       {
;;;2754         __HAL_SPI_CLEAR_OVRFLAG(hspi);
000040  6820              LDR      r0,[r4,#0]
000042  68c2              LDR      r2,[r0,#0xc]
000044  6880              LDR      r0,[r0,#8]
000046  9000              STR      r0,[sp,#0]
                  |L48.72|
;;;2755       }
;;;2756   
;;;2757       hspi->TxXferCount = 0U;
000048  86e1              STRH     r1,[r4,#0x36]
;;;2758       hspi->State = HAL_SPI_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f8840051          STRB     r0,[r4,#0x51]
;;;2759   
;;;2760       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000050  6d60              LDR      r0,[r4,#0x54]
000052  b118              CBZ      r0,|L48.92|
;;;2761       {
;;;2762         /* Call user error callback */
;;;2763   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2764         hspi->ErrorCallback(hspi);
;;;2765   #else
;;;2766         HAL_SPI_ErrorCallback(hspi);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;2767   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2768         return;
;;;2769       }
;;;2770     }
;;;2771     /* Call user Tx complete callback */
;;;2772   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2773     hspi->TxCpltCallback(hspi);
;;;2774   #else
;;;2775     HAL_SPI_TxCpltCallback(hspi);
;;;2776   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2777   }
00005a  bd38              POP      {r3-r5,pc}
                  |L48.92|
00005c  4620              MOV      r0,r4                 ;2775
00005e  f7fffffe          BL       HAL_SPI_TxCpltCallback
000062  bd38              POP      {r3-r5,pc}
;;;2778   
                          ENDP


                          AREA ||i.SPI_DMATransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitReceiveCplt PROC
;;;2883     */
;;;2884   static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;2885   {
000004  4606              MOV      r6,r0
;;;2886     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000006  6a74              LDR      r4,[r6,#0x24]
;;;2887     uint32_t tickstart;
;;;2888   #if (USE_SPI_CRC != 0U)
;;;2889     __IO uint32_t tmpreg = 0U;
000008  2700              MOVS     r7,#0
00000a  9701              STR      r7,[sp,#4]
;;;2890   #endif /* USE_SPI_CRC */
;;;2891   
;;;2892     /* Init tickstart for timeout management*/
;;;2893     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4605              MOV      r5,r0
;;;2894   
;;;2895     /* DMA Normal Mode */
;;;2896     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
000012  6830              LDR      r0,[r6,#0]
000014  6800              LDR      r0,[r0,#0]
000016  0680              LSLS     r0,r0,#26
000018  d44f              BMI      |L49.186|
;;;2897     {
;;;2898       /* Disable ERR interrupt */
;;;2899       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
00001a  6820              LDR      r0,[r4,#0]
00001c  6841              LDR      r1,[r0,#4]
00001e  f0210120          BIC      r1,r1,#0x20
000022  6041              STR      r1,[r0,#4]
;;;2900   
;;;2901   #if (USE_SPI_CRC != 0U)
;;;2902       /* CRC handling */
;;;2903       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000024  6aa0              LDR      r0,[r4,#0x28]
000026  f5b05f00          CMP      r0,#0x2000
00002a  d10e              BNE      |L49.74|
;;;2904       {
;;;2905         /* Wait the CRC data */
;;;2906         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00002c  2201              MOVS     r2,#1
00002e  2364              MOVS     r3,#0x64
000030  4611              MOV      r1,r2
000032  4620              MOV      r0,r4
000034  9500              STR      r5,[sp,#0]
000036  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00003a  b118              CBZ      r0,|L49.68|
;;;2907         {
;;;2908           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
00003c  6d60              LDR      r0,[r4,#0x54]
00003e  f0400002          ORR      r0,r0,#2
000042  6560              STR      r0,[r4,#0x54]
                  |L49.68|
;;;2909         }
;;;2910         /* Read CRC to Flush DR and RXNE flag */
;;;2911         tmpreg = READ_REG(hspi->Instance->DR);
000044  6820              LDR      r0,[r4,#0]
000046  68c0              LDR      r0,[r0,#0xc]
000048  9001              STR      r0,[sp,#4]
                  |L49.74|
;;;2912         /* To avoid GCC warning */
;;;2913         UNUSED(tmpreg);
;;;2914       }
;;;2915   #endif /* USE_SPI_CRC */
;;;2916   
;;;2917       /* Check the end of the transaction */
;;;2918       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00004a  462a              MOV      r2,r5
00004c  2164              MOVS     r1,#0x64
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       SPI_EndRxTxTransaction
000054  b118              CBZ      r0,|L49.94|
;;;2919       {
;;;2920         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000056  6d60              LDR      r0,[r4,#0x54]
000058  f0400020          ORR      r0,r0,#0x20
00005c  6560              STR      r0,[r4,#0x54]
                  |L49.94|
;;;2921       }
;;;2922   
;;;2923       /* Disable Rx/Tx DMA Request */
;;;2924       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
00005e  6820              LDR      r0,[r4,#0]
000060  6841              LDR      r1,[r0,#4]
000062  f0210103          BIC      r1,r1,#3
000066  6041              STR      r1,[r0,#4]
;;;2925   
;;;2926       hspi->TxXferCount = 0U;
000068  86e7              STRH     r7,[r4,#0x36]
;;;2927       hspi->RxXferCount = 0U;
00006a  87e7              STRH     r7,[r4,#0x3e]
;;;2928       hspi->State = HAL_SPI_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  f8840051          STRB     r0,[r4,#0x51]
;;;2929   
;;;2930   #if (USE_SPI_CRC != 0U)
;;;2931       /* Check if CRC error occurred */
;;;2932       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
000072  6820              LDR      r0,[r4,#0]
000074  6880              LDR      r0,[r0,#8]
000076  43c0              MVNS     r0,r0
000078  06c0              LSLS     r0,r0,#27
00007a  d408              BMI      |L49.142|
;;;2933       {
;;;2934         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;2935         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       SPI_ISCRCErrorValid
000082  2801              CMP      r0,#1
000084  d00a              BEQ      |L49.156|
;;;2936         {
;;;2937           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2938   
;;;2939           /* Reset CRC Calculation */
;;;2940           SPI_RESET_CRC(hspi);
;;;2941         }
;;;2942         else
;;;2943         {
;;;2944           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
000086  6821              LDR      r1,[r4,#0]
000088  f64f70ef          MOV      r0,#0xffef
00008c  6088              STR      r0,[r1,#8]
                  |L49.142|
;;;2945         }
;;;2946       }
;;;2947   #endif /* USE_SPI_CRC */
;;;2948   
;;;2949       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
00008e  6d60              LDR      r0,[r4,#0x54]
000090  b198              CBZ      r0,|L49.186|
;;;2950       {
;;;2951         /* Call user error callback */
;;;2952   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2953         hspi->ErrorCallback(hspi);
;;;2954   #else
;;;2955         HAL_SPI_ErrorCallback(hspi);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L49.152|
;;;2956   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2957         return;
;;;2958       }
;;;2959     }
;;;2960     /* Call user TxRx complete callback */
;;;2961   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2962     hspi->TxRxCpltCallback(hspi);
;;;2963   #else
;;;2964     HAL_SPI_TxRxCpltCallback(hspi);
;;;2965   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2966   }
000098  e8bd81fc          POP      {r2-r8,pc}
                  |L49.156|
00009c  6d60              LDR      r0,[r4,#0x54]         ;2937
00009e  f0400002          ORR      r0,r0,#2              ;2937
0000a2  6560              STR      r0,[r4,#0x54]         ;2937
0000a4  6820              LDR      r0,[r4,#0]            ;2940
0000a6  6801              LDR      r1,[r0,#0]            ;2940
0000a8  f4215100          BIC      r1,r1,#0x2000         ;2940
0000ac  6001              STR      r1,[r0,#0]            ;2940
0000ae  6820              LDR      r0,[r4,#0]            ;2940
0000b0  6801              LDR      r1,[r0,#0]            ;2940
0000b2  f4415100          ORR      r1,r1,#0x2000         ;2940
0000b6  6001              STR      r1,[r0,#0]            ;2940
0000b8  e7e9              B        |L49.142|
                  |L49.186|
0000ba  4620              MOV      r0,r4                 ;2964
0000bc  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000c0  e7ea              B        |L49.152|
;;;2967   
                          ENDP


                          AREA ||i.SPI_DMATxAbortCallback||, CODE, READONLY, ALIGN=2

                  SPI_DMATxAbortCallback PROC
;;;3072     */
;;;3073   static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b51c              PUSH     {r2-r4,lr}
;;;3074   {
;;;3075     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
000002  6a40              LDR      r0,[r0,#0x24]
;;;3076     __IO uint32_t count;
;;;3077   
;;;3078     hspi->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6c81              LDR      r1,[r0,#0x48]
000008  634a              STR      r2,[r1,#0x34]
;;;3079     count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000a  4918              LDR      r1,|L50.108|
00000c  f64553c0          MOV      r3,#0x5dc0
000010  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000012  fbb1f1f3          UDIV     r1,r1,r3
000016  2364              MOVS     r3,#0x64
000018  4359              MULS     r1,r3,r1
00001a  9101              STR      r1,[sp,#4]
;;;3080   
;;;3081     /* Disable Tx DMA Request */
;;;3082     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
00001c  6801              LDR      r1,[r0,#0]
00001e  684b              LDR      r3,[r1,#4]
000020  f0230302          BIC      r3,r3,#2
000024  604b              STR      r3,[r1,#4]
                  |L50.38|
;;;3083   
;;;3084     /* Wait until TXE flag is set */
;;;3085     do
;;;3086     {
;;;3087       if (count == 0U)
000026  9901              LDR      r1,[sp,#4]
000028  b1d9              CBZ      r1,|L50.98|
;;;3088       {
;;;3089         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;3090         break;
;;;3091       }
;;;3092       count--;
00002a  9901              LDR      r1,[sp,#4]
00002c  1e49              SUBS     r1,r1,#1
00002e  9101              STR      r1,[sp,#4]
;;;3093     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000030  6801              LDR      r1,[r0,#0]
000032  6889              LDR      r1,[r1,#8]
000034  0789              LSLS     r1,r1,#30
000036  d5f6              BPL      |L50.38|
                  |L50.56|
;;;3094   
;;;3095     /* Check if an Abort process is still ongoing */
;;;3096     if (hspi->hdmarx != NULL)
000038  6cc1              LDR      r1,[r0,#0x4c]
00003a  b111              CBZ      r1,|L50.66|
;;;3097     {
;;;3098       if (hspi->hdmarx->XferAbortCallback != NULL)
00003c  6b49              LDR      r1,[r1,#0x34]
00003e  2900              CMP      r1,#0
000040  d10e              BNE      |L50.96|
                  |L50.66|
;;;3099       {
;;;3100         return;
;;;3101       }
;;;3102     }
;;;3103   
;;;3104     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3105     hspi->RxXferCount = 0U;
000042  87c2              STRH     r2,[r0,#0x3e]
;;;3106     hspi->TxXferCount = 0U;
000044  86c2              STRH     r2,[r0,#0x36]
;;;3107   
;;;3108     /* Check no error during Abort procedure */
;;;3109     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
000046  6d41              LDR      r1,[r0,#0x54]
000048  2940              CMP      r1,#0x40
00004a  d000              BEQ      |L50.78|
;;;3110     {
;;;3111       /* Reset errorCode */
;;;3112       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00004c  6542              STR      r2,[r0,#0x54]
                  |L50.78|
;;;3113     }
;;;3114   
;;;3115     /* Clear the Error flags in the SR register */
;;;3116     __HAL_SPI_CLEAR_OVRFLAG(hspi);
00004e  6801              LDR      r1,[r0,#0]
000050  68ca              LDR      r2,[r1,#0xc]
000052  6889              LDR      r1,[r1,#8]
000054  9100              STR      r1,[sp,#0]
;;;3117   
;;;3118     /* Restore hspi->State to Ready */
;;;3119     hspi->State  = HAL_SPI_STATE_READY;
000056  2101              MOVS     r1,#1
000058  f8801051          STRB     r1,[r0,#0x51]
;;;3120   
;;;3121     /* Call user Abort complete callback */
;;;3122   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3123     hspi->AbortCpltCallback(hspi);
;;;3124   #else
;;;3125     HAL_SPI_AbortCpltCallback(hspi);
00005c  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L50.96|
;;;3126   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3127   }
000060  bd1c              POP      {r2-r4,pc}
                  |L50.98|
000062  6d41              LDR      r1,[r0,#0x54]         ;3089
000064  f0410140          ORR      r1,r1,#0x40           ;3089
000068  6541              STR      r1,[r0,#0x54]         ;3089
00006a  e7e5              B        |L50.56|
;;;3128   
                          ENDP

                  |L50.108|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_EndRxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTransaction PROC
;;;3634     */
;;;3635   static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3636   {
000002  4604              MOV      r4,r0
;;;3637     if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
000004  f44f7582          MOV      r5,#0x104
000008  6860              LDR      r0,[r4,#4]
;;;3638                                                  || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
00000a  f44f6380          MOV      r3,#0x400
00000e  42a8              CMP      r0,r5                 ;3637
000010  d10a              BNE      |L51.40|
000012  68a0              LDR      r0,[r4,#8]            ;3637
000014  f5b04f00          CMP      r0,#0x8000            ;3637
000018  d001              BEQ      |L51.30|
00001a  4298              CMP      r0,r3
00001c  d104              BNE      |L51.40|
                  |L51.30|
;;;3639     {
;;;3640       /* Disable SPI peripheral */
;;;3641       __HAL_SPI_DISABLE(hspi);
00001e  6820              LDR      r0,[r4,#0]
000020  6806              LDR      r6,[r0,#0]
000022  f0260640          BIC      r6,r6,#0x40
000026  6006              STR      r6,[r0,#0]
                  |L51.40|
;;;3642     }
;;;3643   
;;;3644     if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY))
000028  6860              LDR      r0,[r4,#4]
00002a  42a8              CMP      r0,r5
00002c  d110              BNE      |L51.80|
00002e  68a0              LDR      r0,[r4,#8]
000030  4298              CMP      r0,r3
000032  d10d              BNE      |L51.80|
;;;3645     {
;;;3646       /* Wait the RXNE reset */
;;;3647       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
000034  460b              MOV      r3,r1
000036  9200              STR      r2,[sp,#0]
000038  2200              MOVS     r2,#0
00003a  2101              MOVS     r1,#1
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000042  b198              CBZ      r0,|L51.108|
;;;3648       {
;;;3649         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400020          ORR      r0,r0,#0x20
00004a  6560              STR      r0,[r4,#0x54]
;;;3650         return HAL_TIMEOUT;
00004c  2003              MOVS     r0,#3
;;;3651       }
;;;3652     }
;;;3653     else
;;;3654     {
;;;3655       /* Control the BSY flag */
;;;3656       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
;;;3657       {
;;;3658         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3659         return HAL_TIMEOUT;
;;;3660       }
;;;3661     }
;;;3662     return HAL_OK;
;;;3663   }
00004e  bdf8              POP      {r3-r7,pc}
                  |L51.80|
000050  460b              MOV      r3,r1                 ;3656
000052  9200              STR      r2,[sp,#0]            ;3656
000054  2200              MOVS     r2,#0                 ;3656
000056  2180              MOVS     r1,#0x80              ;3656
000058  4620              MOV      r0,r4                 ;3656
00005a  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00005e  b128              CBZ      r0,|L51.108|
000060  6d60              LDR      r0,[r4,#0x54]         ;3658
000062  f0400020          ORR      r0,r0,#0x20           ;3658
000066  6560              STR      r0,[r4,#0x54]         ;3658
000068  2003              MOVS     r0,#3                 ;3659
00006a  bdf8              POP      {r3-r7,pc}
                  |L51.108|
00006c  2000              MOVS     r0,#0                 ;3662
00006e  bdf8              POP      {r3-r7,pc}
;;;3664   
                          ENDP


                          AREA ||i.SPI_EndRxTxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTxTransaction PROC
;;;3671     */
;;;3672   static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3673   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;3674     /* Wait until TXE flag */
;;;3675     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, Tickstart) != HAL_OK)
000008  4633              MOV      r3,r6
00000a  2201              MOVS     r2,#1
00000c  2102              MOVS     r1,#2
00000e  4620              MOV      r0,r4
000010  9500              STR      r5,[sp,#0]
000012  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000016  b128              CBZ      r0,|L52.36|
;;;3676     {
;;;3677       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000018  6d60              LDR      r0,[r4,#0x54]
00001a  f0400020          ORR      r0,r0,#0x20
00001e  6560              STR      r0,[r4,#0x54]
;;;3678       return HAL_TIMEOUT;
000020  2003              MOVS     r0,#3
;;;3679     }
;;;3680   
;;;3681     /* Control the BSY flag */
;;;3682     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
;;;3683     {
;;;3684       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3685       return HAL_TIMEOUT;
;;;3686     }
;;;3687     return HAL_OK;
;;;3688   }
000022  bdf8              POP      {r3-r7,pc}
                  |L52.36|
000024  4633              MOV      r3,r6                 ;3682
000026  2200              MOVS     r2,#0                 ;3682
000028  2180              MOVS     r1,#0x80              ;3682
00002a  4620              MOV      r0,r4                 ;3682
00002c  9500              STR      r5,[sp,#0]            ;3682
00002e  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000032  b128              CBZ      r0,|L52.64|
000034  6d60              LDR      r0,[r4,#0x54]         ;3684
000036  f0400020          ORR      r0,r0,#0x20           ;3684
00003a  6560              STR      r0,[r4,#0x54]         ;3684
00003c  2003              MOVS     r0,#3                 ;3685
00003e  bdf8              POP      {r3-r7,pc}
                  |L52.64|
000040  2000              MOVS     r0,#0                 ;3687
000042  bdf8              POP      {r3-r7,pc}
;;;3689   
                          ENDP


                          AREA ||i.SPI_ISCRCErrorValid||, CODE, READONLY, ALIGN=1

                  SPI_ISCRCErrorValid PROC
;;;3991     */
;;;3992   uint8_t SPI_ISCRCErrorValid(SPI_HandleTypeDef *hspi)
000000  2001              MOVS     r0,#1
;;;3993   {
;;;3994   #if defined(SPI_CRC_ERROR_WORKAROUND_FEATURE) && (USE_SPI_CRC_ERROR_WORKAROUND != 0U)
;;;3995     /* Check how to handle this CRC error (workaround to be applied or not) */
;;;3996     /* If CRC errors could be wrongly detected (issue 2.15.2 in STM32F10xxC/D/E silicon limitations ES
;;;3997        (DocID14732 Rev 13)) */
;;;3998     if (hspi->Instance == SPI2)
;;;3999     {
;;;4000       if (hspi->Instance->RXCRCR == 0U)
;;;4001       {
;;;4002         return (SPI_INVALID_CRC_ERROR);
;;;4003       }
;;;4004     }
;;;4005   #endif /* USE_SPI_CRC_ERROR_WORKAROUND */
;;;4006     /* Prevent unused argument(s) compilation warning */
;;;4007     UNUSED(hspi);
;;;4008   
;;;4009     return (SPI_VALID_CRC_ERROR);
;;;4010   }
000002  4770              BX       lr
;;;4011   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_RxISR_16BIT||, CODE, READONLY, ALIGN=2

                  SPI_RxISR_16BIT PROC
;;;3472     */
;;;3473   static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3474   {
;;;3475     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000002  68c9              LDR      r1,[r1,#0xc]
000004  6b82              LDR      r2,[r0,#0x38]
000006  8011              STRH     r1,[r2,#0]
;;;3476     hspi->pRxBuffPtr += sizeof(uint16_t);
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c89              ADDS     r1,r1,#2
00000c  6381              STR      r1,[r0,#0x38]
;;;3477     hspi->RxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3478   
;;;3479   #if (USE_SPI_CRC != 0U)
;;;3480     /* Enable CRC Transmission */
;;;3481     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  f44f5200          MOV      r2,#0x2000
00001a  2901              CMP      r1,#1
00001c  d107              BNE      |L54.46|
00001e  6a81              LDR      r1,[r0,#0x28]
000020  4291              CMP      r1,r2
000022  d104              BNE      |L54.46|
;;;3482     {
;;;3483       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000024  6801              LDR      r1,[r0,#0]
000026  680b              LDR      r3,[r1,#0]
000028  f4435380          ORR      r3,r3,#0x1000
00002c  600b              STR      r3,[r1,#0]
                  |L54.46|
;;;3484     }
;;;3485     /* Check if CRCNEXT is well reset by hardware */
;;;3486     if (READ_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT))
00002e  6801              LDR      r1,[r0,#0]
000030  680b              LDR      r3,[r1,#0]
000032  04db              LSLS     r3,r3,#19
000034  d503              BPL      |L54.62|
;;;3487     {
;;;3488       /* Workaround to force CRCNEXT bit to zero in case of CRCNEXT is not reset automatically by hardware */
;;;3489       CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000036  680b              LDR      r3,[r1,#0]
000038  f4235380          BIC      r3,r3,#0x1000
00003c  600b              STR      r3,[r1,#0]
                  |L54.62|
;;;3490     }
;;;3491   
;;;3492   #endif /* USE_SPI_CRC */
;;;3493   
;;;3494     if (hspi->RxXferCount == 0U)
00003e  8fc1              LDRH     r1,[r0,#0x3e]
000040  2900              CMP      r1,#0
000042  d104              BNE      |L54.78|
;;;3495     {
;;;3496   #if (USE_SPI_CRC != 0U)
;;;3497       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000044  6a81              LDR      r1,[r0,#0x28]
000046  4291              CMP      r1,r2
000048  d102              BNE      |L54.80|
;;;3498       {
;;;3499         hspi->RxISR = SPI_RxISR_16BITCRC;
00004a  4902              LDR      r1,|L54.84|
00004c  6401              STR      r1,[r0,#0x40]
                  |L54.78|
;;;3500         return;
;;;3501       }
;;;3502   #endif /* USE_SPI_CRC */
;;;3503       SPI_CloseRx_ISR(hspi);
;;;3504     }
;;;3505   }
00004e  4770              BX       lr
                  |L54.80|
000050  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3506   
                          ENDP

                  |L54.84|
                          DCD      SPI_RxISR_16BITCRC

                          AREA ||i.SPI_RxISR_16BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_16BITCRC PROC
;;;3450     */
;;;3451   static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3452   {
;;;3453     __IO uint32_t tmpreg = 0U;
;;;3454   
;;;3455     /* Read 16bit CRC to flush Data Register */
;;;3456     tmpreg = READ_REG(hspi->Instance->DR);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  9201              STR      r2,[sp,#4]
;;;3457     /* To avoid GCC warning */
;;;3458     UNUSED(tmpreg);
;;;3459   
;;;3460     /* Disable RXNE and ERR interrupt */
;;;3461     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000008  684a              LDR      r2,[r1,#4]
00000a  f0220260          BIC      r2,r2,#0x60
00000e  604a              STR      r2,[r1,#4]
;;;3462   
;;;3463     SPI_CloseRx_ISR(hspi);
000010  b002              ADD      sp,sp,#8
000012  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3464   }
;;;3465   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_RxISR_8BIT||, CODE, READONLY, ALIGN=2

                  SPI_RxISR_8BIT PROC
;;;3409     */
;;;3410   static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3411   {
;;;3412     *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
000002  7b09              LDRB     r1,[r1,#0xc]
000004  6b82              LDR      r2,[r0,#0x38]
000006  7011              STRB     r1,[r2,#0]
;;;3413     hspi->pRxBuffPtr++;
000008  6b81              LDR      r1,[r0,#0x38]
00000a  1c49              ADDS     r1,r1,#1
00000c  6381              STR      r1,[r0,#0x38]
;;;3414     hspi->RxXferCount--;
00000e  8fc1              LDRH     r1,[r0,#0x3e]
000010  1e49              SUBS     r1,r1,#1
000012  87c1              STRH     r1,[r0,#0x3e]
;;;3415   
;;;3416   #if (USE_SPI_CRC != 0U)
;;;3417     /* Enable CRC Transmission */
;;;3418     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
000014  8fc1              LDRH     r1,[r0,#0x3e]
000016  f44f5200          MOV      r2,#0x2000
00001a  2901              CMP      r1,#1
00001c  d107              BNE      |L56.46|
00001e  6a81              LDR      r1,[r0,#0x28]
000020  4291              CMP      r1,r2
000022  d104              BNE      |L56.46|
;;;3419     {
;;;3420       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000024  6801              LDR      r1,[r0,#0]
000026  680b              LDR      r3,[r1,#0]
000028  f4435380          ORR      r3,r3,#0x1000
00002c  600b              STR      r3,[r1,#0]
                  |L56.46|
;;;3421     }
;;;3422     /* Check if CRCNEXT is well reset by hardware */
;;;3423     if (READ_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT))
00002e  6801              LDR      r1,[r0,#0]
000030  680b              LDR      r3,[r1,#0]
000032  04db              LSLS     r3,r3,#19
000034  d503              BPL      |L56.62|
;;;3424     {
;;;3425       /* Workaround to force CRCNEXT bit to zero in case of CRCNEXT is not reset automatically by hardware */
;;;3426       CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000036  680b              LDR      r3,[r1,#0]
000038  f4235380          BIC      r3,r3,#0x1000
00003c  600b              STR      r3,[r1,#0]
                  |L56.62|
;;;3427     }
;;;3428   
;;;3429   #endif /* USE_SPI_CRC */
;;;3430   
;;;3431     if (hspi->RxXferCount == 0U)
00003e  8fc1              LDRH     r1,[r0,#0x3e]
000040  2900              CMP      r1,#0
000042  d104              BNE      |L56.78|
;;;3432     {
;;;3433   #if (USE_SPI_CRC != 0U)
;;;3434       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000044  6a81              LDR      r1,[r0,#0x28]
000046  4291              CMP      r1,r2
000048  d102              BNE      |L56.80|
;;;3435       {
;;;3436         hspi->RxISR =  SPI_RxISR_8BITCRC;
00004a  4902              LDR      r1,|L56.84|
00004c  6401              STR      r1,[r0,#0x40]
                  |L56.78|
;;;3437         return;
;;;3438       }
;;;3439   #endif /* USE_SPI_CRC */
;;;3440       SPI_CloseRx_ISR(hspi);
;;;3441     }
;;;3442   }
00004e  4770              BX       lr
                  |L56.80|
000050  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3443   
                          ENDP

                  |L56.84|
                          DCD      SPI_RxISR_8BITCRC

                          AREA ||i.SPI_RxISR_8BITCRC||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_8BITCRC PROC
;;;3387     */
;;;3388   static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
000000  b082              SUB      sp,sp,#8
;;;3389   {
;;;3390     __IO uint8_t  *ptmpreg8;
;;;3391     __IO uint8_t  tmpreg8 = 0;
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
;;;3392   
;;;3393     /* Initialize the 8bit temporary pointer */
;;;3394     ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
000006  6801              LDR      r1,[r0,#0]
;;;3395     /* Read 8bit CRC to flush Data Register */
;;;3396     tmpreg8 = *ptmpreg8;
000008  7b09              LDRB     r1,[r1,#0xc]
00000a  9101              STR      r1,[sp,#4]
;;;3397     /* To avoid GCC warning */
;;;3398     UNUSED(tmpreg8);
00000c  f89d1004          LDRB     r1,[sp,#4]
;;;3399   
;;;3400     SPI_CloseRx_ISR(hspi);
000010  b002              ADD      sp,sp,#8
000012  f7ffbffe          B.W      SPI_CloseRx_ISR
;;;3401   }
;;;3402   #endif /* USE_SPI_CRC */
                          ENDP


                          AREA ||i.SPI_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_16BIT PROC
;;;3537     */
;;;3538   static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;3539   {
;;;3540     /* Transmit data in 16 Bit mode */
;;;3541     hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  8809              LDRH     r1,[r1,#0]
000006  60d1              STR      r1,[r2,#0xc]
;;;3542     hspi->pTxBuffPtr += sizeof(uint16_t);
000008  6b01              LDR      r1,[r0,#0x30]
00000a  1c89              ADDS     r1,r1,#2
00000c  6301              STR      r1,[r0,#0x30]
;;;3543     hspi->TxXferCount--;
00000e  8ec1              LDRH     r1,[r0,#0x36]
000010  1e49              SUBS     r1,r1,#1
000012  86c1              STRH     r1,[r0,#0x36]
;;;3544   
;;;3545     if (hspi->TxXferCount == 0U)
000014  8ec1              LDRH     r1,[r0,#0x36]
000016  2900              CMP      r1,#0
000018  d10a              BNE      |L58.48|
;;;3546     {
;;;3547   #if (USE_SPI_CRC != 0U)
;;;3548       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d104              BNE      |L58.44|
;;;3549       {
;;;3550         /* Enable CRC Transmission */
;;;3551         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000022  6801              LDR      r1,[r0,#0]
000024  680a              LDR      r2,[r1,#0]
000026  f4425280          ORR      r2,r2,#0x1000
00002a  600a              STR      r2,[r1,#0]
                  |L58.44|
;;;3552       }
;;;3553   #endif /* USE_SPI_CRC */
;;;3554       SPI_CloseTx_ISR(hspi);
00002c  f7ffbffe          B.W      SPI_CloseTx_ISR
                  |L58.48|
;;;3555     }
;;;3556   }
000030  4770              BX       lr
;;;3557   
                          ENDP


                          AREA ||i.SPI_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_8BIT PROC
;;;3512     */
;;;3513   static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  6b01              LDR      r1,[r0,#0x30]
;;;3514   {
;;;3515     *(__IO uint8_t *)&hspi->Instance->DR = *((const uint8_t *)hspi->pTxBuffPtr);
000002  6802              LDR      r2,[r0,#0]
000004  7809              LDRB     r1,[r1,#0]
000006  7311              STRB     r1,[r2,#0xc]
;;;3516     hspi->pTxBuffPtr++;
000008  6b01              LDR      r1,[r0,#0x30]
00000a  1c49              ADDS     r1,r1,#1
00000c  6301              STR      r1,[r0,#0x30]
;;;3517     hspi->TxXferCount--;
00000e  8ec1              LDRH     r1,[r0,#0x36]
000010  1e49              SUBS     r1,r1,#1
000012  86c1              STRH     r1,[r0,#0x36]
;;;3518   
;;;3519     if (hspi->TxXferCount == 0U)
000014  8ec1              LDRH     r1,[r0,#0x36]
000016  2900              CMP      r1,#0
000018  d10a              BNE      |L59.48|
;;;3520     {
;;;3521   #if (USE_SPI_CRC != 0U)
;;;3522       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
00001a  6a81              LDR      r1,[r0,#0x28]
00001c  f5b15f00          CMP      r1,#0x2000
000020  d104              BNE      |L59.44|
;;;3523       {
;;;3524         /* Enable CRC Transmission */
;;;3525         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
000022  6801              LDR      r1,[r0,#0]
000024  680a              LDR      r2,[r1,#0]
000026  f4425280          ORR      r2,r2,#0x1000
00002a  600a              STR      r2,[r1,#0]
                  |L59.44|
;;;3526       }
;;;3527   #endif /* USE_SPI_CRC */
;;;3528       SPI_CloseTx_ISR(hspi);
00002c  f7ffbffe          B.W      SPI_CloseTx_ISR
                  |L59.48|
;;;3529     }
;;;3530   }
000030  4770              BX       lr
;;;3531   
                          ENDP


                          AREA ||i.SPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=2

                  SPI_WaitFlagStateUntilTimeout PROC
;;;3567     */
;;;3568   static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3569                                                          uint32_t Timeout, uint32_t Tickstart)
;;;3570   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;3571     __IO uint32_t count;
;;;3572     uint32_t tmp_timeout;
;;;3573     uint32_t tmp_tickstart;
;;;3574   
;;;3575     /* Adjust Timeout value  in case of end of transfer */
;;;3576     tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
00000e  f7fffffe          BL       HAL_GetTick
000012  1b40              SUBS     r0,r0,r5
000014  1a35              SUBS     r5,r6,r0
;;;3577     tmp_tickstart = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  4680              MOV      r8,r0
;;;3578   
;;;3579     /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
;;;3580     count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
00001c  4826              LDR      r0,|L60.184|
00001e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000020  f3c030cb          UBFX     r0,r0,#15,#12
000024  4368              MULS     r0,r5,r0
000026  9000              STR      r0,[sp,#0]
;;;3581   
;;;3582     while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
000028  e03a              B        |L60.160|
                  |L60.42|
;;;3583     {
;;;3584       if (Timeout != HAL_MAX_DELAY)
00002a  1c70              ADDS     r0,r6,#1
00002c  d038              BEQ      |L60.160|
;;;3585       {
;;;3586         if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
00002e  f7fffffe          BL       HAL_GetTick
000032  eba00008          SUB      r0,r0,r8
000036  42a8              CMP      r0,r5
000038  d203              BCS      |L60.66|
00003a  b115              CBZ      r5,|L60.66|
;;;3587         {
;;;3588           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;3589              on both master and slave sides in order to resynchronize the master
;;;3590              and slave for their respective CRC calculation */
;;;3591   
;;;3592           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;3593           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;3594   
;;;3595           if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;3596                                                        || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
;;;3597           {
;;;3598             /* Disable SPI peripheral */
;;;3599             __HAL_SPI_DISABLE(hspi);
;;;3600           }
;;;3601   
;;;3602           /* Reset CRC Calculation */
;;;3603           if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3604           {
;;;3605             SPI_RESET_CRC(hspi);
;;;3606           }
;;;3607   
;;;3608           hspi->State = HAL_SPI_STATE_READY;
;;;3609   
;;;3610           /* Process Unlocked */
;;;3611           __HAL_UNLOCK(hspi);
;;;3612   
;;;3613           return HAL_TIMEOUT;
;;;3614         }
;;;3615         /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
;;;3616         if (count == 0U)
00003c  9800              LDR      r0,[sp,#0]
00003e  b358              CBZ      r0,|L60.152|
000040  e02b              B        |L60.154|
                  |L60.66|
000042  6820              LDR      r0,[r4,#0]            ;3593
000044  6841              LDR      r1,[r0,#4]            ;3593
000046  f02101e0          BIC      r1,r1,#0xe0           ;3593
00004a  6041              STR      r1,[r0,#4]            ;3593
00004c  6860              LDR      r0,[r4,#4]            ;3595
00004e  f5b07f82          CMP      r0,#0x104             ;3595
000052  d10b              BNE      |L60.108|
000054  68a0              LDR      r0,[r4,#8]            ;3595
000056  f5b04f00          CMP      r0,#0x8000            ;3595
00005a  d002              BEQ      |L60.98|
00005c  f5b06f80          CMP      r0,#0x400             ;3596
000060  d104              BNE      |L60.108|
                  |L60.98|
000062  6820              LDR      r0,[r4,#0]            ;3599
000064  6801              LDR      r1,[r0,#0]            ;3599
000066  f0210140          BIC      r1,r1,#0x40           ;3599
00006a  6001              STR      r1,[r0,#0]            ;3599
                  |L60.108|
00006c  6aa0              LDR      r0,[r4,#0x28]         ;3603
00006e  f5b05f00          CMP      r0,#0x2000            ;3603
000072  d109              BNE      |L60.136|
000074  6820              LDR      r0,[r4,#0]            ;3605
000076  6801              LDR      r1,[r0,#0]            ;3605
000078  f4215100          BIC      r1,r1,#0x2000         ;3605
00007c  6001              STR      r1,[r0,#0]            ;3605
00007e  6820              LDR      r0,[r4,#0]            ;3605
000080  6801              LDR      r1,[r0,#0]            ;3605
000082  f4415100          ORR      r1,r1,#0x2000         ;3605
000086  6001              STR      r1,[r0,#0]            ;3605
                  |L60.136|
000088  2001              MOVS     r0,#1                 ;3608
00008a  3450              ADDS     r4,r4,#0x50           ;3608
00008c  7060              STRB     r0,[r4,#1]            ;3608
00008e  2000              MOVS     r0,#0                 ;3611
000090  7020              STRB     r0,[r4,#0]            ;3611
000092  2003              MOVS     r0,#3                 ;3613
                  |L60.148|
;;;3617         {
;;;3618           tmp_timeout = 0U;
;;;3619         }
;;;3620         count--;
;;;3621       }
;;;3622     }
;;;3623   
;;;3624     return HAL_OK;
;;;3625   }
000094  e8bd83f8          POP      {r3-r9,pc}
                  |L60.152|
000098  2500              MOVS     r5,#0                 ;3618
                  |L60.154|
00009a  9800              LDR      r0,[sp,#0]            ;3620
00009c  1e40              SUBS     r0,r0,#1              ;3620
00009e  9000              STR      r0,[sp,#0]            ;3620
                  |L60.160|
0000a0  6820              LDR      r0,[r4,#0]            ;3582
0000a2  6880              LDR      r0,[r0,#8]            ;3582
0000a4  ea370000          BICS     r0,r7,r0              ;3582
0000a8  d004              BEQ      |L60.180|
0000aa  2000              MOVS     r0,#0                 ;3582
                  |L60.172|
0000ac  4548              CMP      r0,r9                 ;3582
0000ae  d1bc              BNE      |L60.42|
0000b0  2000              MOVS     r0,#0                 ;3624
0000b2  e7ef              B        |L60.148|
                  |L60.180|
0000b4  2001              MOVS     r0,#1                 ;3582
0000b6  e7f9              B        |L60.172|
;;;3626   
                          ENDP

                  |L60.184|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____RRX|
#line 665
|__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
