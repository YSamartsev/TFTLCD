; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_hal_rtc_ex.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_hal_rtc_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_hal_rtc_ex.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.c]
                          THUMB

                          AREA ||i.HAL_RTCEx_BKUPRead||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_BKUPRead PROC
;;;497      */
;;;498    uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
000000  4802              LDR      r0,|L1.12|
;;;499    {
;;;500      uint32_t backupregister = 0U;
;;;501      uint32_t pvalue = 0U;
;;;502    
;;;503      /* Prevent unused argument(s) compilation warning */
;;;504      UNUSED(hrtc);
;;;505    
;;;506      /* Check the parameters */
;;;507      assert_param(IS_RTC_BKP(BackupRegister));
;;;508    
;;;509      backupregister = (uint32_t)BKP_BASE;
;;;510      backupregister += (BackupRegister * 4U);
000002  eb000081          ADD      r0,r0,r1,LSL #2
;;;511    
;;;512      pvalue = (*(__IO uint32_t *)(backupregister)) & BKP_DR1_D;
000006  6800              LDR      r0,[r0,#0]
000008  b280              UXTH     r0,r0
;;;513    
;;;514      /* Read the specified register */
;;;515      return pvalue;
;;;516    }
00000a  4770              BX       lr
;;;517    
                          ENDP

                  |L1.12|
                          DCD      0x40006c00

                          AREA ||i.HAL_RTCEx_BKUPWrite||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_BKUPWrite PROC
;;;472      */
;;;473    void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
000000  4802              LDR      r0,|L2.12|
;;;474    {
;;;475      uint32_t tmp = 0U;
;;;476    
;;;477      /* Prevent unused argument(s) compilation warning */
;;;478      UNUSED(hrtc);
;;;479    
;;;480      /* Check the parameters */
;;;481      assert_param(IS_RTC_BKP(BackupRegister));
;;;482    
;;;483      tmp = (uint32_t)BKP_BASE;
;;;484      tmp += (BackupRegister * 4U);
000002  eb000081          ADD      r0,r0,r1,LSL #2
;;;485    
;;;486      *(__IO uint32_t *) tmp = (Data & BKP_DR1_D);
000006  b291              UXTH     r1,r2
000008  6001              STR      r1,[r0,#0]
;;;487    }
00000a  4770              BX       lr
;;;488    
                          ENDP

                  |L2.12|
                          DCD      0x40006c00

                          AREA ||i.HAL_RTCEx_DeactivateSecond||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_DeactivateSecond PROC
;;;347      */
;;;348    HAL_StatusTypeDef HAL_RTCEx_DeactivateSecond(RTC_HandleTypeDef *hrtc)
000000  2800              CMP      r0,#0
;;;349    {
000002  d010              BEQ      |L3.38|
;;;350      /* Check input parameters */
;;;351      if (hrtc == NULL)
;;;352      {
;;;353        return HAL_ERROR;
;;;354      }
;;;355    
;;;356      /* Process Locked */
;;;357      __HAL_LOCK(hrtc);
000004  7c01              LDRB     r1,[r0,#0x10]
000006  2901              CMP      r1,#1
000008  d00f              BEQ      |L3.42|
00000a  2201              MOVS     r2,#1
00000c  7402              STRB     r2,[r0,#0x10]
;;;358    
;;;359      hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  7441              STRB     r1,[r0,#0x11]
;;;360    
;;;361      /* Deactivate Second interruption*/
;;;362      __HAL_RTC_SECOND_DISABLE_IT(hrtc, RTC_IT_SEC);
000012  6801              LDR      r1,[r0,#0]
000014  680b              LDR      r3,[r1,#0]
000016  f0230301          BIC      r3,r3,#1
00001a  600b              STR      r3,[r1,#0]
;;;363    
;;;364      hrtc->State = HAL_RTC_STATE_READY;
00001c  7442              STRB     r2,[r0,#0x11]
;;;365    
;;;366      /* Process Unlocked */
;;;367      __HAL_UNLOCK(hrtc);
00001e  2100              MOVS     r1,#0
000020  7401              STRB     r1,[r0,#0x10]
;;;368    
;;;369      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;370    }
000024  4770              BX       lr
                  |L3.38|
000026  2001              MOVS     r0,#1                 ;353
000028  4770              BX       lr
                  |L3.42|
00002a  2002              MOVS     r0,#2                 ;357
00002c  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.HAL_RTCEx_DeactivateTamper||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_DeactivateTamper PROC
;;;173      */
;;;174    HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
000000  2800              CMP      r0,#0
;;;175    {
000002  d01d              BEQ      |L4.64|
;;;176      /* Check input parameters */
;;;177      if (hrtc == NULL)
;;;178      {
;;;179        return HAL_ERROR;
;;;180      }
;;;181      /* Prevent unused argument(s) compilation warning */
;;;182      UNUSED(Tamper);
;;;183    
;;;184      assert_param(IS_RTC_TAMPER(Tamper));
;;;185    
;;;186      /* Process Locked */
;;;187      __HAL_LOCK(hrtc);
000004  7c01              LDRB     r1,[r0,#0x10]
000006  2901              CMP      r1,#1
000008  d01c              BEQ      |L4.68|
00000a  2201              MOVS     r2,#1
00000c  7402              STRB     r2,[r0,#0x10]
;;;188    
;;;189      hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  7441              STRB     r1,[r0,#0x11]
;;;190    
;;;191      /* Disable the selected Tamper pin */
;;;192      CLEAR_BIT(BKP->CR, BKP_CR_TPE);
000012  490d              LDR      r1,|L4.72|
000014  680b              LDR      r3,[r1,#0]
000016  f0230301          BIC      r3,r3,#1
00001a  600b              STR      r3,[r1,#0]
;;;193    
;;;194      /* Disable the Tamper Interrupt in the BKP->CSR */
;;;195      /* Configure the Tamper Interrupt in the BKP->CSR */
;;;196      __HAL_RTC_TAMPER_DISABLE_IT(hrtc, RTC_IT_TAMP1);
00001c  1d09              ADDS     r1,r1,#4
00001e  680b              LDR      r3,[r1,#0]
000020  f0230304          BIC      r3,r3,#4
000024  600b              STR      r3,[r1,#0]
;;;197    
;;;198      /* Clear the Tamper interrupt pending bit */
;;;199      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
000026  680b              LDR      r3,[r1,#0]
000028  f0430303          ORR      r3,r3,#3
00002c  600b              STR      r3,[r1,#0]
;;;200      SET_BIT(BKP->CSR, BKP_CSR_CTE);
00002e  680b              LDR      r3,[r1,#0]
000030  f0430301          ORR      r3,r3,#1
000034  600b              STR      r3,[r1,#0]
;;;201    
;;;202      hrtc->State = HAL_RTC_STATE_READY;
000036  7442              STRB     r2,[r0,#0x11]
;;;203    
;;;204      /* Process Unlocked */
;;;205      __HAL_UNLOCK(hrtc);
000038  2100              MOVS     r1,#0
00003a  7401              STRB     r1,[r0,#0x10]
;;;206    
;;;207      return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;208    }
00003e  4770              BX       lr
                  |L4.64|
000040  2001              MOVS     r0,#1                 ;179
000042  4770              BX       lr
                  |L4.68|
000044  2002              MOVS     r0,#2                 ;187
000046  4770              BX       lr
;;;209    
                          ENDP

                  |L4.72|
                          DCD      0x40006c30

                          AREA ||i.HAL_RTCEx_PollForTamper1Event||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_PollForTamper1Event PROC
;;;261      */
;;;262    HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;263    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;264      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4605              MOV      r5,r0
;;;265    
;;;266      /* Check input parameters */
;;;267      if (hrtc == NULL)
00000e  b10e              CBZ      r6,|L5.20|
;;;268      {
;;;269        return HAL_ERROR;
;;;270      }
;;;271    
;;;272      /* Get the status of the Interrupt */
;;;273      while (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) == RESET)
000010  4f0d              LDR      r7,|L5.72|
000012  e00d              B        |L5.48|
                  |L5.20|
000014  2001              MOVS     r0,#1                 ;269
                  |L5.22|
;;;274      {
;;;275        if (Timeout != HAL_MAX_DELAY)
;;;276        {
;;;277          if ((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
;;;278          {
;;;279            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;280            return HAL_TIMEOUT;
;;;281          }
;;;282        }
;;;283      }
;;;284    
;;;285      /* Clear the Tamper Flag */
;;;286      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
;;;287    
;;;288      /* Change RTC state */
;;;289      hrtc->State = HAL_RTC_STATE_READY;
;;;290    
;;;291      return HAL_OK;
;;;292    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  1c60              ADDS     r0,r4,#1              ;275
00001c  d008              BEQ      |L5.48|
00001e  b124              CBZ      r4,|L5.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1b40              SUBS     r0,r0,r5              ;277
000026  42a0              CMP      r0,r4                 ;277
000028  d902              BLS      |L5.48|
                  |L5.42|
00002a  2003              MOVS     r0,#3                 ;279
00002c  7470              STRB     r0,[r6,#0x11]         ;279
00002e  e7f2              B        |L5.22|
                  |L5.48|
000030  6838              LDR      r0,[r7,#0]            ;273
000032  05c0              LSLS     r0,r0,#23             ;273
000034  d5f1              BPL      |L5.26|
000036  6838              LDR      r0,[r7,#0]            ;286
000038  f0400003          ORR      r0,r0,#3              ;286
00003c  6038              STR      r0,[r7,#0]            ;286
00003e  2001              MOVS     r0,#1                 ;289
000040  7470              STRB     r0,[r6,#0x11]         ;289
000042  2000              MOVS     r0,#0                 ;291
000044  e7e7              B        |L5.22|
;;;293    
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      0x40006c34

                          AREA ||i.HAL_RTCEx_RTCEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_RTCEventCallback PROC
;;;417      */
;;;418    __weak void HAL_RTCEx_RTCEventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;419    {
;;;420      /* Prevent unused argument(s) compilation warning */
;;;421      UNUSED(hrtc);
;;;422      /* NOTE : This function Should not be modified, when the callback is needed,
;;;423                the HAL_RTCEx_RTCEventCallback could be implemented in the user file
;;;424       */
;;;425    }
;;;426    
                          ENDP


                          AREA ||i.HAL_RTCEx_RTCEventErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_RTCEventErrorCallback PROC
;;;432      */
;;;433    __weak void HAL_RTCEx_RTCEventErrorCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;434    {
;;;435      /* Prevent unused argument(s) compilation warning */
;;;436      UNUSED(hrtc);
;;;437      /* NOTE : This function Should not be modified, when the callback is needed,
;;;438                the HAL_RTCEx_RTCEventErrorCallback could be implemented in the user file
;;;439       */
;;;440    }
;;;441    
                          ENDP


                          AREA ||i.HAL_RTCEx_RTCIRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_RTCIRQHandler PROC
;;;377      */
;;;378    void HAL_RTCEx_RTCIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b510              PUSH     {r4,lr}
;;;379    {
000002  4604              MOV      r4,r0
;;;380      if (__HAL_RTC_SECOND_GET_IT_SOURCE(hrtc, RTC_IT_SEC))
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  07c9              LSLS     r1,r1,#31
00000a  d019              BEQ      |L8.64|
;;;381      {
;;;382        /* Get the status of the Interrupt */
;;;383        if (__HAL_RTC_SECOND_GET_FLAG(hrtc, RTC_FLAG_SEC))
00000c  6841              LDR      r1,[r0,#4]
00000e  07c9              LSLS     r1,r1,#31
000010  d016              BEQ      |L8.64|
;;;384        {
;;;385          /* Check if Overrun occurred */
;;;386          if (__HAL_RTC_SECOND_GET_FLAG(hrtc, RTC_FLAG_OW))
000012  6840              LDR      r0,[r0,#4]
000014  0740              LSLS     r0,r0,#29
000016  d509              BPL      |L8.44|
;;;387          {
;;;388            /* Second error callback */
;;;389            HAL_RTCEx_RTCEventErrorCallback(hrtc);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_RTCEx_RTCEventErrorCallback
;;;390    
;;;391            /* Clear flag Second */
;;;392            __HAL_RTC_OVERFLOW_CLEAR_FLAG(hrtc, RTC_FLAG_OW);
00001e  6821              LDR      r1,[r4,#0]
000020  f06f0004          MVN      r0,#4
000024  6048              STR      r0,[r1,#4]
;;;393    
;;;394            /* Change RTC state */
;;;395            hrtc->State = HAL_RTC_STATE_ERROR;
000026  2004              MOVS     r0,#4
000028  7460              STRB     r0,[r4,#0x11]
00002a  e004              B        |L8.54|
                  |L8.44|
;;;396          }
;;;397          else
;;;398          {
;;;399            /* Second callback */
;;;400            HAL_RTCEx_RTCEventCallback(hrtc);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       HAL_RTCEx_RTCEventCallback
;;;401    
;;;402            /* Change RTC state */
;;;403            hrtc->State = HAL_RTC_STATE_READY;
000032  2001              MOVS     r0,#1
000034  7460              STRB     r0,[r4,#0x11]
                  |L8.54|
;;;404          }
;;;405    
;;;406          /* Clear flag Second */
;;;407          __HAL_RTC_SECOND_CLEAR_FLAG(hrtc, RTC_FLAG_SEC);
000036  6820              LDR      r0,[r4,#0]
000038  6841              LDR      r1,[r0,#4]
00003a  f0210101          BIC      r1,r1,#1
00003e  6041              STR      r1,[r0,#4]
                  |L8.64|
;;;408        }
;;;409      }
;;;410    }
000040  bd10              POP      {r4,pc}
;;;411    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSecond_IT||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_SetSecond_IT PROC
;;;317      */
;;;318    HAL_StatusTypeDef HAL_RTCEx_SetSecond_IT(RTC_HandleTypeDef *hrtc)
000000  2800              CMP      r0,#0
;;;319    {
000002  d010              BEQ      |L9.38|
;;;320      /* Check input parameters */
;;;321      if (hrtc == NULL)
;;;322      {
;;;323        return HAL_ERROR;
;;;324      }
;;;325    
;;;326      /* Process Locked */
;;;327      __HAL_LOCK(hrtc);
000004  7c01              LDRB     r1,[r0,#0x10]
000006  2901              CMP      r1,#1
000008  d00f              BEQ      |L9.42|
00000a  2201              MOVS     r2,#1
00000c  7402              STRB     r2,[r0,#0x10]
;;;328    
;;;329      hrtc->State = HAL_RTC_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  7441              STRB     r1,[r0,#0x11]
;;;330    
;;;331      /* Enable Second interruption */
;;;332      __HAL_RTC_SECOND_ENABLE_IT(hrtc, RTC_IT_SEC);
000012  6801              LDR      r1,[r0,#0]
000014  680b              LDR      r3,[r1,#0]
000016  f0430301          ORR      r3,r3,#1
00001a  600b              STR      r3,[r1,#0]
;;;333    
;;;334      hrtc->State = HAL_RTC_STATE_READY;
00001c  7442              STRB     r2,[r0,#0x11]
;;;335    
;;;336      /* Process Unlocked */
;;;337      __HAL_UNLOCK(hrtc);
00001e  2100              MOVS     r1,#0
000020  7401              STRB     r1,[r0,#0x10]
;;;338    
;;;339      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;340    }
000024  4770              BX       lr
                  |L9.38|
000026  2001              MOVS     r0,#1                 ;323
000028  4770              BX       lr
                  |L9.42|
00002a  2002              MOVS     r0,#2                 ;327
00002c  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.HAL_RTCEx_SetSmoothCalib||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetSmoothCalib PROC
;;;527      */
;;;528    HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue)
000000  b510              PUSH     {r4,lr}
;;;529    {
;;;530      /* Check input parameters */
;;;531      if (hrtc == NULL)
000002  2800              CMP      r0,#0
000004  d011              BEQ      |L10.42|
;;;532      {
;;;533        return HAL_ERROR;
;;;534      }
;;;535      /* Prevent unused argument(s) compilation warning */
;;;536      UNUSED(SmoothCalibPeriod);
;;;537      UNUSED(SmoothCalibPlusPulses);
;;;538    
;;;539      /* Check the parameters */
;;;540      assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmouthCalibMinusPulsesValue));
;;;541    
;;;542      /* Process Locked */
;;;543      __HAL_LOCK(hrtc);
000006  7c01              LDRB     r1,[r0,#0x10]
000008  2901              CMP      r1,#1
00000a  d010              BEQ      |L10.46|
00000c  2101              MOVS     r1,#1
00000e  7401              STRB     r1,[r0,#0x10]
;;;544    
;;;545      hrtc->State = HAL_RTC_STATE_BUSY;
000010  2202              MOVS     r2,#2
000012  7442              STRB     r2,[r0,#0x11]
;;;546    
;;;547      /* Sets RTC Clock Calibration value.*/
;;;548      MODIFY_REG(BKP->RTCCR, BKP_RTCCR_CAL, SmouthCalibMinusPulsesValue);
000014  4a07              LDR      r2,|L10.52|
000016  6814              LDR      r4,[r2,#0]
000018  f024047f          BIC      r4,r4,#0x7f
00001c  431c              ORRS     r4,r4,r3
00001e  6014              STR      r4,[r2,#0]
;;;549    
;;;550      /* Change RTC state */
;;;551      hrtc->State = HAL_RTC_STATE_READY;
000020  7441              STRB     r1,[r0,#0x11]
;;;552    
;;;553      /* Process Unlocked */
;;;554      __HAL_UNLOCK(hrtc);
000022  2100              MOVS     r1,#0
000024  7401              STRB     r1,[r0,#0x10]
;;;555    
;;;556      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;557    }
000028  bd10              POP      {r4,pc}
                  |L10.42|
00002a  2001              MOVS     r0,#1                 ;533
00002c  bd10              POP      {r4,pc}
                  |L10.46|
00002e  2002              MOVS     r0,#2                 ;543
000030  bd10              POP      {r4,pc}
;;;558    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40006c2c

                          AREA ||i.HAL_RTCEx_SetTamper||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper PROC
;;;79       */
;;;80     HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef *sTamper)
000000  b530              PUSH     {r4,r5,lr}
;;;81     {
;;;82       /* Check input parameters */
;;;83       if ((hrtc == NULL) || (sTamper == NULL))
000002  2800              CMP      r0,#0
000004  d013              BEQ      |L11.46|
000006  b191              CBZ      r1,|L11.46|
;;;84       {
;;;85         return HAL_ERROR;
;;;86       }
;;;87     
;;;88       /* Check the parameters */
;;;89       assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;90       assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;91     
;;;92       /* Process Locked */
;;;93       __HAL_LOCK(hrtc);
000008  7c02              LDRB     r2,[r0,#0x10]
00000a  2a01              CMP      r2,#1
00000c  d011              BEQ      |L11.50|
00000e  2201              MOVS     r2,#1
000010  7402              STRB     r2,[r0,#0x10]
;;;94     
;;;95       hrtc->State = HAL_RTC_STATE_BUSY;
000012  2302              MOVS     r3,#2
000014  7443              STRB     r3,[r0,#0x11]
;;;96     
;;;97       if (HAL_IS_BIT_SET(BKP->RTCCR, (BKP_RTCCR_CCO | BKP_RTCCR_ASOE)))
000016  4b0f              LDR      r3,|L11.84|
000018  681b              LDR      r3,[r3,#0]
00001a  f4137fc0          TST      r3,#0x180
00001e  f04f0300          MOV      r3,#0
000022  d008              BEQ      |L11.54|
;;;98       {
;;;99         hrtc->State = HAL_RTC_STATE_ERROR;
000024  2104              MOVS     r1,#4
000026  7441              STRB     r1,[r0,#0x11]
;;;100    
;;;101        /* Process Unlocked */
;;;102        __HAL_UNLOCK(hrtc);
000028  7403              STRB     r3,[r0,#0x10]
;;;103    
;;;104        return HAL_ERROR;
00002a  2001              MOVS     r0,#1
;;;105      }
;;;106    
;;;107      MODIFY_REG(BKP->CR, (BKP_CR_TPE | BKP_CR_TPAL), (sTamper->Tamper | (sTamper->Trigger)));
;;;108    
;;;109      hrtc->State = HAL_RTC_STATE_READY;
;;;110    
;;;111      /* Process Unlocked */
;;;112      __HAL_UNLOCK(hrtc);
;;;113    
;;;114      return HAL_OK;
;;;115    }
00002c  bd30              POP      {r4,r5,pc}
                  |L11.46|
00002e  2001              MOVS     r0,#1                 ;85
000030  bd30              POP      {r4,r5,pc}
                  |L11.50|
000032  2002              MOVS     r0,#2                 ;93
000034  bd30              POP      {r4,r5,pc}
                  |L11.54|
000036  e9d14100          LDRD     r4,r1,[r1,#0]         ;107
00003a  430c              ORRS     r4,r4,r1              ;107
00003c  4905              LDR      r1,|L11.84|
00003e  1d09              ADDS     r1,r1,#4              ;107
000040  680d              LDR      r5,[r1,#0]            ;107
000042  f0250503          BIC      r5,r5,#3              ;107
000046  432c              ORRS     r4,r4,r5              ;107
000048  600c              STR      r4,[r1,#0]            ;107
00004a  7442              STRB     r2,[r0,#0x11]         ;109
00004c  7403              STRB     r3,[r0,#0x10]         ;112
00004e  2000              MOVS     r0,#0                 ;114
000050  bd30              POP      {r4,r5,pc}
;;;116    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      0x40006c2c

                          AREA ||i.HAL_RTCEx_SetTamper_IT||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper_IT PROC
;;;125      */
;;;126    HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef *sTamper)
000000  b530              PUSH     {r4,r5,lr}
;;;127    {
;;;128      /* Check input parameters */
;;;129      if ((hrtc == NULL) || (sTamper == NULL))
000002  2800              CMP      r0,#0
000004  d013              BEQ      |L12.46|
000006  b191              CBZ      r1,|L12.46|
;;;130      {
;;;131        return HAL_ERROR;
;;;132      }
;;;133    
;;;134      /* Check the parameters */
;;;135      assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;136      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;137    
;;;138      /* Process Locked */
;;;139      __HAL_LOCK(hrtc);
000008  7c02              LDRB     r2,[r0,#0x10]
00000a  2a01              CMP      r2,#1
00000c  d011              BEQ      |L12.50|
00000e  2301              MOVS     r3,#1
000010  7403              STRB     r3,[r0,#0x10]
;;;140    
;;;141      hrtc->State = HAL_RTC_STATE_BUSY;
000012  2202              MOVS     r2,#2
000014  7442              STRB     r2,[r0,#0x11]
;;;142    
;;;143      if (HAL_IS_BIT_SET(BKP->RTCCR, (BKP_RTCCR_CCO | BKP_RTCCR_ASOE)))
000016  4a11              LDR      r2,|L12.92|
000018  6812              LDR      r2,[r2,#0]
00001a  f04f0400          MOV      r4,#0
00001e  f4127fc0          TST      r2,#0x180
000022  d008              BEQ      |L12.54|
;;;144      {
;;;145        hrtc->State = HAL_RTC_STATE_ERROR;
000024  2104              MOVS     r1,#4
000026  7441              STRB     r1,[r0,#0x11]
;;;146    
;;;147        /* Process Unlocked */
;;;148        __HAL_UNLOCK(hrtc);
000028  7404              STRB     r4,[r0,#0x10]
;;;149    
;;;150        return HAL_ERROR;
00002a  2001              MOVS     r0,#1
;;;151      }
;;;152    
;;;153      MODIFY_REG(BKP->CR, (BKP_CR_TPE | BKP_CR_TPAL), (sTamper->Tamper | (sTamper->Trigger)));
;;;154    
;;;155      /* Configure the Tamper Interrupt in the BKP->CSR */
;;;156      __HAL_RTC_TAMPER_ENABLE_IT(hrtc, RTC_IT_TAMP1);
;;;157    
;;;158      hrtc->State = HAL_RTC_STATE_READY;
;;;159    
;;;160      /* Process Unlocked */
;;;161      __HAL_UNLOCK(hrtc);
;;;162    
;;;163      return HAL_OK;
;;;164    }
00002c  bd30              POP      {r4,r5,pc}
                  |L12.46|
00002e  2001              MOVS     r0,#1                 ;131
000030  bd30              POP      {r4,r5,pc}
                  |L12.50|
000032  2002              MOVS     r0,#2                 ;139
000034  bd30              POP      {r4,r5,pc}
                  |L12.54|
000036  e9d12100          LDRD     r2,r1,[r1,#0]         ;153
00003a  430a              ORRS     r2,r2,r1              ;153
00003c  4907              LDR      r1,|L12.92|
00003e  1d09              ADDS     r1,r1,#4              ;153
000040  680d              LDR      r5,[r1,#0]            ;153
000042  f0250503          BIC      r5,r5,#3              ;153
000046  432a              ORRS     r2,r2,r5              ;153
000048  600a              STR      r2,[r1,#0]            ;153
00004a  1d09              ADDS     r1,r1,#4              ;156
00004c  680a              LDR      r2,[r1,#0]            ;156
00004e  f0420204          ORR      r2,r2,#4              ;156
000052  600a              STR      r2,[r1,#0]            ;156
000054  7443              STRB     r3,[r0,#0x11]         ;158
000056  7404              STRB     r4,[r0,#0x10]         ;161
000058  2000              MOVS     r0,#0                 ;163
00005a  bd30              POP      {r4,r5,pc}
;;;165    
                          ENDP

                  |L12.92|
                          DCD      0x40006c2c

                          AREA ||i.HAL_RTCEx_Tamper1EventCallback||, CODE, READONLY, ALIGN=1

                  HAL_RTCEx_Tamper1EventCallback PROC
;;;245      */
;;;246    __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
000000  4770              BX       lr
;;;247    {
;;;248      /* Prevent unused argument(s) compilation warning */
;;;249      UNUSED(hrtc);
;;;250      /* NOTE : This function Should not be modified, when the callback is needed,
;;;251                the HAL_RTCEx_Tamper1EventCallback could be implemented in the user file
;;;252       */
;;;253    }
;;;254    
                          ENDP


                          AREA ||i.HAL_RTCEx_TamperIRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_TamperIRQHandler PROC
;;;215      */
;;;216    void HAL_RTCEx_TamperIRQHandler(RTC_HandleTypeDef *hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
000002  4605              MOV      r5,r0
;;;218      /* Get the status of the Interrupt */
;;;219      if (__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP1))
000004  4c08              LDR      r4,|L14.40|
000006  6821              LDR      r1,[r4,#0]
000008  0749              LSLS     r1,r1,#29
00000a  d509              BPL      |L14.32|
;;;220      {
;;;221        /* Get the TAMPER Interrupt enable bit and pending bit */
;;;222        if (__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != (uint32_t)RESET)
00000c  6820              LDR      r0,[r4,#0]
00000e  05c0              LSLS     r0,r0,#23
000010  d506              BPL      |L14.32|
;;;223        {
;;;224          /* Tamper callback */
;;;225    #if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
;;;226          hrtc->Tamper1EventCallback(hrtc);
;;;227    #else
;;;228          HAL_RTCEx_Tamper1EventCallback(hrtc);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       HAL_RTCEx_Tamper1EventCallback
;;;229    #endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
;;;230    
;;;231          /* Clear the Tamper interrupt pending bit */
;;;232          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
000018  6820              LDR      r0,[r4,#0]
00001a  f0400103          ORR      r1,r0,#3
00001e  6021              STR      r1,[r4,#0]
                  |L14.32|
;;;233        }
;;;234      }
;;;235    
;;;236      /* Change RTC state */
;;;237      hrtc->State = HAL_RTC_STATE_READY;
000020  2001              MOVS     r0,#1
000022  7468              STRB     r0,[r5,#0x11]
;;;238    }
000024  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x40006c34

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rtc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REVSH|
#line 478
|__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____RRX|
#line 665
|__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
