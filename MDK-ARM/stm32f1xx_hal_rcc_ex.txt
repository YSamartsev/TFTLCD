; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_hal_rcc_ex.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_hal_rcc_ex.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;291      */
;;;292    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2101              MOVS     r1,#1
;;;293    {
;;;294      uint32_t srcclk = 0U;
;;;295    
;;;296      /* Set all possible values for the extended clock type parameter------------*/
;;;297      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
000002  6001              STR      r1,[r0,#0]
;;;298    
;;;299      /* Get the RTC configuration -----------------------------------------------*/
;;;300      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000004  4908              LDR      r1,|L1.40|
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f4027240          AND      r2,r2,#0x300
;;;301      /* Source clock is LSE or LSI*/
;;;302      PeriphClkInit->RTCClockSelection = srcclk;
00000c  6042              STR      r2,[r0,#4]
;;;303    
;;;304      /* Get the ADC clock configuration -----------------------------------------*/
;;;305      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
00000e  2203              MOVS     r2,#3
000010  6002              STR      r2,[r0,#0]
;;;306      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000012  684a              LDR      r2,[r1,#4]
000014  f4024240          AND      r2,r2,#0xc000
000018  6082              STR      r2,[r0,#8]
;;;307    
;;;308    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;309      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;310      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;311      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;312    
;;;313      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;314      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;315      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;316    
;;;317    #endif /* STM32F105xC || STM32F107xC */
;;;318    
;;;319    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;320      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;321      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;322      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;323    
;;;324      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;325      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;326      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;327    
;;;328    #endif /* STM32F103xE || STM32F103xG */
;;;329    
;;;330    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;331     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;332     || defined(STM32F105xC) || defined(STM32F107xC)
;;;333      /* Get the USB clock configuration -----------------------------------------*/
;;;334      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
00001a  2213              MOVS     r2,#0x13
00001c  6002              STR      r2,[r0,#0]
;;;335      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00001e  6849              LDR      r1,[r1,#4]
000020  f4010180          AND      r1,r1,#0x400000
000024  60c1              STR      r1,[r0,#0xc]
;;;336    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;337    }
000026  4770              BX       lr
;;;338    
                          ENDP

                  |L1.40|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;384      */
;;;385    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b510              PUSH     {r4,lr}
;;;386    {
000002  4601              MOV      r1,r0
;;;387    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;388      static const uint8_t aPLLMULFactorTable[14U] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;389      static const uint8_t aPredivFactorTable[16U] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;390    
;;;391      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;392      uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
;;;393    #endif /* STM32F105xC || STM32F107xC */
;;;394    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
;;;395        defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
;;;396      static const uint8_t aPLLMULFactorTable[16U] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
;;;397      static const uint8_t aPredivFactorTable[2U] = {1, 2};
;;;398    
;;;399      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;400    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG */
;;;401      uint32_t temp_reg = 0U, frequency = 0U;
000004  2000              MOVS     r0,#0
;;;402    
;;;403      /* Check the parameters */
;;;404      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;405    
;;;406      switch (PeriphClk)
;;;407      {
;;;408    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;409     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;410     || defined(STM32F105xC) || defined(STM32F107xC)
;;;411        case RCC_PERIPHCLK_USB:
;;;412        {
;;;413          /* Get RCC configuration ------------------------------------------------------*/
;;;414          temp_reg = RCC->CFGR;
000006  4c24              LDR      r4,|L2.152|
000008  2901              CMP      r1,#1                 ;406
00000a  d022              BEQ      |L2.82|
00000c  2902              CMP      r1,#2                 ;406
00000e  d039              BEQ      |L2.132|
000010  2910              CMP      r1,#0x10              ;406
000012  d11d              BNE      |L2.80|
000014  6861              LDR      r1,[r4,#4]
;;;415    
;;;416          /* Check if PLL is enabled */
;;;417          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLON))
000016  6822              LDR      r2,[r4,#0]
000018  01d2              LSLS     r2,r2,#7
00001a  d519              BPL      |L2.80|
;;;418          {
;;;419            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
00001c  481f              LDR      r0,|L2.156|
00001e  f3c14283          UBFX     r2,r1,#18,#4
000022  5c80              LDRB     r0,[r0,r2]
;;;420            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000024  03c9              LSLS     r1,r1,#15
000026  d50a              BPL      |L2.62|
;;;421            {
;;;422    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;423     || defined(STM32F100xE)
;;;424              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;425    #else
;;;426              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
000028  6861              LDR      r1,[r4,#4]
00002a  4a1c              LDR      r2,|L2.156|
00002c  f3c14140          UBFX     r1,r1,#17,#1
000030  1e92              SUBS     r2,r2,#2
000032  5c51              LDRB     r1,[r2,r1]
;;;427    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;428    
;;;429    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;430              if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;431              {
;;;432                /* PLL2 selected as Prediv1 source */
;;;433                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;434                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;435                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;436                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;437              }
;;;438              else
;;;439              {
;;;440                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;441                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;442              }
;;;443    
;;;444              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;445              /* In this case need to divide pllclk by 2 */
;;;446              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;447              {
;;;448                pllclk = pllclk / 2;
;;;449              }
;;;450    #else
;;;451              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;452              {
;;;453                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;454                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
000034  4a1a              LDR      r2,|L2.160|
000036  fbb2f1f1          UDIV     r1,r2,r1
00003a  4348              MULS     r0,r1,r0
00003c  e001              B        |L2.66|
                  |L2.62|
;;;455              }
;;;456    #endif /* STM32F105xC || STM32F107xC */
;;;457            }
;;;458            else
;;;459            {
;;;460              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;461              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
00003e  4919              LDR      r1,|L2.164|
000040  4348              MULS     r0,r1,r0
                  |L2.66|
;;;462            }
;;;463    
;;;464            /* Calcul of the USB frequency*/
;;;465    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;466            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;467            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;468            {
;;;469              /* Prescaler of 2 selected for USB */
;;;470              frequency = pllclk;
;;;471            }
;;;472            else
;;;473            {
;;;474              /* Prescaler of 3 selected for USB */
;;;475              frequency = (2 * pllclk) / 3;
;;;476            }
;;;477    #else
;;;478            /* USBCLK = PLLCLK / USB prescaler */
;;;479            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
000042  6861              LDR      r1,[r4,#4]
000044  0249              LSLS     r1,r1,#9
000046  d403              BMI      |L2.80|
;;;480            {
;;;481              /* No prescaler selected for USB */
;;;482              frequency = pllclk;
;;;483            }
;;;484            else
;;;485            {
;;;486              /* Prescaler of 1.5 selected for USB */
;;;487              frequency = (pllclk * 2) / 3;
000048  0040              LSLS     r0,r0,#1
00004a  2103              MOVS     r1,#3
00004c  fbb0f0f1          UDIV     r0,r0,r1
                  |L2.80|
;;;488            }
;;;489    #endif
;;;490          }
;;;491          break;
;;;492        }
;;;493    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;494    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC) || defined(STM32F107xC)
;;;495        case RCC_PERIPHCLK_I2S2:
;;;496        {
;;;497    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;498          /* SYSCLK used as source clock for I2S2 */
;;;499          frequency = HAL_RCC_GetSysClockFreq();
;;;500    #else
;;;501          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;502          {
;;;503            /* SYSCLK used as source clock for I2S2 */
;;;504            frequency = HAL_RCC_GetSysClockFreq();
;;;505          }
;;;506          else
;;;507          {
;;;508            /* Check if PLLI2S is enabled */
;;;509            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;510            {
;;;511              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;512              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;513              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;514              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;515            }
;;;516          }
;;;517    #endif /* STM32F103xE || STM32F103xG */
;;;518          break;
;;;519        }
;;;520        case RCC_PERIPHCLK_I2S3:
;;;521        {
;;;522    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;523          /* SYSCLK used as source clock for I2S3 */
;;;524          frequency = HAL_RCC_GetSysClockFreq();
;;;525    #else
;;;526          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;527          {
;;;528            /* SYSCLK used as source clock for I2S3 */
;;;529            frequency = HAL_RCC_GetSysClockFreq();
;;;530          }
;;;531          else
;;;532          {
;;;533            /* Check if PLLI2S is enabled */
;;;534            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;535            {
;;;536              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;537              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;538              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;539              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;540            }
;;;541          }
;;;542    #endif /* STM32F103xE || STM32F103xG */
;;;543          break;
;;;544        }
;;;545    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;546        case RCC_PERIPHCLK_RTC:
;;;547        {
;;;548          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;549          temp_reg = RCC->BDCR;
;;;550    
;;;551          /* Check if LSE is ready if RTC clock selection is LSE */
;;;552          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
;;;553          {
;;;554            frequency = LSE_VALUE;
;;;555          }
;;;556          /* Check if LSI is ready if RTC clock selection is LSI */
;;;557          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
;;;558          {
;;;559            frequency = LSI_VALUE;
;;;560          }
;;;561          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
;;;562          {
;;;563            frequency = HSE_VALUE / 128U;
;;;564          }
;;;565          /* Clock not enabled for RTC*/
;;;566          else
;;;567          {
;;;568            /* nothing to do: frequency already initialized to 0U */
;;;569          }
;;;570          break;
;;;571        }
;;;572        case RCC_PERIPHCLK_ADC:
;;;573        {
;;;574          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
;;;575          break;
;;;576        }
;;;577        default:
;;;578        {
;;;579          break;
;;;580        }
;;;581      }
;;;582      return (frequency);
;;;583    }
000050  bd10              POP      {r4,pc}
                  |L2.82|
000052  6a22              LDR      r2,[r4,#0x20]         ;549
000054  f3c22101          UBFX     r1,r2,#8,#2           ;552
000058  2901              CMP      r1,#1                 ;552
00005a  d103              BNE      |L2.100|
00005c  0792              LSLS     r2,r2,#30             ;552
00005e  d501              BPL      |L2.100|
000060  03c8              LSLS     r0,r1,#15             ;554
000062  bd10              POP      {r4,pc}
                  |L2.100|
000064  2902              CMP      r1,#2                 ;557
000066  d105              BNE      |L2.116|
000068  6a62              LDR      r2,[r4,#0x24]         ;557
00006a  0792              LSLS     r2,r2,#30             ;557
00006c  d502              BPL      |L2.116|
00006e  f6494040          MOV      r0,#0x9c40            ;559
                  |L2.114|
000072  bd10              POP      {r4,pc}
                  |L2.116|
000074  2903              CMP      r1,#3                 ;561
000076  d1fc              BNE      |L2.114|
000078  6821              LDR      r1,[r4,#0]            ;561
00007a  0389              LSLS     r1,r1,#14             ;561
00007c  d5f9              BPL      |L2.114|
00007e  f24f4024          MOV      r0,#0xf424            ;563
000082  bd10              POP      {r4,pc}
                  |L2.132|
000084  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000088  6861              LDR      r1,[r4,#4]            ;574
00008a  f3c13181          UBFX     r1,r1,#14,#2          ;574
00008e  1c49              ADDS     r1,r1,#1              ;574
000090  0049              LSLS     r1,r1,#1              ;574
000092  fbb0f0f1          UDIV     r0,r0,r1              ;574
000096  bd10              POP      {r4,pc}
;;;584    
                          ENDP

                  |L2.152|
                          DCD      0x40021000
                  |L2.156|
                          DCD      ||.constdata||+0x2
                  |L2.160|
                          DCD      0x007a1200
                  |L2.164|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;97       */
;;;98     HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;99     {
000004  4604              MOV      r4,r0
;;;100      uint32_t tickstart = 0U, temp_reg = 0U;
;;;101    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;102      uint32_t  pllactive = 0U;
;;;103    #endif /* STM32F105xC || STM32F107xC */
;;;104    
;;;105      /* Check the parameters */
;;;106      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;107    
;;;108      /*------------------------------- RTC/LCD Configuration ------------------------*/
;;;109      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
;;;110      {
;;;111        FlagStatus pwrclkchanged = RESET;
;;;112    
;;;113        /* check for RTC Parameters used to output RTCCLK */
;;;114        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;115    
;;;116        /* As soon as function is called to change RTC clock source, activation of the
;;;117           power domain is done. */
;;;118        /* Requires to enable write access to Backup Domain of necessary */
;;;119        if (__HAL_RCC_PWR_IS_CLK_DISABLED())
000006  f8df80f8          LDR      r8,|L3.256|
00000a  7820              LDRB     r0,[r4,#0]            ;109
00000c  07c0              LSLS     r0,r0,#31             ;109
00000e  d05f              BEQ      |L3.208|
000010  2700              MOVS     r7,#0                 ;111
000012  f8d8001c          LDR      r0,[r8,#0x1c]
000016  00c0              LSLS     r0,r0,#3
000018  d40b              BMI      |L3.50|
;;;120        {
;;;121          __HAL_RCC_PWR_CLK_ENABLE();
00001a  f8d8001c          LDR      r0,[r8,#0x1c]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  f8c8001c          STR      r0,[r8,#0x1c]
000026  f8d8001c          LDR      r0,[r8,#0x1c]
00002a  f0005080          AND      r0,r0,#0x10000000
00002e  9000              STR      r0,[sp,#0]
;;;122          pwrclkchanged = SET;
000030  2701              MOVS     r7,#1
                  |L3.50|
;;;123        }
;;;124    
;;;125        if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000032  4d34              LDR      r5,|L3.260|
000034  6828              LDR      r0,[r5,#0]
000036  05c0              LSLS     r0,r0,#23
000038  d412              BMI      |L3.96|
;;;126        {
;;;127          /* Enable write access to Backup domain */
;;;128          SET_BIT(PWR->CR, PWR_CR_DBP);
00003a  6828              LDR      r0,[r5,#0]
00003c  f4407080          ORR      r0,r0,#0x100
000040  6028              STR      r0,[r5,#0]
;;;129    
;;;130          /* Wait for Backup domain Write protection disable */
;;;131          tickstart = HAL_GetTick();
000042  f7fffffe          BL       HAL_GetTick
000046  4606              MOV      r6,r0
;;;132    
;;;133          while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000048  e007              B        |L3.90|
                  |L3.74|
;;;134          {
;;;135            if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
00004a  f7fffffe          BL       HAL_GetTick
00004e  1b80              SUBS     r0,r0,r6
000050  2864              CMP      r0,#0x64
000052  d902              BLS      |L3.90|
;;;136            {
;;;137              return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L3.86|
;;;138            }
;;;139          }
;;;140        }
;;;141    
;;;142        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
;;;143        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
;;;144        if ((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
;;;145        {
;;;146          /* Store the content of BDCR register before the reset of Backup Domain */
;;;147          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
;;;148          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;149          __HAL_RCC_BACKUPRESET_FORCE();
;;;150          __HAL_RCC_BACKUPRESET_RELEASE();
;;;151          /* Restore the Content of BDCR register */
;;;152          RCC->BDCR = temp_reg;
;;;153    
;;;154          /* Wait for LSERDY if LSE was enabled */
;;;155          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
;;;156          {
;;;157            /* Get Start Tick */
;;;158            tickstart = HAL_GetTick();
;;;159    
;;;160            /* Wait till LSE is ready */
;;;161            while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;162            {
;;;163              if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;164              {
;;;165                return HAL_TIMEOUT;
;;;166              }
;;;167            }
;;;168          }
;;;169        }
;;;170        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;171    
;;;172        /* Require to disable power clock if necessary */
;;;173        if (pwrclkchanged == SET)
;;;174        {
;;;175          __HAL_RCC_PWR_CLK_DISABLE();
;;;176        }
;;;177      }
;;;178    
;;;179      /*------------------------------ ADC clock Configuration ------------------*/
;;;180      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;181      {
;;;182        /* Check the parameters */
;;;183        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;184    
;;;185        /* Configure the ADC clock source */
;;;186        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;187      }
;;;188    
;;;189    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;190      /*------------------------------ I2S2 Configuration ------------------------*/
;;;191      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;192      {
;;;193        /* Check the parameters */
;;;194        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;195    
;;;196        /* Configure the I2S2 clock source */
;;;197        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;198      }
;;;199    
;;;200      /*------------------------------ I2S3 Configuration ------------------------*/
;;;201      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;202      {
;;;203        /* Check the parameters */
;;;204        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;205    
;;;206        /* Configure the I2S3 clock source */
;;;207        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;208      }
;;;209    
;;;210      /*------------------------------ PLL I2S Configuration ----------------------*/
;;;211      /* Check that PLLI2S need to be enabled */
;;;212      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;213      {
;;;214        /* Update flag to indicate that PLL I2S should be active */
;;;215        pllactive = 1;
;;;216      }
;;;217    
;;;218      /* Check if PLL I2S need to be enabled */
;;;219      if (pllactive == 1)
;;;220      {
;;;221        /* Enable PLL I2S only if not active */
;;;222        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;223        {
;;;224          /* Check the parameters */
;;;225          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;226          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;227    
;;;228          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;229          /* Return an error only if new value is different from the programmed value */
;;;230          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2ON) && \
;;;231              (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;232          {
;;;233            return HAL_ERROR;
;;;234          }
;;;235    
;;;236          /* Configure the HSE prediv2 factor --------------------------------*/
;;;237          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;238    
;;;239          /* Configure the main PLLI2S multiplication factors. */
;;;240          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;241    
;;;242          /* Enable the main PLLI2S. */
;;;243          __HAL_RCC_PLLI2S_ENABLE();
;;;244    
;;;245          /* Get Start Tick*/
;;;246          tickstart = HAL_GetTick();
;;;247    
;;;248          /* Wait till PLLI2S is ready */
;;;249          while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;250          {
;;;251            if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
;;;252            {
;;;253              return HAL_TIMEOUT;
;;;254            }
;;;255          }
;;;256        }
;;;257        else
;;;258        {
;;;259          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;260          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;261          {
;;;262            return HAL_ERROR;
;;;263          }
;;;264        }
;;;265      }
;;;266    #endif /* STM32F105xC || STM32F107xC */
;;;267    
;;;268    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;269     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;270     || defined(STM32F105xC) || defined(STM32F107xC)
;;;271      /*------------------------------ USB clock Configuration ------------------*/
;;;272      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;273      {
;;;274        /* Check the parameters */
;;;275        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;276    
;;;277        /* Configure the USB clock source */
;;;278        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;279      }
;;;280    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;281    
;;;282      return HAL_OK;
;;;283    }
000056  e8bd83f8          POP      {r3-r9,pc}
                  |L3.90|
00005a  6828              LDR      r0,[r5,#0]            ;133
00005c  05c0              LSLS     r0,r0,#23             ;133
00005e  d5f4              BPL      |L3.74|
                  |L3.96|
000060  f8d80020          LDR      r0,[r8,#0x20]         ;143
000064  f4007040          AND      r0,r0,#0x300          ;143
000068  b310              CBZ      r0,|L3.176|
00006a  88a1              LDRH     r1,[r4,#4]            ;144
00006c  f4017140          AND      r1,r1,#0x300          ;144
000070  4281              CMP      r1,r0                 ;144
000072  d01d              BEQ      |L3.176|
000074  f8d80020          LDR      r0,[r8,#0x20]         ;147
000078  f4207040          BIC      r0,r0,#0x300          ;147
00007c  4922              LDR      r1,|L3.264|
00007e  2201              MOVS     r2,#1                 ;149
000080  600a              STR      r2,[r1,#0]            ;149
000082  2200              MOVS     r2,#0                 ;150
000084  600a              STR      r2,[r1,#0]            ;150
000086  f8c80020          STR      r0,[r8,#0x20]         ;152
00008a  07c0              LSLS     r0,r0,#31             ;155
00008c  d010              BEQ      |L3.176|
00008e  f7fffffe          BL       HAL_GetTick
000092  4605              MOV      r5,r0                 ;158
000094  f2413688          MOV      r6,#0x1388            ;163
000098  e006              B        |L3.168|
                  |L3.154|
00009a  f7fffffe          BL       HAL_GetTick
00009e  1b40              SUBS     r0,r0,r5              ;163
0000a0  42b0              CMP      r0,r6                 ;163
0000a2  d901              BLS      |L3.168|
0000a4  2003              MOVS     r0,#3                 ;165
0000a6  e7d6              B        |L3.86|
                  |L3.168|
0000a8  f8d80020          LDR      r0,[r8,#0x20]         ;161
0000ac  0780              LSLS     r0,r0,#30             ;161
0000ae  d5f4              BPL      |L3.154|
                  |L3.176|
0000b0  f8d80020          LDR      r0,[r8,#0x20]         ;170
0000b4  6861              LDR      r1,[r4,#4]            ;170
0000b6  f4207040          BIC      r0,r0,#0x300          ;170
0000ba  4308              ORRS     r0,r0,r1              ;170
0000bc  f8c80020          STR      r0,[r8,#0x20]         ;170
0000c0  2f01              CMP      r7,#1                 ;173
0000c2  d105              BNE      |L3.208|
0000c4  f8d8001c          LDR      r0,[r8,#0x1c]         ;175
0000c8  f0205080          BIC      r0,r0,#0x10000000     ;175
0000cc  f8c8001c          STR      r0,[r8,#0x1c]         ;175
                  |L3.208|
0000d0  7820              LDRB     r0,[r4,#0]            ;180
0000d2  0780              LSLS     r0,r0,#30             ;180
0000d4  d507              BPL      |L3.230|
0000d6  f8d80004          LDR      r0,[r8,#4]            ;186
0000da  68a1              LDR      r1,[r4,#8]            ;186
0000dc  f4204040          BIC      r0,r0,#0xc000         ;186
0000e0  4308              ORRS     r0,r0,r1              ;186
0000e2  f8c80004          STR      r0,[r8,#4]            ;186
                  |L3.230|
0000e6  7820              LDRB     r0,[r4,#0]            ;272
0000e8  06c0              LSLS     r0,r0,#27             ;272
0000ea  d507              BPL      |L3.252|
0000ec  f8d80004          LDR      r0,[r8,#4]            ;278
0000f0  68e1              LDR      r1,[r4,#0xc]          ;278
0000f2  f4200080          BIC      r0,r0,#0x400000       ;278
0000f6  4308              ORRS     r0,r0,r1              ;278
0000f8  f8c80004          STR      r0,[r8,#4]            ;278
                  |L3.252|
0000fc  2000              MOVS     r0,#0                 ;282
0000fe  e7aa              B        |L3.86|
;;;284    
                          ENDP

                  |L3.256|
                          DCD      0x40021000
                  |L3.260|
                          DCD      0x40007000
                  |L3.264|
                          DCD      0x42420440

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  aPredivFactorTable
000000  0102              DCB      0x01,0x02
                  aPLLMULFactorTable
000002  0203              DCB      0x02,0x03
000004  04050607          DCB      0x04,0x05,0x06,0x07
000008  08090a0b          DCB      0x08,0x09,0x0a,0x0b
00000c  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
000010  1010              DCB      0x10,0x10

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 478
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 665
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
