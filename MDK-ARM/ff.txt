; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\ff.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\ff.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\ff.crf ..\Middlewares\Third_Party\FatFs\src\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2247   static
;;;2248   BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;2249   	FATFS* fs,	/* File system object */
;;;2250   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;2251   )
;;;2252   {
000002  4604              MOV      r4,r0
;;;2253   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
000004  2000              MOVS     r0,#0
000006  f8840204          STRB     r0,[r4,#0x204]
00000a  1e40              SUBS     r0,r0,#1
00000c  f8c4022c          STR      r0,[r4,#0x22c]
;;;2254   	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       move_window
000016  b108              CBZ      r0,|L1.28|
;;;2255   		return 3;
000018  2003              MOVS     r0,#3
;;;2256   
;;;2257   	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
;;;2258   		return 2;
;;;2259   
;;;2260   	if ((LD_DWORD(&fs->win.d8[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
;;;2261   		return 0;
;;;2262   	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;2263   		return 0;
;;;2264   
;;;2265   	return 1;
;;;2266   }
00001a  bd10              POP      {r4,pc}
                  |L1.28|
00001c  f89401fe          LDRB     r0,[r4,#0x1fe]        ;2257
000020  f89411ff          LDRB     r1,[r4,#0x1ff]        ;2257
000024  ea402001          ORR      r0,r0,r1,LSL #8       ;2257
000028  f5a0412a          SUB      r1,r0,#0xaa00         ;2257
00002c  3955              SUBS     r1,r1,#0x55           ;2257
00002e  d001              BEQ      |L1.52|
000030  2002              MOVS     r0,#2                 ;2258
000032  bd10              POP      {r4,pc}
                  |L1.52|
000034  f8140f36          LDRB     r0,[r4,#0x36]!        ;2260
000038  78e1              LDRB     r1,[r4,#3]            ;2260
00003a  7862              LDRB     r2,[r4,#1]            ;2260
00003c  ea406101          ORR      r1,r0,r1,LSL #24      ;2260
000040  78a0              LDRB     r0,[r4,#2]            ;2260
000042  3c36              SUBS     r4,r4,#0x36           ;2260
000044  0400              LSLS     r0,r0,#16             ;2260
000046  ea402002          ORR      r0,r0,r2,LSL #8       ;2260
00004a  4301              ORRS     r1,r1,r0              ;2260
00004c  480b              LDR      r0,|L1.124|
00004e  ebb02f01          CMP      r0,r1,LSL #8          ;2260
000052  d101              BNE      |L1.88|
000054  2000              MOVS     r0,#0                 ;2261
000056  bd10              POP      {r4,pc}
                  |L1.88|
000058  f8141f52          LDRB     r1,[r4,#0x52]!        ;2262
00005c  78e2              LDRB     r2,[r4,#3]            ;2262
00005e  7863              LDRB     r3,[r4,#1]            ;2262
000060  ea416102          ORR      r1,r1,r2,LSL #24      ;2262
000064  78a2              LDRB     r2,[r4,#2]            ;2262
000066  0412              LSLS     r2,r2,#16             ;2262
000068  ea422203          ORR      r2,r2,r3,LSL #8       ;2262
00006c  4311              ORRS     r1,r1,r2              ;2262
00006e  ebb02f01          CMP      r0,r1,LSL #8          ;2262
000072  d101              BNE      |L1.120|
000074  2000              MOVS     r0,#0                 ;2263
000076  bd10              POP      {r4,pc}
                  |L1.120|
000078  2001              MOVS     r0,#1                 ;2265
00007a  bd10              POP      {r4,pc}
;;;2267   
                          ENDP

                  |L1.124|
                          DCD      0x54414600

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;615    static
;;;616    int chk_chr (const char* str, int chr) {
000000  e000              B        |L2.4|
                  |L2.2|
;;;617    	while (*str && *str != chr) str++;
000002  1c40              ADDS     r0,r0,#1
                  |L2.4|
000004  7802              LDRB     r2,[r0,#0]
000006  b10a              CBZ      r2,|L2.12|
000008  428a              CMP      r2,r1
00000a  d1fa              BNE      |L2.2|
                  |L2.12|
;;;618    	return *str;
00000c  7800              LDRB     r0,[r0,#0]
;;;619    }
00000e  4770              BX       lr
;;;620    
                          ENDP


                          AREA ||i.chk_lock||, CODE, READONLY, ALIGN=2

                  chk_lock PROC
;;;661    static
;;;662    FRESULT chk_lock (	/* Check if the file can be accessed */
000000  b5f0              PUSH     {r4-r7,lr}
;;;663    	DIR* dp,		/* Directory object pointing the file to be checked */
;;;664    	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
;;;665    )
;;;666    {
;;;667    	UINT i, be;
;;;668    
;;;669    	/* Search file semaphore table */
;;;670    	for (i = be = 0; i < _FS_LOCK; i++) {
000002  2200              MOVS     r2,#0
000004  4615              MOV      r5,r2
;;;671    		if (Files[i].fs) {	/* Existing entry */
000006  4e19              LDR      r6,|L3.108|
000008  e017              B        |L3.58|
                  |L3.10|
00000a  eb020342          ADD      r3,r2,r2,LSL #1
00000e  f8564023          LDR      r4,[r6,r3,LSL #2]
000012  b184              CBZ      r4,|L3.54|
;;;672    			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
000014  f8d07200          LDR      r7,[r0,#0x200]
000018  42bc              CMP      r4,r7
00001a  d10d              BNE      |L3.56|
;;;673    				Files[i].clu == dp->sclust &&
00001c  eb060383          ADD      r3,r6,r3,LSL #2
000020  f8d07208          LDR      r7,[r0,#0x208]
000024  685c              LDR      r4,[r3,#4]
000026  42bc              CMP      r4,r7
000028  d106              BNE      |L3.56|
;;;674    				Files[i].idx == dp->index) break;
00002a  891b              LDRH     r3,[r3,#8]
00002c  f8b04206          LDRH     r4,[r0,#0x206]
000030  42a3              CMP      r3,r4
000032  d004              BEQ      |L3.62|
000034  e000              B        |L3.56|
                  |L3.54|
;;;675    		} else {			/* Blank entry */
;;;676    			be = 1;
000036  2501              MOVS     r5,#1
                  |L3.56|
000038  1c52              ADDS     r2,r2,#1              ;670
                  |L3.58|
00003a  2a0c              CMP      r2,#0xc               ;670
00003c  d3e5              BCC      |L3.10|
                  |L3.62|
;;;677    		}
;;;678    	}
;;;679    	if (i == _FS_LOCK)	/* The object is not opened */
00003e  2a0c              CMP      r2,#0xc
000040  d001              BEQ      |L3.70|
;;;680    		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
;;;681    
;;;682    	/* The object has been opened. Reject any open against writing file and all write mode open */
;;;683    	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
000042  b989              CBNZ     r1,|L3.104|
000044  e006              B        |L3.84|
                  |L3.70|
000046  b91d              CBNZ     r5,|L3.80|
000048  2902              CMP      r1,#2                 ;680
00004a  d001              BEQ      |L3.80|
00004c  2012              MOVS     r0,#0x12              ;680
;;;684    }
00004e  bdf0              POP      {r4-r7,pc}
                  |L3.80|
000050  2000              MOVS     r0,#0                 ;680
000052  bdf0              POP      {r4-r7,pc}
                  |L3.84|
000054  eb020042          ADD      r0,r2,r2,LSL #1       ;683
000058  eb060080          ADD      r0,r6,r0,LSL #2       ;683
00005c  8940              LDRH     r0,[r0,#0xa]          ;683
00005e  f5b07f80          CMP      r0,#0x100             ;683
000062  d001              BEQ      |L3.104|
000064  2000              MOVS     r0,#0                 ;683
000066  bdf0              POP      {r4-r7,pc}
                  |L3.104|
000068  2010              MOVS     r0,#0x10              ;683
00006a  bdf0              POP      {r4-r7,pc}
;;;685    
                          ENDP

                  |L3.108|
                          DCD      ||.bss||

                          AREA ||i.clear_lock||, CODE, READONLY, ALIGN=2

                  clear_lock PROC
;;;752    static
;;;753    void clear_lock (	/* Clear lock entries of the volume */
000000  b530              PUSH     {r4,r5,lr}
;;;754    	FATFS *fs
;;;755    )
;;;756    {
;;;757    	UINT i;
;;;758    
;;;759    	for (i = 0; i < _FS_LOCK; i++) {
000002  2100              MOVS     r1,#0
;;;760    		if (Files[i].fs == fs) Files[i].fs = 0;
000004  4b06              LDR      r3,|L4.32|
000006  2400              MOVS     r4,#0                 ;759
                  |L4.8|
000008  eb010241          ADD      r2,r1,r1,LSL #1
00000c  f8535022          LDR      r5,[r3,r2,LSL #2]
000010  4285              CMP      r5,r0
000012  d101              BNE      |L4.24|
000014  f8434022          STR      r4,[r3,r2,LSL #2]
                  |L4.24|
000018  1c49              ADDS     r1,r1,#1              ;759
00001a  290c              CMP      r1,#0xc               ;759
00001c  d3f4              BCC      |L4.8|
;;;761    	}
;;;762    }
00001e  bd30              POP      {r4,r5,pc}
;;;763    #endif
                          ENDP

                  |L4.32|
                          DCD      ||.bss||

                          AREA ||i.clmt_clust||, CODE, READONLY, ALIGN=1

                  clmt_clust PROC
;;;1124   static
;;;1125   DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
000000  f8d02224          LDR      r2,[r0,#0x224]
;;;1126   	FIL* fp,		/* Pointer to the file object */
;;;1127   	DWORD ofs		/* File offset to be converted to cluster# */
;;;1128   )
;;;1129   {
;;;1130   	DWORD cl, ncl, *tbl;
;;;1131   
;;;1132   
;;;1133   	tbl = fp->cltbl + 1;	/* Top of CLMT */
000004  1d12              ADDS     r2,r2,#4
;;;1134   	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
000006  f8d00200          LDR      r0,[r0,#0x200]
00000a  0a49              LSRS     r1,r1,#9
00000c  f8900202          LDRB     r0,[r0,#0x202]
000010  fbb1f0f0          UDIV     r0,r1,r0
                  |L5.20|
;;;1135   	for (;;) {
;;;1136   		ncl = *tbl++;			/* Number of cluters in the fragment */
000014  ca02              LDM      r2!,{r1}
;;;1137   		if (!ncl) return 0;		/* End of table? (error) */
000016  b121              CBZ      r1,|L5.34|
;;;1138   		if (cl < ncl) break;	/* In this fragment? */
000018  4288              CMP      r0,r1
00001a  d204              BCS      |L5.38|
;;;1139   		cl -= ncl; tbl++;		/* Next fragment */
;;;1140   	}
;;;1141   	return cl + *tbl;	/* Return the cluster number */
00001c  6811              LDR      r1,[r2,#0]
00001e  4408              ADD      r0,r0,r1
;;;1142   }
000020  4770              BX       lr
                  |L5.34|
000022  2000              MOVS     r0,#0                 ;1137
000024  4770              BX       lr
                  |L5.38|
000026  1a40              SUBS     r0,r0,r1              ;1139
000028  1d12              ADDS     r2,r2,#4              ;1139
00002a  e7f3              B        |L5.20|
;;;1143   #endif	/* _USE_FASTSEEK */
                          ENDP


                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;872    
;;;873    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  1e89              SUBS     r1,r1,#2
;;;874    	FATFS* fs,		/* File system object */
;;;875    	DWORD clst		/* Cluster# to be converted */
;;;876    )
;;;877    {
;;;878    	clst -= 2;
;;;879    	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
000002  f8d02214          LDR      r2,[r0,#0x214]
000006  1e92              SUBS     r2,r2,#2
000008  428a              CMP      r2,r1
00000a  d801              BHI      |L6.16|
00000c  2000              MOVS     r0,#0
;;;880    	return clst * fs->csize + fs->database;
;;;881    }
00000e  4770              BX       lr
                  |L6.16|
000010  f8d02228          LDR      r2,[r0,#0x228]        ;880
000014  f8900202          LDRB     r0,[r0,#0x202]        ;880
000018  fb012000          MLA      r0,r1,r0,r2           ;880
00001c  4770              BX       lr
;;;882    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;1062   static
;;;1063   DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1064   	FATFS* fs,			/* File system object */
;;;1065   	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;;;1066   )
;;;1067   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1068   	DWORD cs, ncl, scl;
;;;1069   	FRESULT res;
;;;1070   
;;;1071   
;;;1072   	if (clst == 0) {		/* Create a new chain */
000008  2f00              CMP      r7,#0
00000a  d008              BEQ      |L7.30|
;;;1073   		scl = fs->last_clust;			/* Get suggested start point */
;;;1074   		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;1075   	}
;;;1076   	else {					/* Stretch the current chain */
;;;1077   		cs = get_fat(fs, clst);			/* Check the cluster status */
00000c  4639              MOV      r1,r7
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       get_fat
;;;1078   		if (cs < 2) return 1;			/* Invalid value */
000014  2802              CMP      r0,#2
000016  d20b              BCS      |L7.48|
000018  2001              MOVS     r0,#1
                  |L7.26|
;;;1079   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1080   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1081   		scl = clst;
;;;1082   	}
;;;1083   
;;;1084   	ncl = scl;				/* Start cluster */
;;;1085   	for (;;) {
;;;1086   		ncl++;							/* Next cluster */
;;;1087   		if (ncl >= fs->n_fatent) {		/* Check wrap around */
;;;1088   			ncl = 2;
;;;1089   			if (ncl > scl) return 0;	/* No free cluster */
;;;1090   		}
;;;1091   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1092   		if (cs == 0) break;				/* Found a free cluster */
;;;1093   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1094   			return cs;
;;;1095   		if (ncl == scl) return 0;		/* No free cluster */
;;;1096   	}
;;;1097   
;;;1098   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1099   	if (res == FR_OK && clst != 0) {
;;;1100   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1101   	}
;;;1102   	if (res == FR_OK) {
;;;1103   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1104   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1105   			fs->free_clust--;
;;;1106   			fs->fsi_flag |= 1;
;;;1107   		}
;;;1108   	} else {
;;;1109   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1110   	}
;;;1111   
;;;1112   	return ncl;		/* Return new cluster number or error code */
;;;1113   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L7.30|
00001e  f8d6520c          LDR      r5,[r6,#0x20c]        ;1073
000022  b11d              CBZ      r5,|L7.44|
000024  f8d60214          LDR      r0,[r6,#0x214]        ;1074
000028  42a8              CMP      r0,r5                 ;1074
00002a  d808              BHI      |L7.62|
                  |L7.44|
00002c  2501              MOVS     r5,#1                 ;1074
00002e  e006              B        |L7.62|
                  |L7.48|
000030  1c41              ADDS     r1,r0,#1              ;1079
000032  d0f2              BEQ      |L7.26|
000034  f8d61214          LDR      r1,[r6,#0x214]        ;1080
000038  4281              CMP      r1,r0                 ;1080
00003a  d8ee              BHI      |L7.26|
00003c  463d              MOV      r5,r7                 ;1081
                  |L7.62|
00003e  462c              MOV      r4,r5                 ;1084
                  |L7.64|
000040  1c64              ADDS     r4,r4,#1              ;1086
000042  f8d60214          LDR      r0,[r6,#0x214]        ;1087
000046  42a0              CMP      r0,r4                 ;1087
000048  d804              BHI      |L7.84|
00004a  2402              MOVS     r4,#2                 ;1088
00004c  2d02              CMP      r5,#2                 ;1089
00004e  d201              BCS      |L7.84|
000050  2000              MOVS     r0,#0                 ;1089
000052  e7e2              B        |L7.26|
                  |L7.84|
000054  4621              MOV      r1,r4                 ;1091
000056  4630              MOV      r0,r6                 ;1091
000058  f7fffffe          BL       get_fat
00005c  b138              CBZ      r0,|L7.110|
00005e  1c41              ADDS     r1,r0,#1              ;1093
000060  d0db              BEQ      |L7.26|
000062  2801              CMP      r0,#1                 ;1093
000064  d0d9              BEQ      |L7.26|
000066  42ac              CMP      r4,r5                 ;1095
000068  d1ea              BNE      |L7.64|
00006a  2000              MOVS     r0,#0                 ;1095
00006c  e7d5              B        |L7.26|
                  |L7.110|
00006e  f06f4270          MVN      r2,#0xf0000000        ;1098
000072  4621              MOV      r1,r4                 ;1098
000074  4630              MOV      r0,r6                 ;1098
000076  f7fffffe          BL       put_fat
00007a  b928              CBNZ     r0,|L7.136|
00007c  b127              CBZ      r7,|L7.136|
00007e  4622              MOV      r2,r4                 ;1100
000080  4639              MOV      r1,r7                 ;1100
000082  4630              MOV      r0,r6                 ;1100
000084  f7fffffe          BL       put_fat
                  |L7.136|
000088  b120              CBZ      r0,|L7.148|
00008a  2801              CMP      r0,#1                 ;1109
00008c  d012              BEQ      |L7.180|
00008e  2401              MOVS     r4,#1                 ;1109
                  |L7.144|
000090  4620              MOV      r0,r4                 ;1112
000092  e7c2              B        |L7.26|
                  |L7.148|
000094  f8c6420c          STR      r4,[r6,#0x20c]        ;1103
000098  f8d60210          LDR      r0,[r6,#0x210]        ;1104
00009c  1c41              ADDS     r1,r0,#1              ;1104
00009e  d0f7              BEQ      |L7.144|
0000a0  1e40              SUBS     r0,r0,#1              ;1105
0000a2  f8c60210          STR      r0,[r6,#0x210]        ;1105
0000a6  f8960205          LDRB     r0,[r6,#0x205]        ;1106
0000aa  f0400001          ORR      r0,r0,#1              ;1106
0000ae  f8860205          STRB     r0,[r6,#0x205]        ;1106
0000b2  e7ed              B        |L7.144|
                  |L7.180|
0000b4  f04f34ff          MOV      r4,#0xffffffff        ;1109
0000b8  e7ea              B        |L7.144|
;;;1114   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1912   static
;;;1913   FRESULT create_name (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1914   	DIR* dp,			/* Pointer to the directory object */
;;;1915   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;1916   )
;;;1917   {
000004  468b              MOV      r11,r1
;;;1918   #if _USE_LFN	/* LFN configuration */
;;;1919   	BYTE b, cf;
;;;1920   	WCHAR w, *lfn;
;;;1921   	UINT i, ni, si, di;
;;;1922   	const TCHAR *p;
;;;1923   
;;;1924   	/* Create LFN in Unicode */
;;;1925   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1926   	lfn = dp->lfn;
;;;1927   	si = di = 0;
;;;1928   	for (;;) {
;;;1929   		w = p[si++];					/* Get a character */
;;;1930   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
;;;1931   		if (di >= _MAX_LFN)				/* Reject too long name */
;;;1932   			return FR_INVALID_NAME;
;;;1933   #if !_LFN_UNICODE
;;;1934   		w &= 0xFF;
;;;1935   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1936   #if _DF1S
;;;1937   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;1938   			w = (w << 8) + b;			/* Create a DBC */
;;;1939   			if (!IsDBCS2(b))
;;;1940   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1941   #endif
;;;1942   		}
;;;1943   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;1944   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1945   #endif
;;;1946   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
;;;1947   			return FR_INVALID_NAME;
;;;1948   		lfn[di++] = w;					/* Store the Unicode character */
;;;1949   	}
;;;1950   	*path = &p[si];						/* Return pointer to the next segment */
;;;1951   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1952   #if _FS_RPATH
;;;1953   	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
;;;1954   		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
;;;1955   		lfn[di] = 0;
;;;1956   		for (i = 0; i < 11; i++)
;;;1957   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;1958   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1959   		return FR_OK;
;;;1960   	}
;;;1961   #endif
;;;1962   	while (di) {						/* Strip trailing spaces and dots */
;;;1963   		w = lfn[di - 1];
;;;1964   		if (w != ' ' && w != '.') break;
;;;1965   		di--;
;;;1966   	}
;;;1967   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;;;1968   
;;;1969   	lfn[di] = 0;						/* LFN is created */
;;;1970   
;;;1971   	/* Create SFN in directory form */
;;;1972   	mem_set(dp->fn, ' ', 11);
;;;1973   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;1974   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1975   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1976   
;;;1977   	b = i = 0; ni = 8;
;;;1978   	for (;;) {
;;;1979   		w = lfn[si++];					/* Get an LFN character */
;;;1980   		if (!w) break;					/* Break on end of the LFN */
;;;1981   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1982   			cf |= NS_LOSS | NS_LFN; continue;
;;;1983   		}
;;;1984   
;;;1985   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1986   			if (ni == 11) {				/* Long extension */
;;;1987   				cf |= NS_LOSS | NS_LFN; break;
;;;1988   			}
;;;1989   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1990   			if (si > di) break;			/* No extension */
;;;1991   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1992   			b <<= 2; continue;
;;;1993   		}
;;;1994   
;;;1995   		if (w >= 0x80) {				/* Non ASCII character */
;;;1996   #ifdef _EXCVT
;;;1997   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1998   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;1999   #else
;;;2000   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;2001   #endif
;;;2002   			cf |= NS_LFN;				/* Force create LFN entry */
;;;2003   		}
;;;2004   
;;;2005   		if (_DF1S && w >= 0x100) {		/* DBC (always false at SBCS cfg) */
;;;2006   			if (i >= ni - 1) {
;;;2007   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;2008   			}
;;;2009   			dp->fn[i++] = (BYTE)(w >> 8);
;;;2010   		} else {						/* SBC */
;;;2011   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;2012   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;2013   			} else {
;;;2014   				if (IsUpper(w)) {		/* ASCII large capital */
;;;2015   					b |= 2;
;;;2016   				} else {
;;;2017   					if (IsLower(w)) {	/* ASCII small capital */
;;;2018   						b |= 1; w -= 0x20;
;;;2019   					}
;;;2020   				}
;;;2021   			}
;;;2022   		}
;;;2023   		dp->fn[i++] = (BYTE)w;
;;;2024   	}
;;;2025   
;;;2026   	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
;;;2027   
;;;2028   	if (ni == 8) b <<= 2;
;;;2029   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;2030   		cf |= NS_LFN;
;;;2031   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;2032   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;2033   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;2034   	}
;;;2035   
;;;2036   	dp->fn[NSFLAG] = cf;	/* SFN is created */
;;;2037   
;;;2038   	return FR_OK;
;;;2039   
;;;2040   
;;;2041   #else	/* Non-LFN configuration */
;;;2042   	BYTE b, c, d, *sfn;
;;;2043   	UINT ni, si, i;
;;;2044   	const char *p;
;;;2045   
;;;2046   	/* Create file name in directory form */
;;;2047   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
000006  f8db7000          LDR      r7,[r11,#0]
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  1c7f              ADDS     r7,r7,#1
                  |L8.14|
00000e  7839              LDRB     r1,[r7,#0]
000010  292f              CMP      r1,#0x2f
000012  d0fb              BEQ      |L8.12|
000014  295c              CMP      r1,#0x5c
000016  d0f9              BEQ      |L8.12|
;;;2048   	sfn = dp->fn;
000018  f8d0a218          LDR      r10,[r0,#0x218]
;;;2049   	mem_set(sfn, ' ', 11);
00001c  220b              MOVS     r2,#0xb
00001e  2120              MOVS     r1,#0x20
000020  4650              MOV      r0,r10
000022  f7fffffe          BL       mem_set
;;;2050   	si = i = b = 0; ni = 8;
000026  2500              MOVS     r5,#0
000028  462e              MOV      r6,r5
00002a  46a8              MOV      r8,r5
00002c  f04f0908          MOV      r9,#8
                  |L8.48|
;;;2051   #if _FS_RPATH
;;;2052   	if (p[si] == '.') { /* Is this a dot entry? */
;;;2053   		for (;;) {
;;;2054   			c = (BYTE)p[si++];
;;;2055   			if (c != '.' || si >= 3) break;
;;;2056   			sfn[i++] = c;
;;;2057   		}
;;;2058   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;2059   		*path = &p[si];									/* Return pointer to the next segment */
;;;2060   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;2061   		return FR_OK;
;;;2062   	}
;;;2063   #endif
;;;2064   	for (;;) {
;;;2065   		c = (BYTE)p[si++];
000030  4640              MOV      r0,r8
000032  f1080801          ADD      r8,r8,#1
000036  5c3c              LDRB     r4,[r7,r0]
;;;2066   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
000038  2c20              CMP      r4,#0x20
00003a  d90b              BLS      |L8.84|
00003c  2c2f              CMP      r4,#0x2f
00003e  d009              BEQ      |L8.84|
000040  2c5c              CMP      r4,#0x5c
000042  d007              BEQ      |L8.84|
;;;2067   		if (c == '.' || i >= ni) {
000044  2c2e              CMP      r4,#0x2e
000046  d001              BEQ      |L8.76|
000048  454e              CMP      r6,r9
00004a  d316              BCC      |L8.122|
                  |L8.76|
;;;2068   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
00004c  f1b90f08          CMP      r9,#8
000050  d10a              BNE      |L8.104|
000052  e007              B        |L8.100|
                  |L8.84|
;;;2069   			i = 8; ni = 11;
;;;2070   			b <<= 2; continue;
;;;2071   		}
;;;2072   		if (c >= 0x80) {				/* Extended character? */
;;;2073   			b |= 3;						/* Eliminate NT flag */
;;;2074   #ifdef _EXCVT
;;;2075   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;;;2076   #else
;;;2077   #if !_DF1S
;;;2078   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
;;;2079   #endif
;;;2080   #endif
;;;2081   		}
;;;2082   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;2083   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;2084   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;2085   				return FR_INVALID_NAME;
;;;2086   			sfn[i++] = c;
;;;2087   			sfn[i++] = d;
;;;2088   		} else {						/* SBC */
;;;2089   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
;;;2090   				return FR_INVALID_NAME;
;;;2091   			if (IsUpper(c)) {			/* ASCII large capital? */
;;;2092   				b |= 2;
;;;2093   			} else {
;;;2094   				if (IsLower(c)) {		/* ASCII small capital? */
;;;2095   					b |= 1; c -= 0x20;
;;;2096   				}
;;;2097   			}
;;;2098   			sfn[i++] = c;
;;;2099   		}
;;;2100   	}
;;;2101   	*path = &p[si];						/* Return pointer to the next segment */
000054  eb070008          ADD      r0,r7,r8
000058  f8cb0000          STR      r0,[r11,#0]
;;;2102   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
00005c  2c20              CMP      r4,#0x20
00005e  d82f              BHI      |L8.192|
000060  2004              MOVS     r0,#4
000062  e02e              B        |L8.194|
                  |L8.100|
000064  2c2e              CMP      r4,#0x2e              ;2068
000066  d002              BEQ      |L8.110|
                  |L8.104|
000068  2006              MOVS     r0,#6                 ;2068
                  |L8.106|
;;;2103   
;;;2104   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
;;;2105   	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
;;;2106   
;;;2107   	if (ni == 8) b <<= 2;
;;;2108   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;2109   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;2110   
;;;2111   	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
;;;2112   
;;;2113   	return FR_OK;
;;;2114   #endif
;;;2115   }
00006a  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.110|
00006e  2608              MOVS     r6,#8                 ;2069
000070  f04f090b          MOV      r9,#0xb               ;2069
000074  06a8              LSLS     r0,r5,#26             ;2070
000076  0e05              LSRS     r5,r0,#24             ;2070
000078  e7da              B        |L8.48|
                  |L8.122|
00007a  2c80              CMP      r4,#0x80              ;2072
00007c  d305              BCC      |L8.138|
00007e  f0450503          ORR      r5,r5,#3              ;2073
000082  4820              LDR      r0,|L8.260|
000084  4420              ADD      r0,r0,r4              ;2075
000086  f8104c80          LDRB     r4,[r0,#-0x80]        ;2075
                  |L8.138|
00008a  a01f              ADR      r0,|L8.264|
00008c  4621              MOV      r1,r4                 ;2089
00008e  f7fffffe          BL       chk_chr
000092  b108              CBZ      r0,|L8.152|
000094  2006              MOVS     r0,#6                 ;2090
000096  e7e8              B        |L8.106|
                  |L8.152|
000098  f1a40041          SUB      r0,r4,#0x41           ;2091
00009c  2819              CMP      r0,#0x19              ;2091
00009e  d802              BHI      |L8.166|
0000a0  f0450502          ORR      r5,r5,#2              ;2092
0000a4  e007              B        |L8.182|
                  |L8.166|
0000a6  f1a40061          SUB      r0,r4,#0x61           ;2094
0000aa  2819              CMP      r0,#0x19              ;2094
0000ac  d803              BHI      |L8.182|
0000ae  f0450501          ORR      r5,r5,#1              ;2095
0000b2  3c20              SUBS     r4,r4,#0x20           ;2095
0000b4  b2e4              UXTB     r4,r4                 ;2095
                  |L8.182|
0000b6  4630              MOV      r0,r6                 ;2098
0000b8  1c76              ADDS     r6,r6,#1              ;2098
0000ba  f80a4000          STRB     r4,[r10,r0]           ;2098
0000be  e7b7              B        |L8.48|
                  |L8.192|
0000c0  2000              MOVS     r0,#0                 ;2102
                  |L8.194|
0000c2  b126              CBZ      r6,|L8.206|
0000c4  f89a1000          LDRB     r1,[r10,#0]           ;2105
0000c8  29e5              CMP      r1,#0xe5              ;2105
0000ca  d002              BEQ      |L8.210|
0000cc  e004              B        |L8.216|
                  |L8.206|
0000ce  2006              MOVS     r0,#6                 ;2104
0000d0  e7cb              B        |L8.106|
                  |L8.210|
0000d2  2105              MOVS     r1,#5                 ;2105
0000d4  f88a1000          STRB     r1,[r10,#0]           ;2105
                  |L8.216|
0000d8  f1b90f08          CMP      r9,#8                 ;2107
0000dc  d101              BNE      |L8.226|
0000de  06a9              LSLS     r1,r5,#26             ;2107
0000e0  0e0d              LSRS     r5,r1,#24             ;2107
                  |L8.226|
0000e2  f0050103          AND      r1,r5,#3              ;2108
0000e6  2901              CMP      r1,#1                 ;2108
0000e8  d101              BNE      |L8.238|
0000ea  f0400010          ORR      r0,r0,#0x10           ;2108
                  |L8.238|
0000ee  f3c50181          UBFX     r1,r5,#2,#2           ;2109
0000f2  2901              CMP      r1,#1                 ;2109
0000f4  d101              BNE      |L8.250|
0000f6  f0400008          ORR      r0,r0,#8              ;2109
                  |L8.250|
0000fa  f88a000b          STRB     r0,[r10,#0xb]         ;2111
0000fe  2000              MOVS     r0,#0                 ;2113
000100  e7b3              B        |L8.106|
;;;2116   
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      ||.constdata||
                  |L8.264|
000108  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
00010c  3a3b3c3d
000110  3e3f5b5d
000114  7c7f00  
000117  00                DCB      0

                          AREA ||i.dec_lock||, CODE, READONLY, ALIGN=2

                  dec_lock PROC
;;;729    static
;;;730    FRESULT dec_lock (	/* Decrement object open counter */
000000  1e40              SUBS     r0,r0,#1
;;;731    	UINT i			/* Semaphore index (1..) */
;;;732    )
;;;733    {
;;;734    	WORD n;
;;;735    	FRESULT res;
;;;736    
;;;737    
;;;738    	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
000002  280c              CMP      r0,#0xc
000004  d213              BCS      |L9.46|
;;;739    		n = Files[i].ctr;
000006  4b0b              LDR      r3,|L9.52|
000008  eb000240          ADD      r2,r0,r0,LSL #1
00000c  eb030182          ADD      r1,r3,r2,LSL #2
000010  8948              LDRH     r0,[r1,#0xa]
;;;740    		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
000012  f5b07f80          CMP      r0,#0x100
000016  d100              BNE      |L9.26|
000018  2000              MOVS     r0,#0
                  |L9.26|
;;;741    		if (n) n--;					/* Decrement read mode open count */
00001a  b108              CBZ      r0,|L9.32|
00001c  1e40              SUBS     r0,r0,#1
00001e  b280              UXTH     r0,r0
                  |L9.32|
;;;742    		Files[i].ctr = n;
000020  8148              STRH     r0,[r1,#0xa]
;;;743    		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
000022  b910              CBNZ     r0,|L9.42|
000024  2000              MOVS     r0,#0
000026  f8430022          STR      r0,[r3,r2,LSL #2]
                  |L9.42|
;;;744    		res = FR_OK;
00002a  2000              MOVS     r0,#0
;;;745    	} else {
;;;746    		res = FR_INT_ERR;			/* Invalid index nunber */
;;;747    	}
;;;748    	return res;
;;;749    }
00002c  4770              BX       lr
                  |L9.46|
00002e  2002              MOVS     r0,#2                 ;746
000030  4770              BX       lr
;;;750    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      ||.bss||

                          AREA ||i.dir_alloc||, CODE, READONLY, ALIGN=1

                  dir_alloc PROC
;;;1271   static
;;;1272   FRESULT dir_alloc (
000000  b570              PUSH     {r4-r6,lr}
;;;1273   	DIR* dp,	/* Pointer to the directory object */
;;;1274   	UINT nent	/* Number of contiguous entries to allocate (1-21) */
;;;1275   )
;;;1276   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1277   	FRESULT res;
;;;1278   	UINT n;
;;;1279   
;;;1280   
;;;1281   	res = dir_sdi(dp, 0);
000006  2100              MOVS     r1,#0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dir_sdi
;;;1282   	if (res == FR_OK) {
00000e  b9a0              CBNZ     r0,|L10.58|
;;;1283   		n = 0;
000010  2400              MOVS     r4,#0
                  |L10.18|
;;;1284   		do {
;;;1285   			res = move_window(dp->fs, dp->sect);
000012  f8d51210          LDR      r1,[r5,#0x210]
000016  f8d50200          LDR      r0,[r5,#0x200]
00001a  f7fffffe          BL       move_window
;;;1286   			if (res != FR_OK) break;
00001e  b960              CBNZ     r0,|L10.58|
;;;1287   			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
000020  f8d51214          LDR      r1,[r5,#0x214]
000024  7809              LDRB     r1,[r1,#0]
000026  29e5              CMP      r1,#0xe5
000028  d00b              BEQ      |L10.66|
00002a  b151              CBZ      r1,|L10.66|
;;;1288   				if (++n == nent) break;	/* A block of contiguous free entries is found */
;;;1289   			} else {
;;;1290   				n = 0;					/* Not a blank entry. Restart to search */
00002c  2400              MOVS     r4,#0
                  |L10.46|
;;;1291   			}
;;;1292   			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
00002e  2101              MOVS     r1,#1
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       dir_next
;;;1293   		} while (res == FR_OK);
000036  2800              CMP      r0,#0
000038  d0eb              BEQ      |L10.18|
                  |L10.58|
;;;1294   	}
;;;1295   	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
00003a  2804              CMP      r0,#4
00003c  d100              BNE      |L10.64|
00003e  2007              MOVS     r0,#7
                  |L10.64|
;;;1296   	return res;
;;;1297   }
000040  bd70              POP      {r4-r6,pc}
                  |L10.66|
000042  1c64              ADDS     r4,r4,#1              ;1288
000044  42b4              CMP      r4,r6                 ;1288
000046  d0f8              BEQ      |L10.58|
000048  e7f1              B        |L10.46|
;;;1298   #endif
                          ENDP


                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;1527   static
;;;1528   FRESULT dir_find (
000000  b570              PUSH     {r4-r6,lr}
;;;1529   	DIR* dp			/* Pointer to the directory object linked to the file name */
;;;1530   )
;;;1531   {
000002  4604              MOV      r4,r0
;;;1532   	FRESULT res;
;;;1533   	BYTE c, *dir;
;;;1534   #if _USE_LFN
;;;1535   	BYTE a, ord, sum;
;;;1536   #endif
;;;1537   
;;;1538   	res = dir_sdi(dp, 0);			/* Rewind directory object */
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       dir_sdi
;;;1539   	if (res != FR_OK) return res;
00000c  2800              CMP      r0,#0
00000e  d11c              BNE      |L11.74|
                  |L11.16|
;;;1540   
;;;1541   #if _USE_LFN
;;;1542   	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1543   #endif
;;;1544   	do {
;;;1545   		res = move_window(dp->fs, dp->sect);
000010  f8d41210          LDR      r1,[r4,#0x210]
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f7fffffe          BL       move_window
00001c  4605              MOV      r5,r0
;;;1546   		if (res != FR_OK) break;
00001e  b99d              CBNZ     r5,|L11.72|
;;;1547   		dir = dp->dir;					/* Ptr to the directory entry of current index */
000020  f8d40214          LDR      r0,[r4,#0x214]
;;;1548   		c = dir[DIR_Name];
000024  7801              LDRB     r1,[r0,#0]
;;;1549   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000026  b189              CBZ      r1,|L11.76|
;;;1550   #if _USE_LFN	/* LFN configuration */
;;;1551   		a = dir[DIR_Attr] & AM_MASK;
;;;1552   		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;1553   			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1554   		} else {
;;;1555   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1556   				if (dp->lfn) {
;;;1557   					if (c & LLEF) {		/* Is it start of LFN sequence? */
;;;1558   						sum = dir[LDIR_Chksum];
;;;1559   						c &= ~LLEF; ord = c;	/* LFN start order */
;;;1560   						dp->lfn_idx = dp->index;	/* Start index of LFN */
;;;1561   					}
;;;1562   					/* Check validity of the LFN entry and compare it with given name */
;;;1563   					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1564   				}
;;;1565   			} else {					/* An SFN entry is found */
;;;1566   				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
;;;1567   				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
;;;1568   				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1569   			}
;;;1570   		}
;;;1571   #else		/* Non LFN configuration */
;;;1572   		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
000028  7ac1              LDRB     r1,[r0,#0xb]
00002a  0709              LSLS     r1,r1,#28
00002c  d405              BMI      |L11.58|
00002e  220b              MOVS     r2,#0xb
000030  f8d41218          LDR      r1,[r4,#0x218]
000034  f7fffffe          BL       mem_cmp
000038  b130              CBZ      r0,|L11.72|
                  |L11.58|
;;;1573   			break;
;;;1574   #endif
;;;1575   		res = dir_next(dp, 0);		/* Next entry */
00003a  2100              MOVS     r1,#0
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       dir_next
000042  4605              MOV      r5,r0
;;;1576   	} while (res == FR_OK);
000044  2d00              CMP      r5,#0
000046  d0e3              BEQ      |L11.16|
                  |L11.72|
;;;1577   
;;;1578   	return res;
000048  4628              MOV      r0,r5
                  |L11.74|
;;;1579   }
00004a  bd70              POP      {r4-r6,pc}
                  |L11.76|
00004c  2504              MOVS     r5,#4                 ;1549
00004e  e7fb              B        |L11.72|
;;;1580   
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1200   static
;;;1201   FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1202   	DIR* dp,		/* Pointer to the directory object */
;;;1203   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1204   )
;;;1205   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1206   	DWORD clst;
;;;1207   	UINT i;
;;;1208   #if !_FS_READONLY
;;;1209   	UINT c;
;;;1210   #endif
;;;1211   
;;;1212   
;;;1213   	i = dp->index + 1;
000008  f8b47206          LDRH     r7,[r4,#0x206]
00000c  1c7f              ADDS     r7,r7,#1
;;;1214   	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
00000e  0438              LSLS     r0,r7,#16
000010  0c00              LSRS     r0,r0,#16
000012  d005              BEQ      |L12.32|
000014  f8d40210          LDR      r0,[r4,#0x210]
000018  b110              CBZ      r0,|L12.32|
;;;1215   		return FR_NO_FILE;
;;;1216   
;;;1217   	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
00001a  0739              LSLS     r1,r7,#28
00001c  d003              BEQ      |L12.38|
00001e  e080              B        |L12.290|
                  |L12.32|
000020  2004              MOVS     r0,#4                 ;1215
                  |L12.34|
;;;1218   		dp->sect++;					/* Next sector */
;;;1219   
;;;1220   		if (!dp->clust) {		/* Static table */
;;;1221   			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
;;;1222   				return FR_NO_FILE;
;;;1223   		}
;;;1224   		else {					/* Dynamic table */
;;;1225   			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
;;;1226   				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
;;;1227   				if (clst <= 1) return FR_INT_ERR;
;;;1228   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;;;1229   				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
;;;1230   #if !_FS_READONLY
;;;1231   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
;;;1232   					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
;;;1233   					if (clst == 0) return FR_DENIED;			/* No free cluster */
;;;1234   					if (clst == 1) return FR_INT_ERR;
;;;1235   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;;;1236   					/* Clean-up stretched table */
;;;1237   					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
;;;1238   					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
;;;1239   					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
;;;1240   					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1241   						dp->fs->wflag = 1;
;;;1242   						if (sync_window(dp->fs)) return FR_DISK_ERR;
;;;1243   						dp->fs->winsect++;
;;;1244   					}
;;;1245   					dp->fs->winsect -= c;						/* Rewind window offset */
;;;1246   #else
;;;1247   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
;;;1248   					return FR_NO_FILE;							/* Report EOT */
;;;1249   #endif
;;;1250   				}
;;;1251   				dp->clust = clst;				/* Initialize data for new cluster */
;;;1252   				dp->sect = clust2sect(dp->fs, clst);
;;;1253   			}
;;;1254   		}
;;;1255   	}
;;;1256   
;;;1257   	dp->index = (WORD)i;	/* Current index */
;;;1258   	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
;;;1259   
;;;1260   	return FR_OK;
;;;1261   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L12.38|
000026  1c40              ADDS     r0,r0,#1              ;1218
000028  f8c40210          STR      r0,[r4,#0x210]        ;1218
00002c  f8d4120c          LDR      r1,[r4,#0x20c]        ;1220
000030  b141              CBZ      r1,|L12.68|
000032  f8d40200          LDR      r0,[r4,#0x200]        ;1225
000036  f8902202          LDRB     r2,[r0,#0x202]        ;1225
00003a  1e52              SUBS     r2,r2,#1              ;1225
00003c  ea121f17          TST      r2,r7,LSR #4          ;1225
000040  d008              BEQ      |L12.84|
000042  e06e              B        |L12.290|
                  |L12.68|
000044  f8d40200          LDR      r0,[r4,#0x200]        ;1221
000048  f8b00208          LDRH     r0,[r0,#0x208]        ;1221
00004c  42b8              CMP      r0,r7                 ;1221
00004e  d868              BHI      |L12.290|
000050  2004              MOVS     r0,#4                 ;1222
000052  e7e6              B        |L12.34|
                  |L12.84|
000054  f7fffffe          BL       get_fat
000058  4605              MOV      r5,r0                 ;1226
00005a  2d01              CMP      r5,#1                 ;1227
00005c  d801              BHI      |L12.98|
00005e  2002              MOVS     r0,#2                 ;1227
000060  e7df              B        |L12.34|
                  |L12.98|
000062  1c68              ADDS     r0,r5,#1              ;1228
000064  d018              BEQ      |L12.152|
000066  f8d40200          LDR      r0,[r4,#0x200]        ;1229
00006a  f8d01214          LDR      r1,[r0,#0x214]        ;1229
00006e  42a9              CMP      r1,r5                 ;1229
000070  d84e              BHI      |L12.272|
000072  b19e              CBZ      r6,|L12.156|
000074  f8d4120c          LDR      r1,[r4,#0x20c]        ;1232
000078  f7fffffe          BL       create_chain
00007c  4605              MOV      r5,r0                 ;1232
00007e  0028              MOVS     r0,r5                 ;1233
000080  d00e              BEQ      |L12.160|
000082  2d01              CMP      r5,#1                 ;1234
000084  d00e              BEQ      |L12.164|
000086  1c68              ADDS     r0,r5,#1              ;1235
000088  d00e              BEQ      |L12.168|
00008a  f8d40200          LDR      r0,[r4,#0x200]        ;1237
00008e  f7fffffe          BL       sync_window
000092  b158              CBZ      r0,|L12.172|
000094  2001              MOVS     r0,#1                 ;1237
000096  e7c4              B        |L12.34|
                  |L12.152|
000098  2001              MOVS     r0,#1                 ;1228
00009a  e7c2              B        |L12.34|
                  |L12.156|
00009c  2004              MOVS     r0,#4                 ;1231
00009e  e7c0              B        |L12.34|
                  |L12.160|
0000a0  2007              MOVS     r0,#7                 ;1233
0000a2  e7be              B        |L12.34|
                  |L12.164|
0000a4  2002              MOVS     r0,#2                 ;1234
0000a6  e7bc              B        |L12.34|
                  |L12.168|
0000a8  2001              MOVS     r0,#1                 ;1235
0000aa  e7ba              B        |L12.34|
                  |L12.172|
0000ac  f44f7200          MOV      r2,#0x200             ;1238
0000b0  2100              MOVS     r1,#0                 ;1238
0000b2  f8d40200          LDR      r0,[r4,#0x200]        ;1238
0000b6  f7fffffe          BL       mem_set
0000ba  4629              MOV      r1,r5                 ;1239
0000bc  f8d40200          LDR      r0,[r4,#0x200]        ;1239
0000c0  f7fffffe          BL       clust2sect
0000c4  f8d41200          LDR      r1,[r4,#0x200]        ;1239
0000c8  f8c1022c          STR      r0,[r1,#0x22c]        ;1239
0000cc  2600              MOVS     r6,#0                 ;1240
0000ce  f04f0801          MOV      r8,#1                 ;1228
0000d2  e010              B        |L12.246|
                  |L12.212|
0000d4  f8808204          STRB     r8,[r0,#0x204]        ;1241
0000d8  f8d40200          LDR      r0,[r4,#0x200]        ;1242
0000dc  f7fffffe          BL       sync_window
0000e0  b108              CBZ      r0,|L12.230|
0000e2  2001              MOVS     r0,#1                 ;1242
0000e4  e79d              B        |L12.34|
                  |L12.230|
0000e6  f8d40200          LDR      r0,[r4,#0x200]        ;1243
0000ea  f8d0122c          LDR      r1,[r0,#0x22c]        ;1243
0000ee  1c49              ADDS     r1,r1,#1              ;1243
0000f0  f8c0122c          STR      r1,[r0,#0x22c]        ;1243
0000f4  1c76              ADDS     r6,r6,#1              ;1240
                  |L12.246|
0000f6  f8d40200          LDR      r0,[r4,#0x200]        ;1240
0000fa  f8901202          LDRB     r1,[r0,#0x202]        ;1240
0000fe  42b1              CMP      r1,r6                 ;1240
000100  d8e8              BHI      |L12.212|
000102  f8d41200          LDR      r1,[r4,#0x200]        ;1245
000106  f8d1122c          LDR      r1,[r1,#0x22c]        ;1245
00010a  1b89              SUBS     r1,r1,r6              ;1245
00010c  f8c0122c          STR      r1,[r0,#0x22c]        ;1245
                  |L12.272|
000110  f8c4520c          STR      r5,[r4,#0x20c]        ;1251
000114  4629              MOV      r1,r5                 ;1252
000116  f8d40200          LDR      r0,[r4,#0x200]        ;1252
00011a  f7fffffe          BL       clust2sect
00011e  f8c40210          STR      r0,[r4,#0x210]        ;1252
                  |L12.290|
000122  f5047400          ADD      r4,r4,#0x200          ;1257
000126  80e7              STRH     r7,[r4,#6]            ;1257
000128  6820              LDR      r0,[r4,#0]            ;1258
00012a  f007010f          AND      r1,r7,#0xf            ;1258
00012e  eb001041          ADD      r0,r0,r1,LSL #5       ;1258
000132  6160              STR      r0,[r4,#0x14]         ;1258
000134  2000              MOVS     r0,#0                 ;1260
000136  e774              B        |L12.34|
;;;1262   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;1588   static
;;;1589   FRESULT dir_read (
000000  b570              PUSH     {r4-r6,lr}
;;;1590   	DIR* dp,		/* Pointer to the directory object */
;;;1591   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;1592   )
;;;1593   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1594   	FRESULT res;
;;;1595   	BYTE a, c, *dir;
;;;1596   #if _USE_LFN
;;;1597   	BYTE ord = 0xFF, sum = 0xFF;
;;;1598   #endif
;;;1599   
;;;1600   	res = FR_NO_FILE;
000006  2004              MOVS     r0,#4
000008  e022              B        |L13.80|
                  |L13.10|
;;;1601   	while (dp->sect) {
;;;1602   		res = move_window(dp->fs, dp->sect);
00000a  f8d40200          LDR      r0,[r4,#0x200]
00000e  f7fffffe          BL       move_window
;;;1603   		if (res != FR_OK) break;
000012  bb08              CBNZ     r0,|L13.88|
;;;1604   		dir = dp->dir;					/* Ptr to the directory entry of current index */
000014  f8d42214          LDR      r2,[r4,#0x214]
;;;1605   		c = dir[DIR_Name];
000018  7811              LDRB     r1,[r2,#0]
;;;1606   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
00001a  b1a9              CBZ      r1,|L13.72|
;;;1607   		a = dir[DIR_Attr] & AM_MASK;
00001c  7ad2              LDRB     r2,[r2,#0xb]
00001e  f002023f          AND      r2,r2,#0x3f
;;;1608   #if _USE_LFN	/* LFN configuration */
;;;1609   		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
;;;1610   			ord = 0xFF;
;;;1611   		} else {
;;;1612   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1613   				if (c & LLEF) {			/* Is it start of LFN sequence? */
;;;1614   					sum = dir[LDIR_Chksum];
;;;1615   					c &= ~LLEF; ord = c;
;;;1616   					dp->lfn_idx = dp->index;
;;;1617   				}
;;;1618   				/* Check LFN validity and capture it */
;;;1619   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1620   			} else {					/* An SFN entry is found */
;;;1621   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
;;;1622   					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1623   				break;
;;;1624   			}
;;;1625   		}
;;;1626   #else		/* Non LFN configuration */
;;;1627   		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
000022  29e5              CMP      r1,#0xe5
000024  d00a              BEQ      |L13.60|
000026  292e              CMP      r1,#0x2e
000028  d008              BEQ      |L13.60|
00002a  2a0f              CMP      r2,#0xf
00002c  d006              BEQ      |L13.60|
00002e  f0220120          BIC      r1,r2,#0x20
000032  2908              CMP      r1,#8
000034  d00a              BEQ      |L13.76|
000036  2100              MOVS     r1,#0
                  |L13.56|
000038  42a9              CMP      r1,r5
00003a  d00d              BEQ      |L13.88|
                  |L13.60|
;;;1628   			break;
;;;1629   #endif
;;;1630   		res = dir_next(dp, 0);				/* Next entry */
00003c  2100              MOVS     r1,#0
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       dir_next
;;;1631   		if (res != FR_OK) break;
000044  b120              CBZ      r0,|L13.80|
000046  e007              B        |L13.88|
                  |L13.72|
000048  2004              MOVS     r0,#4                 ;1606
00004a  e005              B        |L13.88|
                  |L13.76|
00004c  2101              MOVS     r1,#1                 ;1627
00004e  e7f3              B        |L13.56|
                  |L13.80|
000050  f8d41210          LDR      r1,[r4,#0x210]        ;1601
000054  2900              CMP      r1,#0                 ;1601
000056  d1d8              BNE      |L13.10|
                  |L13.88|
;;;1632   	}
;;;1633   
;;;1634   	if (res != FR_OK) dp->sect = 0;
000058  2800              CMP      r0,#0
00005a  d002              BEQ      |L13.98|
00005c  2100              MOVS     r1,#0
00005e  f8c41210          STR      r1,[r4,#0x210]
                  |L13.98|
;;;1635   
;;;1636   	return res;
;;;1637   }
000062  bd70              POP      {r4-r6,pc}
;;;1638   #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;1647   static
;;;1648   FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1649   	DIR* dp				/* Target directory with object name to be created */
;;;1650   )
;;;1651   {
000002  4604              MOV      r4,r0
;;;1652   	FRESULT res;
;;;1653   #if _USE_LFN	/* LFN configuration */
;;;1654   	UINT n, nent;
;;;1655   	BYTE sn[12], *fn, sum;
;;;1656   	WCHAR *lfn;
;;;1657   
;;;1658   
;;;1659   	fn = dp->fn; lfn = dp->lfn;
;;;1660   	mem_cpy(sn, fn, 12);
;;;1661   
;;;1662   	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
;;;1663   		return FR_INVALID_NAME;
;;;1664   
;;;1665   	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;1666   		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
;;;1667   		for (n = 1; n < 100; n++) {
;;;1668   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;1669   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;1670   			if (res != FR_OK) break;
;;;1671   		}
;;;1672   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;1673   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;1674   		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
;;;1675   	}
;;;1676   
;;;1677   	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
;;;1678   		for (n = 0; lfn[n]; n++) ;
;;;1679   		nent = (n + 25) / 13;
;;;1680   	} else {						/* Otherwise allocate an entry for an SFN  */
;;;1681   		nent = 1;
;;;1682   	}
;;;1683   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;1684   
;;;1685   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;1686   		res = dir_sdi(dp, dp->index - nent);
;;;1687   		if (res == FR_OK) {
;;;1688   			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
;;;1689   			do {					/* Store LFN entries in bottom first */
;;;1690   				res = move_window(dp->fs, dp->sect);
;;;1691   				if (res != FR_OK) break;
;;;1692   				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
;;;1693   				dp->fs->wflag = 1;
;;;1694   				res = dir_next(dp, 0);	/* Next entry */
;;;1695   			} while (res == FR_OK && --nent);
;;;1696   		}
;;;1697   	}
;;;1698   #else	/* Non LFN configuration */
;;;1699   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       dir_alloc
00000c  4605              MOV      r5,r0
;;;1700   #endif
;;;1701   
;;;1702   	if (res == FR_OK) {				/* Set SFN entry */
00000e  b9bd              CBNZ     r5,|L14.64|
;;;1703   		res = move_window(dp->fs, dp->sect);
000010  f8d41210          LDR      r1,[r4,#0x210]
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f7fffffe          BL       move_window
00001c  4605              MOV      r5,r0
;;;1704   		if (res == FR_OK) {
00001e  b97d              CBNZ     r5,|L14.64|
;;;1705   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
000020  f5047400          ADD      r4,r4,#0x200
000024  2220              MOVS     r2,#0x20
000026  2100              MOVS     r1,#0
000028  6960              LDR      r0,[r4,#0x14]
00002a  f7fffffe          BL       mem_set
;;;1706   			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
00002e  e9d40105          LDRD     r0,r1,[r4,#0x14]
000032  220b              MOVS     r2,#0xb
000034  f7fffffe          BL       mem_cpy
;;;1707   #if _USE_LFN
;;;1708   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1709   #endif
;;;1710   			dp->fs->wflag = 1;
000038  6821              LDR      r1,[r4,#0]
00003a  2001              MOVS     r0,#1
00003c  f8810204          STRB     r0,[r1,#0x204]
                  |L14.64|
;;;1711   		}
;;;1712   	}
;;;1713   
;;;1714   	return res;
000040  4628              MOV      r0,r5
;;;1715   }
000042  bd70              POP      {r4-r6,pc}
;;;1716   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1725   static
;;;1726   FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1727   	DIR* dp				/* Directory object pointing the entry to be removed */
;;;1728   )
;;;1729   {
000002  4604              MOV      r4,r0
;;;1730   	FRESULT res;
;;;1731   #if _USE_LFN	/* LFN configuration */
;;;1732   	UINT i;
;;;1733   
;;;1734   	i = dp->index;	/* SFN index */
;;;1735   	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
;;;1736   	if (res == FR_OK) {
;;;1737   		do {
;;;1738   			res = move_window(dp->fs, dp->sect);
;;;1739   			if (res != FR_OK) break;
;;;1740   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
;;;1741   			*dp->dir = DDEM;
;;;1742   			dp->fs->wflag = 1;
;;;1743   			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;;;1744   			res = dir_next(dp, 0);		/* Next entry */
;;;1745   		} while (res == FR_OK);
;;;1746   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;1747   	}
;;;1748   
;;;1749   #else			/* Non LFN configuration */
;;;1750   	res = dir_sdi(dp, dp->index);
000004  4620              MOV      r0,r4
000006  f8b41206          LDRH     r1,[r4,#0x206]
00000a  f7fffffe          BL       dir_sdi
00000e  4605              MOV      r5,r0
;;;1751   	if (res == FR_OK) {
000010  b9ad              CBNZ     r5,|L15.62|
;;;1752   		res = move_window(dp->fs, dp->sect);
000012  f8d41210          LDR      r1,[r4,#0x210]
000016  f8d40200          LDR      r0,[r4,#0x200]
00001a  f7fffffe          BL       move_window
00001e  4605              MOV      r5,r0
;;;1753   		if (res == FR_OK) {
000020  b96d              CBNZ     r5,|L15.62|
;;;1754   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
000022  f5047400          ADD      r4,r4,#0x200
000026  2220              MOVS     r2,#0x20
000028  2100              MOVS     r1,#0
00002a  6960              LDR      r0,[r4,#0x14]
00002c  f7fffffe          BL       mem_set
;;;1755   			*dp->dir = DDEM;
000030  6961              LDR      r1,[r4,#0x14]
000032  20e5              MOVS     r0,#0xe5
000034  7008              STRB     r0,[r1,#0]
;;;1756   			dp->fs->wflag = 1;
000036  6821              LDR      r1,[r4,#0]
000038  2001              MOVS     r0,#1
00003a  f8810204          STRB     r0,[r1,#0x204]
                  |L15.62|
;;;1757   		}
;;;1758   	}
;;;1759   #endif
;;;1760   
;;;1761   	return res;
00003e  4628              MOV      r0,r5
;;;1762   }
000040  bd70              POP      {r4-r6,pc}
;;;1763   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1152   static
;;;1153   FRESULT dir_sdi (
000000  b570              PUSH     {r4-r6,lr}
;;;1154   	DIR* dp,		/* Pointer to directory object */
;;;1155   	UINT idx		/* Index of directory table */
;;;1156   )
;;;1157   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1158   	DWORD clst, sect;
;;;1159   	UINT ic;
;;;1160   
;;;1161   
;;;1162   	dp->index = (WORD)idx;	/* Current index */
000006  f8a45206          STRH     r5,[r4,#0x206]
;;;1163   	clst = dp->sclust;		/* Table start cluster (0:root) */
00000a  f8d43208          LDR      r3,[r4,#0x208]
;;;1164   	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
00000e  2b01              CMP      r3,#1
000010  d005              BEQ      |L16.30|
000012  f8d40200          LDR      r0,[r4,#0x200]
000016  f8d01214          LDR      r1,[r0,#0x214]
00001a  4299              CMP      r1,r3
00001c  d801              BHI      |L16.34|
                  |L16.30|
;;;1165   		return FR_INT_ERR;
00001e  2002              MOVS     r0,#2
;;;1166   	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
;;;1167   		clst = dp->fs->dirbase;
;;;1168   
;;;1169   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1170   		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
;;;1171   			return FR_INT_ERR;
;;;1172   		sect = dp->fs->dirbase;
;;;1173   	}
;;;1174   	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
;;;1175   		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
;;;1176   		while (idx >= ic) {	/* Follow cluster chain */
;;;1177   			clst = get_fat(dp->fs, clst);				/* Get next cluster */
;;;1178   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1179   			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
;;;1180   				return FR_INT_ERR;
;;;1181   			idx -= ic;
;;;1182   		}
;;;1183   		sect = clust2sect(dp->fs, clst);
;;;1184   	}
;;;1185   	dp->clust = clst;	/* Current cluster# */
;;;1186   	if (!sect) return FR_INT_ERR;
;;;1187   	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
;;;1188   	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
;;;1189   
;;;1190   	return FR_OK;
;;;1191   }
000020  bd70              POP      {r4-r6,pc}
                  |L16.34|
000022  b92b              CBNZ     r3,|L16.48|
000024  f8901200          LDRB     r1,[r0,#0x200]        ;1166
000028  2903              CMP      r1,#3                 ;1166
00002a  d101              BNE      |L16.48|
00002c  f8d03224          LDR      r3,[r0,#0x224]        ;1167
                  |L16.48|
000030  b11b              CBZ      r3,|L16.58|
000032  f8900202          LDRB     r0,[r0,#0x202]        ;1175
000036  0106              LSLS     r6,r0,#4              ;1175
000038  e01d              B        |L16.118|
                  |L16.58|
00003a  f8b01208          LDRH     r1,[r0,#0x208]        ;1170
00003e  42a9              CMP      r1,r5                 ;1170
000040  d801              BHI      |L16.70|
000042  2002              MOVS     r0,#2                 ;1171
000044  bd70              POP      {r4-r6,pc}
                  |L16.70|
000046  f8d00224          LDR      r0,[r0,#0x224]        ;1172
00004a  e01b              B        |L16.132|
                  |L16.76|
00004c  4619              MOV      r1,r3                 ;1177
00004e  f8d40200          LDR      r0,[r4,#0x200]        ;1177
000052  f7fffffe          BL       get_fat
000056  4603              MOV      r3,r0                 ;1177
000058  1c58              ADDS     r0,r3,#1              ;1178
00005a  d009              BEQ      |L16.112|
00005c  2b02              CMP      r3,#2                 ;1179
00005e  d305              BCC      |L16.108|
000060  f8d40200          LDR      r0,[r4,#0x200]        ;1179
000064  f8d00214          LDR      r0,[r0,#0x214]        ;1179
000068  4298              CMP      r0,r3                 ;1179
00006a  d803              BHI      |L16.116|
                  |L16.108|
00006c  2002              MOVS     r0,#2                 ;1180
00006e  bd70              POP      {r4-r6,pc}
                  |L16.112|
000070  2001              MOVS     r0,#1                 ;1178
000072  bd70              POP      {r4-r6,pc}
                  |L16.116|
000074  1bad              SUBS     r5,r5,r6              ;1181
                  |L16.118|
000076  42b5              CMP      r5,r6                 ;1176
000078  d2e8              BCS      |L16.76|
00007a  4619              MOV      r1,r3                 ;1183
00007c  f8d40200          LDR      r0,[r4,#0x200]        ;1183
000080  f7fffffe          BL       clust2sect
                  |L16.132|
000084  f8c4320c          STR      r3,[r4,#0x20c]        ;1185
000088  b160              CBZ      r0,|L16.164|
00008a  f5047400          ADD      r4,r4,#0x200          ;1187
00008e  eb001015          ADD      r0,r0,r5,LSR #4       ;1187
000092  6120              STR      r0,[r4,#0x10]         ;1187
000094  6820              LDR      r0,[r4,#0]            ;1188
000096  f005010f          AND      r1,r5,#0xf            ;1188
00009a  eb001041          ADD      r0,r0,r1,LSL #5       ;1188
00009e  6160              STR      r0,[r4,#0x14]         ;1188
0000a0  2000              MOVS     r0,#0                 ;1190
0000a2  bd70              POP      {r4-r6,pc}
                  |L16.164|
0000a4  2002              MOVS     r0,#2                 ;1186
0000a6  bd70              POP      {r4-r6,pc}
;;;1192   
                          ENDP


                          AREA ||i.enq_lock||, CODE, READONLY, ALIGN=2

                  enq_lock PROC
;;;687    static
;;;688    int enq_lock (void)	/* Check if an entry is available for a new object */
000000  2000              MOVS     r0,#0
;;;689    {
;;;690    	UINT i;
;;;691    
;;;692    	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
000002  4908              LDR      r1,|L17.36|
000004  e000              B        |L17.8|
                  |L17.6|
000006  1c40              ADDS     r0,r0,#1
                  |L17.8|
000008  280c              CMP      r0,#0xc
00000a  d205              BCS      |L17.24|
00000c  eb000240          ADD      r2,r0,r0,LSL #1
000010  f8512022          LDR      r2,[r1,r2,LSL #2]
000014  2a00              CMP      r2,#0
000016  d1f6              BNE      |L17.6|
                  |L17.24|
;;;693    	return (i == _FS_LOCK) ? 0 : 1;
000018  280c              CMP      r0,#0xc
00001a  d001              BEQ      |L17.32|
00001c  2001              MOVS     r0,#1
;;;694    }
00001e  4770              BX       lr
                  |L17.32|
000020  2000              MOVS     r0,#0                 ;693
000022  4770              BX       lr
;;;695    
                          ENDP

                  |L17.36|
                          DCD      ||.bss||

                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3742   
;;;3743   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3744   	const TCHAR* path,	/* Pointer to the file path */
;;;3745   	BYTE attr,			/* Attribute bits */
;;;3746   	BYTE mask			/* Attribute mask to change */
;;;3747   )
;;;3748   {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;3749   	FRESULT res;
;;;3750   	DIR dj;
;;;3751   	BYTE *dir;
;;;3752   	DEFINE_NAMEBUF;
;;;3753   
;;;3754   
;;;3755   	/* Get logical drive number */
;;;3756   	res = find_volume(&dj.fs, &path, 1);
00000a  2201              MOVS     r2,#1
00000c  a98c              ADD      r1,sp,#0x230
00000e  a884              ADD      r0,sp,#0x210
000010  f7fffffe          BL       find_volume
;;;3757   	if (res == FR_OK) {
000014  2800              CMP      r0,#0
000016  d117              BNE      |L18.72|
;;;3758   		INIT_BUF(dj);
000018  a801              ADD      r0,sp,#4
00001a  908a              STR      r0,[sp,#0x228]
;;;3759   		res = follow_path(&dj, path);		/* Follow the file path */
00001c  a804              ADD      r0,sp,#0x10
00001e  998c              LDR      r1,[sp,#0x230]
000020  f7fffffe          BL       follow_path
;;;3760   		FREE_BUF();
;;;3761   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3762   			res = FR_INVALID_NAME;
;;;3763   		if (res == FR_OK) {
000024  2800              CMP      r0,#0
000026  d10f              BNE      |L18.72|
;;;3764   			dir = dj.dir;
000028  9889              LDR      r0,[sp,#0x224]
;;;3765   			if (!dir) {						/* Is it a root directory? */
00002a  b180              CBZ      r0,|L18.78|
;;;3766   				res = FR_INVALID_NAME;
;;;3767   			} else {						/* File or sub directory */
;;;3768   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
00002c  f0050227          AND      r2,r5,#0x27
;;;3769   				dir[DIR_Attr] = (attr & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
000030  7ac1              LDRB     r1,[r0,#0xb]
000032  4014              ANDS     r4,r4,r2
000034  4391              BICS     r1,r1,r2
000036  430c              ORRS     r4,r4,r1
000038  72c4              STRB     r4,[r0,#0xb]
;;;3770   				dj.fs->wflag = 1;
00003a  9984              LDR      r1,[sp,#0x210]
00003c  2001              MOVS     r0,#1
00003e  f8810204          STRB     r0,[r1,#0x204]
;;;3771   				res = sync_fs(dj.fs);
000042  9884              LDR      r0,[sp,#0x210]
000044  f7fffffe          BL       sync_fs
                  |L18.72|
;;;3772   			}
;;;3773   		}
;;;3774   	}
;;;3775   
;;;3776   	LEAVE_FF(dj.fs, res);
;;;3777   }
000048  f50d7d0f          ADD      sp,sp,#0x23c
00004c  bd30              POP      {r4,r5,pc}
                  |L18.78|
00004e  2006              MOVS     r0,#6                 ;3766
000050  e7fa              B        |L18.72|
;;;3778   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2929   
;;;2930   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2931   	FIL *fp		/* Pointer to the file object to be closed */
;;;2932   )
;;;2933   {
000002  4604              MOV      r4,r0
;;;2934   	FRESULT res;
;;;2935   
;;;2936   
;;;2937   #if !_FS_READONLY
;;;2938   	res = f_sync(fp);					/* Flush cached data */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_sync
;;;2939   	if (res == FR_OK)
00000a  2800              CMP      r0,#0
00000c  d10d              BNE      |L19.42|
;;;2940   #endif
;;;2941   	{
;;;2942   		res = validate(fp);				/* Lock volume */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       validate
;;;2943   		if (res == FR_OK) {
000014  2800              CMP      r0,#0
000016  d108              BNE      |L19.42|
;;;2944   #if _FS_REENTRANT
;;;2945   			FATFS *fs = fp->fs;
;;;2946   #endif
;;;2947   #if _FS_LOCK
;;;2948   			res = dec_lock(fp->lockid);	/* Decrement file open counter */
000018  f8d40228          LDR      r0,[r4,#0x228]
00001c  f7fffffe          BL       dec_lock
;;;2949   			if (res == FR_OK)
000020  2800              CMP      r0,#0
000022  d102              BNE      |L19.42|
;;;2950   #endif
;;;2951   				fp->fs = 0;				/* Invalidate file object */
000024  2100              MOVS     r1,#0
000026  f8c41200          STR      r1,[r4,#0x200]
                  |L19.42|
;;;2952   #if _FS_REENTRANT
;;;2953   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;2954   #endif
;;;2955   		}
;;;2956   	}
;;;2957   	return res;
;;;2958   }
00002a  bd10              POP      {r4,pc}
;;;2959   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;3315   
;;;3316   FRESULT f_closedir (
000000  b510              PUSH     {r4,lr}
;;;3317   	DIR *dp		/* Pointer to the directory object to be closed */
;;;3318   )
;;;3319   {
000002  4604              MOV      r4,r0
;;;3320   	FRESULT res;
;;;3321   
;;;3322   
;;;3323   	res = validate(dp);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
;;;3324   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d10a              BNE      |L20.36|
;;;3325   #if _FS_REENTRANT
;;;3326   		FATFS *fs = dp->fs;
;;;3327   #endif
;;;3328   #if _FS_LOCK
;;;3329   		if (dp->lockid)				/* Decrement sub-directory open counter */
00000e  f8d4121c          LDR      r1,[r4,#0x21c]
000012  b111              CBZ      r1,|L20.26|
;;;3330   			res = dec_lock(dp->lockid);
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       dec_lock
                  |L20.26|
;;;3331   		if (res == FR_OK)
00001a  2800              CMP      r0,#0
00001c  d102              BNE      |L20.36|
;;;3332   #endif
;;;3333   			dp->fs = 0;				/* Invalidate directory object */
00001e  2100              MOVS     r1,#0
000020  f8c41200          STR      r1,[r4,#0x200]
                  |L20.36|
;;;3334   #if _FS_REENTRANT
;;;3335   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3336   #endif
;;;3337   	}
;;;3338   	return res;
;;;3339   }
000024  bd10              POP      {r4,pc}
;;;3340   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3476   
;;;3477   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3478   	const TCHAR* path,	/* Path name of the logical drive number */
;;;3479   	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;;;3480   	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;;;3481   )
;;;3482   {
000004  468b              MOV      r11,r1
000006  4614              MOV      r4,r2
;;;3483   	FRESULT res;
;;;3484   	FATFS *fs;
;;;3485   	DWORD n, clst, sect, stat;
;;;3486   	UINT i;
;;;3487   	BYTE fat, *p;
;;;3488   
;;;3489   
;;;3490   	/* Get logical drive number */
;;;3491   	res = find_volume(fatfs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       find_volume
000012  4680              MOV      r8,r0
;;;3492   	fs = *fatfs;
000014  6826              LDR      r6,[r4,#0]
;;;3493   	if (res == FR_OK) {
000016  ea5f0008          MOVS     r0,r8
00001a  d163              BNE      |L21.228|
;;;3494   		/* If free_clust is valid, return it without full cluster scan */
;;;3495   		if (fs->free_clust <= fs->n_fatent - 2) {
00001c  f8d69214          LDR      r9,[r6,#0x214]
000020  f8d60210          LDR      r0,[r6,#0x210]
000024  f1a90102          SUB      r1,r9,#2
000028  4288              CMP      r0,r1
00002a  d802              BHI      |L21.50|
;;;3496   			*nclst = fs->free_clust;
00002c  f8cb0000          STR      r0,[r11,#0]
000030  e058              B        |L21.228|
                  |L21.50|
;;;3497   		} else {
;;;3498   			/* Get number of free clusters */
;;;3499   			fat = fs->fs_type;
000032  f896a200          LDRB     r10,[r6,#0x200]
;;;3500   			n = 0;
000036  2500              MOVS     r5,#0
;;;3501   			if (fat == FS_FAT12) {
000038  f1ba0f01          CMP      r10,#1
00003c  d005              BEQ      |L21.74|
;;;3502   				clst = 2;
;;;3503   				do {
;;;3504   					stat = get_fat(fs, clst);
;;;3505   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3506   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3507   					if (stat == 0) n++;
;;;3508   				} while (++clst < fs->n_fatent);
;;;3509   			} else {
;;;3510   				clst = fs->n_fatent;
;;;3511   				sect = fs->fatbase;
00003e  f8d67220          LDR      r7,[r6,#0x220]
;;;3512   				i = 0; p = 0;
000042  2000              MOVS     r0,#0
000044  2400              MOVS     r4,#0
                  |L21.70|
;;;3513   				do {
;;;3514   					if (!i) {
000046  b1c0              CBZ      r0,|L21.122|
000048  e023              B        |L21.146|
                  |L21.74|
00004a  2402              MOVS     r4,#2                 ;3502
                  |L21.76|
00004c  4621              MOV      r1,r4                 ;3504
00004e  4630              MOV      r0,r6                 ;3504
000050  f7fffffe          BL       get_fat
000054  1c41              ADDS     r1,r0,#1              ;3505
000056  d003              BEQ      |L21.96|
000058  2801              CMP      r0,#1                 ;3506
00005a  d004              BEQ      |L21.102|
00005c  b130              CBZ      r0,|L21.108|
00005e  e006              B        |L21.110|
                  |L21.96|
000060  f04f0801          MOV      r8,#1                 ;3505
000064  e034              B        |L21.208|
                  |L21.102|
000066  f04f0802          MOV      r8,#2                 ;3506
00006a  e031              B        |L21.208|
                  |L21.108|
00006c  1c6d              ADDS     r5,r5,#1              ;3507
                  |L21.110|
00006e  f8d60214          LDR      r0,[r6,#0x214]        ;3508
000072  1c64              ADDS     r4,r4,#1              ;3508
000074  4284              CMP      r4,r0                 ;3508
000076  d3e9              BCC      |L21.76|
000078  e02a              B        |L21.208|
                  |L21.122|
;;;3515   						res = move_window(fs, sect++);
00007a  4639              MOV      r1,r7
00007c  1c7f              ADDS     r7,r7,#1
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       move_window
000084  4680              MOV      r8,r0
;;;3516   						if (res != FR_OK) break;
000086  ea5f0008          MOVS     r0,r8
00008a  d121              BNE      |L21.208|
;;;3517   						p = fs->win.d8;
00008c  4634              MOV      r4,r6
;;;3518   						i = SS(fs);
00008e  f44f7000          MOV      r0,#0x200
                  |L21.146|
;;;3519   					}
;;;3520   					if (fat == FS_FAT16) {
000092  f1ba0f02          CMP      r10,#2
000096  d00c              BEQ      |L21.178|
;;;3521   						if (LD_WORD(p) == 0) n++;
;;;3522   						p += 2; i -= 2;
;;;3523   					} else {
;;;3524   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
000098  7821              LDRB     r1,[r4,#0]
00009a  78e2              LDRB     r2,[r4,#3]
00009c  7863              LDRB     r3,[r4,#1]
00009e  ea416102          ORR      r1,r1,r2,LSL #24
0000a2  78a2              LDRB     r2,[r4,#2]
0000a4  0412              LSLS     r2,r2,#16
0000a6  ea422203          ORR      r2,r2,r3,LSL #8
0000aa  4311              ORRS     r1,r1,r2
0000ac  0109              LSLS     r1,r1,#4
0000ae  d009              BEQ      |L21.196|
0000b0  e009              B        |L21.198|
                  |L21.178|
0000b2  7821              LDRB     r1,[r4,#0]            ;3521
0000b4  7862              LDRB     r2,[r4,#1]            ;3521
0000b6  ea512102          ORRS     r1,r1,r2,LSL #8       ;3521
0000ba  d100              BNE      |L21.190|
0000bc  1c6d              ADDS     r5,r5,#1              ;3521
                  |L21.190|
0000be  1ca4              ADDS     r4,r4,#2              ;3522
0000c0  1e80              SUBS     r0,r0,#2              ;3522
0000c2  e002              B        |L21.202|
                  |L21.196|
0000c4  1c6d              ADDS     r5,r5,#1
                  |L21.198|
;;;3525   						p += 4; i -= 4;
0000c6  1d24              ADDS     r4,r4,#4
0000c8  1f00              SUBS     r0,r0,#4
                  |L21.202|
;;;3526   					}
;;;3527   				} while (--clst);
0000ca  f1b90901          SUBS     r9,r9,#1
0000ce  d1ba              BNE      |L21.70|
                  |L21.208|
;;;3528   			}
;;;3529   			fs->free_clust = n;
0000d0  f8c65210          STR      r5,[r6,#0x210]
;;;3530   			fs->fsi_flag |= 1;
0000d4  f8960205          LDRB     r0,[r6,#0x205]
0000d8  f0400001          ORR      r0,r0,#1
0000dc  f8860205          STRB     r0,[r6,#0x205]
;;;3531   			*nclst = n;
0000e0  f8cb5000          STR      r5,[r11,#0]
                  |L21.228|
;;;3532   		}
;;;3533   	}
;;;3534   	LEAVE_FF(fs, res);
0000e4  4640              MOV      r0,r8
;;;3535   }
0000e6  e8bd8ffe          POP      {r1-r11,pc}
;;;3536   
                          ENDP


                          AREA ||i.f_gets||, CODE, READONLY, ALIGN=1

                  f_gets PROC
;;;4456   
;;;4457   TCHAR* f_gets (
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;4458   	TCHAR* buff,	/* Pointer to the string buffer to read */
;;;4459   	int len,		/* Size of string buffer (characters) */
;;;4460   	FIL* fp			/* Pointer to the file object */
;;;4461   )
;;;4462   {
000004  4607              MOV      r7,r0
000006  4690              MOV      r8,r2
;;;4463   	int n = 0;
000008  2500              MOVS     r5,#0
;;;4464   	TCHAR c, *p = buff;
00000a  463c              MOV      r4,r7
;;;4465   	BYTE s[2];
;;;4466   	UINT rc;
;;;4467   
;;;4468   
;;;4469   	while (n < len - 1) {	/* Read characters until buffer gets filled */
00000c  1e4e              SUBS     r6,r1,#1
00000e  e011              B        |L22.52|
                  |L22.16|
;;;4470   #if _USE_LFN && _LFN_UNICODE
;;;4471   #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
;;;4472   		f_read(fp, s, 1, &rc);
;;;4473   		if (rc != 1) break;
;;;4474   		c = s[0];
;;;4475   		if (c >= 0x80) {
;;;4476   			if (c < 0xC0) continue;	/* Skip stray trailer */
;;;4477   			if (c < 0xE0) {			/* Two-byte sequence */
;;;4478   				f_read(fp, s, 1, &rc);
;;;4479   				if (rc != 1) break;
;;;4480   				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
;;;4481   				if (c < 0x80) c = '?';
;;;4482   			} else {
;;;4483   				if (c < 0xF0) {		/* Three-byte sequence */
;;;4484   					f_read(fp, s, 2, &rc);
;;;4485   					if (rc != 2) break;
;;;4486   					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
;;;4487   					if (c < 0x800) c = '?';
;;;4488   				} else {			/* Reject four-byte sequence */
;;;4489   					c = '?';
;;;4490   				}
;;;4491   			}
;;;4492   		}
;;;4493   #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
;;;4494   		f_read(fp, s, 2, &rc);
;;;4495   		if (rc != 2) break;
;;;4496   		c = s[1] + (s[0] << 8);
;;;4497   #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
;;;4498   		f_read(fp, s, 2, &rc);
;;;4499   		if (rc != 2) break;
;;;4500   		c = s[0] + (s[1] << 8);
;;;4501   #else						/* Read a character in ANSI/OEM */
;;;4502   		f_read(fp, s, 1, &rc);
;;;4503   		if (rc != 1) break;
;;;4504   		c = s[0];
;;;4505   		if (IsDBCS1(c)) {
;;;4506   			f_read(fp, s, 1, &rc);
;;;4507   			if (rc != 1) break;
;;;4508   			c = (c << 8) + s[0];
;;;4509   		}
;;;4510   		c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;4511   		if (!c) c = '?';
;;;4512   #endif
;;;4513   #else						/* Read a character without conversion */
;;;4514   		f_read(fp, s, 1, &rc);
000010  466b              MOV      r3,sp
000012  2201              MOVS     r2,#1
000014  a901              ADD      r1,sp,#4
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       f_read
;;;4515   		if (rc != 1) break;
00001c  9800              LDR      r0,[sp,#0]
00001e  2801              CMP      r0,#1
000020  d10a              BNE      |L22.56|
;;;4516   		c = s[0];
000022  f89d0004          LDRB     r0,[sp,#4]
;;;4517   #endif
;;;4518   		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
000026  280d              CMP      r0,#0xd
000028  d004              BEQ      |L22.52|
;;;4519   		*p++ = c;
00002a  f8040b01          STRB     r0,[r4],#1
;;;4520   		n++;
00002e  1c6d              ADDS     r5,r5,#1
;;;4521   		if (c == '\n') break;		/* Break on EOL */
000030  280a              CMP      r0,#0xa
000032  d001              BEQ      |L22.56|
                  |L22.52|
000034  42b5              CMP      r5,r6                 ;4469
000036  dbeb              BLT      |L22.16|
                  |L22.56|
;;;4522   	}
;;;4523   	*p = 0;
000038  2000              MOVS     r0,#0
00003a  7020              STRB     r0,[r4,#0]
00003c  b115              CBZ      r5,|L22.68|
;;;4524   	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
00003e  4638              MOV      r0,r7
                  |L22.64|
;;;4525   }
000040  e8bd81fc          POP      {r2-r8,pc}
                  |L22.68|
000044  2000              MOVS     r0,#0                 ;4524
000046  e7fb              B        |L22.64|
;;;4526   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;3101   
;;;3102   FRESULT f_lseek (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3103   	FIL* fp,		/* Pointer to the file object */
;;;3104   	DWORD ofs		/* File pointer from top of file */
;;;3105   )
;;;3106   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3107   	FRESULT res;
;;;3108   	DWORD clst, bcs, nsect, ifptr;
;;;3109   #if _USE_FASTSEEK
;;;3110   	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;3111   #endif
;;;3112   
;;;3113   
;;;3114   	res = validate(fp);					/* Check validity of the object */
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       validate
00000e  9000              STR      r0,[sp,#0]
;;;3115   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000010  9800              LDR      r0,[sp,#0]
000012  b110              CBZ      r0,|L23.26|
000014  9800              LDR      r0,[sp,#0]
                  |L23.22|
;;;3116   	if (fp->err)						/* Check error */
;;;3117   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;3118   
;;;3119   #if _USE_FASTSEEK
;;;3120   	if (fp->cltbl) {	/* Fast seek */
;;;3121   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;3122   			tbl = fp->cltbl;
;;;3123   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;3124   			cl = fp->sclust;			/* Top of the chain */
;;;3125   			if (cl) {
;;;3126   				do {
;;;3127   					/* Get a fragment */
;;;3128   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;3129   					do {
;;;3130   						pcl = cl; ncl++;
;;;3131   						cl = get_fat(fp->fs, cl);
;;;3132   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;3133   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3134   					} while (cl == pcl + 1);
;;;3135   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;3136   						*tbl++ = ncl; *tbl++ = tcl;
;;;3137   					}
;;;3138   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;3139   			}
;;;3140   			*fp->cltbl = ulen;	/* Number of items used */
;;;3141   			if (ulen <= tlen)
;;;3142   				*tbl = 0;		/* Terminate table */
;;;3143   			else
;;;3144   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;3145   
;;;3146   		} else {						/* Fast seek */
;;;3147   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;3148   				ofs = fp->fsize;
;;;3149   			fp->fptr = ofs;				/* Set file pointer */
;;;3150   			if (ofs) {
;;;3151   				fp->clust = clmt_clust(fp, ofs - 1);
;;;3152   				dsc = clust2sect(fp->fs, fp->clust);
;;;3153   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;3154   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;3155   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;3156   #if !_FS_TINY
;;;3157   #if !_FS_READONLY
;;;3158   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;3159   						if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
;;;3160   							ABORT(fp->fs, FR_DISK_ERR);
;;;3161   						fp->flag &= ~FA__DIRTY;
;;;3162   					}
;;;3163   #endif
;;;3164   					if (disk_read(fp->fs->drv, fp->buf.d8, dsc, 1) != RES_OK)	/* Load current sector */
;;;3165   						ABORT(fp->fs, FR_DISK_ERR);
;;;3166   #endif
;;;3167   					fp->dsect = dsc;
;;;3168   				}
;;;3169   			}
;;;3170   		}
;;;3171   	} else
;;;3172   #endif
;;;3173   
;;;3174   	/* Normal Seek */
;;;3175   	{
;;;3176   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;;;3177   #if !_FS_READONLY
;;;3178   			 && !(fp->flag & FA_WRITE)
;;;3179   #endif
;;;3180   			) ofs = fp->fsize;
;;;3181   
;;;3182   		ifptr = fp->fptr;
;;;3183   		fp->fptr = nsect = 0;
;;;3184   		if (ofs) {
;;;3185   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;;;3186   			if (ifptr > 0 &&
;;;3187   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;3188   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;3189   				ofs -= fp->fptr;
;;;3190   				clst = fp->clust;
;;;3191   			} else {									/* When seek to back cluster, */
;;;3192   				clst = fp->sclust;						/* start from the first cluster */
;;;3193   #if !_FS_READONLY
;;;3194   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;3195   					clst = create_chain(fp->fs, 0);
;;;3196   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;3197   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3198   					fp->sclust = clst;
;;;3199   				}
;;;3200   #endif
;;;3201   				fp->clust = clst;
;;;3202   			}
;;;3203   			if (clst != 0) {
;;;3204   				while (ofs > bcs) {						/* Cluster following loop */
;;;3205   #if !_FS_READONLY
;;;3206   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;3207   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
;;;3208   						if (clst == 0) {				/* When disk gets full, clip file size */
;;;3209   							ofs = bcs; break;
;;;3210   						}
;;;3211   					} else
;;;3212   #endif
;;;3213   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;;;3214   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3215   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
;;;3216   					fp->clust = clst;
;;;3217   					fp->fptr += bcs;
;;;3218   					ofs -= bcs;
;;;3219   				}
;;;3220   				fp->fptr += ofs;
;;;3221   				if (ofs % SS(fp->fs)) {
;;;3222   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
;;;3223   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;;;3224   					nsect += ofs / SS(fp->fs);
;;;3225   				}
;;;3226   			}
;;;3227   		}
;;;3228   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
;;;3229   #if !_FS_TINY
;;;3230   #if !_FS_READONLY
;;;3231   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
;;;3232   				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
;;;3233   					ABORT(fp->fs, FR_DISK_ERR);
;;;3234   				fp->flag &= ~FA__DIRTY;
;;;3235   			}
;;;3236   #endif
;;;3237   			if (disk_read(fp->fs->drv, fp->buf.d8, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;3238   				ABORT(fp->fs, FR_DISK_ERR);
;;;3239   #endif
;;;3240   			fp->dsect = nsect;
;;;3241   		}
;;;3242   #if !_FS_READONLY
;;;3243   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;3244   			fp->fsize = fp->fptr;
;;;3245   			fp->flag |= FA__WRITTEN;
;;;3246   		}
;;;3247   #endif
;;;3248   	}
;;;3249   
;;;3250   	LEAVE_FF(fp->fs, res);
;;;3251   }
000016  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.26|
00001a  f8940207          LDRB     r0,[r4,#0x207]        ;3116
00001e  2800              CMP      r0,#0                 ;3116
000020  d1f9              BNE      |L23.22|
000022  f8d47224          LDR      r7,[r4,#0x224]        ;3120
000026  f04f0a01          MOV      r10,#1                ;3133
00002a  2f00              CMP      r7,#0                 ;3120
00002c  d068              BEQ      |L23.256|
00002e  1c68              ADDS     r0,r5,#1              ;3121
000030  d035              BEQ      |L23.158|
000032  f8d4020c          LDR      r0,[r4,#0x20c]        ;3147
000036  42a8              CMP      r0,r5                 ;3147
000038  d200              BCS      |L23.60|
00003a  4605              MOV      r5,r0                 ;3148
                  |L23.60|
00003c  f8c45208          STR      r5,[r4,#0x208]        ;3149
000040  2d00              CMP      r5,#0                 ;3150
                  |L23.66|
000042  d05b              BEQ      |L23.252|
000044  1e69              SUBS     r1,r5,#1              ;3151
000046  4620              MOV      r0,r4                 ;3151
000048  f7fffffe          BL       clmt_clust
00004c  f8c40214          STR      r0,[r4,#0x214]        ;3151
000050  f8d42200          LDR      r2,[r4,#0x200]        ;3152
000054  4601              MOV      r1,r0                 ;3152
000056  4610              MOV      r0,r2                 ;3152
000058  f7fffffe          BL       clust2sect
00005c  b3a8              CBZ      r0,|L23.202|
00005e  f8d41200          LDR      r1,[r4,#0x200]        ;3154
000062  1e6d              SUBS     r5,r5,#1              ;3154
000064  f8912202          LDRB     r2,[r1,#0x202]        ;3154
000068  1e52              SUBS     r2,r2,#1              ;3154
00006a  ea022255          AND      r2,r2,r5,LSR #9       ;3154
00006e  1815              ADDS     r5,r2,r0              ;3154
000070  f8b40208          LDRH     r0,[r4,#0x208]        ;3155
000074  05c0              LSLS     r0,r0,#23             ;3155
000076  d0e4              BEQ      |L23.66|
000078  f8d42218          LDR      r2,[r4,#0x218]        ;3155
00007c  42aa              CMP      r2,r5                 ;3155
00007e  d0e0              BEQ      |L23.66|
000080  f8940206          LDRB     r0,[r4,#0x206]        ;3158
000084  0640              LSLS     r0,r0,#25             ;3158
000086  d54d              BPL      |L23.292|
000088  f8910201          LDRB     r0,[r1,#0x201]        ;3159
00008c  2301              MOVS     r3,#1                 ;3159
00008e  4621              MOV      r1,r4                 ;3159
000090  f7fffffe          BL       disk_write
000094  b398              CBZ      r0,|L23.254|
000096  f884a207          STRB     r10,[r4,#0x207]       ;3160
00009a  2001              MOVS     r0,#1                 ;3160
00009c  e7bb              B        |L23.22|
                  |L23.158|
00009e  f857bb04          LDR      r11,[r7],#4           ;3123
0000a2  2602              MOVS     r6,#2                 ;3123
0000a4  f8d41210          LDR      r1,[r4,#0x210]        ;3124
0000a8  b309              CBZ      r1,|L23.238|
                  |L23.170|
0000aa  4689              MOV      r9,r1                 ;3128
0000ac  2500              MOVS     r5,#0                 ;3128
0000ae  1cb6              ADDS     r6,r6,#2              ;3128
                  |L23.176|
0000b0  4688              MOV      r8,r1                 ;3130
0000b2  1c6d              ADDS     r5,r5,#1              ;3130
0000b4  f8d40200          LDR      r0,[r4,#0x200]        ;3131
0000b8  f7fffffe          BL       get_fat
0000bc  4601              MOV      r1,r0                 ;3131
0000be  2901              CMP      r1,#1                 ;3132
0000c0  d804              BHI      |L23.204|
0000c2  2002              MOVS     r0,#2                 ;3132
0000c4  f8840207          STRB     r0,[r4,#0x207]        ;3132
0000c8  e7a5              B        |L23.22|
                  |L23.202|
0000ca  e021              B        |L23.272|
                  |L23.204|
0000cc  1c48              ADDS     r0,r1,#1              ;3133
0000ce  d018              BEQ      |L23.258|
0000d0  f1080801          ADD      r8,r8,#1              ;3134
0000d4  4541              CMP      r1,r8                 ;3134
0000d6  d0eb              BEQ      |L23.176|
0000d8  455e              CMP      r6,r11                ;3135
0000da  d802              BHI      |L23.226|
0000dc  c720              STM      r7!,{r5}              ;3136
0000de  f8479b04          STR      r9,[r7],#4            ;3136
                  |L23.226|
0000e2  f8d40200          LDR      r0,[r4,#0x200]        ;3138
0000e6  f8d00214          LDR      r0,[r0,#0x214]        ;3138
0000ea  4288              CMP      r0,r1                 ;3138
0000ec  d8dd              BHI      |L23.170|
                  |L23.238|
0000ee  f8d40224          LDR      r0,[r4,#0x224]        ;3140
0000f2  6006              STR      r6,[r0,#0]            ;3140
0000f4  455e              CMP      r6,r11                ;3141
0000f6  d808              BHI      |L23.266|
0000f8  2000              MOVS     r0,#0                 ;3142
0000fa  6038              STR      r0,[r7,#0]            ;3142
                  |L23.252|
0000fc  e0dd              B        |L23.698|
                  |L23.254|
0000fe  e00b              B        |L23.280|
                  |L23.256|
000100  e021              B        |L23.326|
                  |L23.258|
000102  f884a207          STRB     r10,[r4,#0x207]       ;3133
000106  2001              MOVS     r0,#1                 ;3133
000108  e785              B        |L23.22|
                  |L23.266|
00010a  2011              MOVS     r0,#0x11              ;3144
00010c  9000              STR      r0,[sp,#0]            ;3144
00010e  e0d4              B        |L23.698|
                  |L23.272|
000110  2002              MOVS     r0,#2                 ;3153
000112  f8840207          STRB     r0,[r4,#0x207]        ;3153
000116  e77e              B        |L23.22|
                  |L23.280|
000118  f8940206          LDRB     r0,[r4,#0x206]        ;3161
00011c  f0200040          BIC      r0,r0,#0x40           ;3161
000120  f8840206          STRB     r0,[r4,#0x206]        ;3161
                  |L23.292|
000124  f8d40200          LDR      r0,[r4,#0x200]        ;3164
000128  2301              MOVS     r3,#1                 ;3164
00012a  462a              MOV      r2,r5                 ;3164
00012c  f8900201          LDRB     r0,[r0,#0x201]        ;3164
000130  4621              MOV      r1,r4                 ;3164
000132  f7fffffe          BL       disk_read
000136  b118              CBZ      r0,|L23.320|
000138  f884a207          STRB     r10,[r4,#0x207]       ;3165
00013c  2001              MOVS     r0,#1                 ;3165
00013e  e76a              B        |L23.22|
                  |L23.320|
000140  f8c45218          STR      r5,[r4,#0x218]        ;3167
000144  e0b9              B        |L23.698|
                  |L23.326|
000146  f8d4020c          LDR      r0,[r4,#0x20c]        ;3176
00014a  42a8              CMP      r0,r5                 ;3176
00014c  d204              BCS      |L23.344|
00014e  f8941206          LDRB     r1,[r4,#0x206]        ;3178
000152  0789              LSLS     r1,r1,#30             ;3178
000154  d400              BMI      |L23.344|
000156  4605              MOV      r5,r0                 ;3180
                  |L23.344|
000158  f8d40208          LDR      r0,[r4,#0x208]        ;3182
00015c  2700              MOVS     r7,#0                 ;3183
00015e  f8c47208          STR      r7,[r4,#0x208]        ;3183
000162  b335              CBZ      r5,|L23.434|
000164  f8d42200          LDR      r2,[r4,#0x200]        ;3185
000168  f8921202          LDRB     r1,[r2,#0x202]        ;3185
00016c  024e              LSLS     r6,r1,#9              ;3185
00016e  b178              CBZ      r0,|L23.400|
000170  1e69              SUBS     r1,r5,#1              ;3187
000172  1e40              SUBS     r0,r0,#1              ;3187
000174  fbb1f1f6          UDIV     r1,r1,r6              ;3187
000178  fbb0f3f6          UDIV     r3,r0,r6              ;3187
00017c  4299              CMP      r1,r3                 ;3187
00017e  d307              BCC      |L23.400|
000180  1e71              SUBS     r1,r6,#1              ;3188
000182  4388              BICS     r0,r0,r1              ;3188
000184  f8c40208          STR      r0,[r4,#0x208]        ;3188
000188  1a2d              SUBS     r5,r5,r0              ;3189
00018a  f8d41214          LDR      r1,[r4,#0x214]        ;3190
00018e  e00f              B        |L23.432|
                  |L23.400|
000190  f8d41210          LDR      r1,[r4,#0x210]        ;3192
000194  b951              CBNZ     r1,|L23.428|
000196  2100              MOVS     r1,#0                 ;3195
000198  4610              MOV      r0,r2                 ;3195
00019a  f7fffffe          BL       create_chain
00019e  4601              MOV      r1,r0                 ;3195
0001a0  2901              CMP      r1,#1                 ;3196
0001a2  d007              BEQ      |L23.436|
0001a4  1c48              ADDS     r0,r1,#1              ;3197
0001a6  d009              BEQ      |L23.444|
0001a8  f8c41210          STR      r1,[r4,#0x210]        ;3198
                  |L23.428|
0001ac  f8c41214          STR      r1,[r4,#0x214]        ;3201
                  |L23.432|
0001b0  bb99              CBNZ     r1,|L23.538|
                  |L23.434|
0001b2  e042              B        |L23.570|
                  |L23.436|
0001b4  2002              MOVS     r0,#2                 ;3196
0001b6  f8840207          STRB     r0,[r4,#0x207]        ;3196
0001ba  e72c              B        |L23.22|
                  |L23.444|
0001bc  f884a207          STRB     r10,[r4,#0x207]       ;3197
0001c0  2001              MOVS     r0,#1                 ;3197
0001c2  e728              B        |L23.22|
                  |L23.452|
0001c4  f8940206          LDRB     r0,[r4,#0x206]        ;3206
0001c8  0780              LSLS     r0,r0,#30             ;3206
0001ca  d507              BPL      |L23.476|
0001cc  f8d40200          LDR      r0,[r4,#0x200]        ;3207
0001d0  f7fffffe          BL       create_chain
0001d4  4601              MOV      r1,r0                 ;3207
0001d6  b931              CBNZ     r1,|L23.486|
0001d8  4635              MOV      r5,r6                 ;3209
0001da  e020              B        |L23.542|
                  |L23.476|
0001dc  f8d40200          LDR      r0,[r4,#0x200]        ;3213
0001e0  f7fffffe          BL       get_fat
0001e4  4601              MOV      r1,r0                 ;3213
                  |L23.486|
0001e6  1c48              ADDS     r0,r1,#1              ;3214
0001e8  d00b              BEQ      |L23.514|
0001ea  2901              CMP      r1,#1                 ;3215
0001ec  d905              BLS      |L23.506|
0001ee  f8d40200          LDR      r0,[r4,#0x200]        ;3215
0001f2  f8d00214          LDR      r0,[r0,#0x214]        ;3215
0001f6  4288              CMP      r0,r1                 ;3215
0001f8  d807              BHI      |L23.522|
                  |L23.506|
0001fa  2002              MOVS     r0,#2                 ;3215
0001fc  f8840207          STRB     r0,[r4,#0x207]        ;3215
000200  e709              B        |L23.22|
                  |L23.514|
000202  f884a207          STRB     r10,[r4,#0x207]       ;3214
000206  2001              MOVS     r0,#1                 ;3214
000208  e705              B        |L23.22|
                  |L23.522|
00020a  f8c41214          STR      r1,[r4,#0x214]        ;3216
00020e  f8d40208          LDR      r0,[r4,#0x208]        ;3217
000212  4430              ADD      r0,r0,r6              ;3217
000214  f8c40208          STR      r0,[r4,#0x208]        ;3217
000218  1bad              SUBS     r5,r5,r6              ;3218
                  |L23.538|
00021a  42b5              CMP      r5,r6                 ;3204
00021c  d8d2              BHI      |L23.452|
                  |L23.542|
00021e  f8d40208          LDR      r0,[r4,#0x208]        ;3220
000222  4428              ADD      r0,r0,r5              ;3220
000224  f8c40208          STR      r0,[r4,#0x208]        ;3220
000228  05e8              LSLS     r0,r5,#23             ;3221
00022a  d006              BEQ      |L23.570|
00022c  f8d40200          LDR      r0,[r4,#0x200]        ;3222
000230  f7fffffe          BL       clust2sect
000234  b1d0              CBZ      r0,|L23.620|
000236  eb002755          ADD      r7,r0,r5,LSR #9       ;3224
                  |L23.570|
00023a  f8b40208          LDRH     r0,[r4,#0x208]        ;3228
00023e  05c0              LSLS     r0,r0,#23             ;3228
000240  d02e              BEQ      |L23.672|
000242  f8d42218          LDR      r2,[r4,#0x218]        ;3228
000246  42ba              CMP      r2,r7                 ;3228
000248  d02a              BEQ      |L23.672|
00024a  f8940206          LDRB     r0,[r4,#0x206]        ;3231
00024e  0640              LSLS     r0,r0,#25             ;3231
000250  d516              BPL      |L23.640|
000252  f8d40200          LDR      r0,[r4,#0x200]        ;3232
000256  2301              MOVS     r3,#1                 ;3232
000258  4621              MOV      r1,r4                 ;3232
00025a  f8900201          LDRB     r0,[r0,#0x201]        ;3232
00025e  f7fffffe          BL       disk_write
000262  b138              CBZ      r0,|L23.628|
000264  f884a207          STRB     r10,[r4,#0x207]       ;3233
000268  2001              MOVS     r0,#1                 ;3233
00026a  e6d4              B        |L23.22|
                  |L23.620|
00026c  2002              MOVS     r0,#2                 ;3223
00026e  f8840207          STRB     r0,[r4,#0x207]        ;3223
000272  e6d0              B        |L23.22|
                  |L23.628|
000274  f8940206          LDRB     r0,[r4,#0x206]        ;3234
000278  f0200040          BIC      r0,r0,#0x40           ;3234
00027c  f8840206          STRB     r0,[r4,#0x206]        ;3234
                  |L23.640|
000280  f8d40200          LDR      r0,[r4,#0x200]        ;3237
000284  2301              MOVS     r3,#1                 ;3237
000286  463a              MOV      r2,r7                 ;3237
000288  f8900201          LDRB     r0,[r0,#0x201]        ;3237
00028c  4621              MOV      r1,r4                 ;3237
00028e  f7fffffe          BL       disk_read
000292  b118              CBZ      r0,|L23.668|
000294  f884a207          STRB     r10,[r4,#0x207]       ;3238
000298  2001              MOVS     r0,#1                 ;3238
00029a  e6bc              B        |L23.22|
                  |L23.668|
00029c  f8c47218          STR      r7,[r4,#0x218]        ;3240
                  |L23.672|
0002a0  f5047002          ADD      r0,r4,#0x208          ;3243
0002a4  c803              LDM      r0,{r0,r1}            ;3243
0002a6  4288              CMP      r0,r1                 ;3243
0002a8  d907              BLS      |L23.698|
0002aa  f8c4020c          STR      r0,[r4,#0x20c]        ;3244
0002ae  f8940206          LDRB     r0,[r4,#0x206]        ;3245
0002b2  f0400020          ORR      r0,r0,#0x20           ;3245
0002b6  f8840206          STRB     r0,[r4,#0x206]        ;3245
                  |L23.698|
0002ba  9800              LDR      r0,[sp,#0]            ;3250
0002bc  e6ab              B        |L23.22|
;;;3252   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=2

                  f_mkdir PROC
;;;3668   
;;;3669   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3670   	const TCHAR* path		/* Pointer to the directory path */
;;;3671   )
;;;3672   {
000004  f5ad7d0c          SUB      sp,sp,#0x230
;;;3673   	FRESULT res;
;;;3674   	DIR dj;
;;;3675   	BYTE *dir, n;
;;;3676   	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
000008  4f55              LDR      r7,|L24.352|
;;;3677   	DEFINE_NAMEBUF;
;;;3678   
;;;3679   
;;;3680   	/* Get logical drive number */
;;;3681   	res = find_volume(&dj.fs, &path, 1);
00000a  2201              MOVS     r2,#1
00000c  a98c              ADD      r1,sp,#0x230
00000e  a883              ADD      r0,sp,#0x20c
000010  f7fffffe          BL       find_volume
000014  4604              MOV      r4,r0
;;;3682   	if (res == FR_OK) {
000016  0020              MOVS     r0,r4
000018  d17e              BNE      |L24.280|
;;;3683   		INIT_BUF(dj);
00001a  f8cdd224          STR      sp,[sp,#0x224]
;;;3684   		res = follow_path(&dj, path);			/* Follow the file path */
00001e  a803              ADD      r0,sp,#0xc
000020  998c              LDR      r1,[sp,#0x230]
000022  f7fffffe          BL       follow_path
000026  4604              MOV      r4,r0
;;;3685   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
000028  0020              MOVS     r0,r4
00002a  d100              BNE      |L24.46|
00002c  2408              MOVS     r4,#8
                  |L24.46|
;;;3686   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
;;;3687   			res = FR_INVALID_NAME;
;;;3688   		if (res == FR_NO_FILE) {				/* Can create a new directory */
00002e  2c04              CMP      r4,#4
000030  d172              BNE      |L24.280|
;;;3689   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
000032  2100              MOVS     r1,#0
000034  9883              LDR      r0,[sp,#0x20c]
000036  f7fffffe          BL       create_chain
00003a  4680              MOV      r8,r0
;;;3690   			res = FR_OK;
00003c  2400              MOVS     r4,#0
;;;3691   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
00003e  f1b80f00          CMP      r8,#0
000042  d100              BNE      |L24.70|
000044  2407              MOVS     r4,#7
                  |L24.70|
;;;3692   			if (dcl == 1) res = FR_INT_ERR;
000046  f1b80f01          CMP      r8,#1
00004a  d100              BNE      |L24.78|
00004c  2402              MOVS     r4,#2
                  |L24.78|
;;;3693   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
00004e  f1b83fff          CMP      r8,#0xffffffff
000052  d100              BNE      |L24.86|
000054  2401              MOVS     r4,#1
                  |L24.86|
;;;3694   			if (res == FR_OK)					/* Flush FAT */
000056  b91c              CBNZ     r4,|L24.96|
;;;3695   				res = sync_window(dj.fs);
000058  9883              LDR      r0,[sp,#0x20c]
00005a  f7fffffe          BL       sync_window
00005e  4604              MOV      r4,r0
                  |L24.96|
;;;3696   			if (res == FR_OK) {					/* Initialize the new directory table */
;;;3697   				dsc = clust2sect(dj.fs, dcl);
;;;3698   				dir = dj.fs->win.d8;
;;;3699   				mem_set(dir, 0, SS(dj.fs));
;;;3700   				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
;;;3701   				dir[DIR_Name] = '.';
;;;3702   				dir[DIR_Attr] = AM_DIR;
000060  f04f0a10          MOV      r10,#0x10
000064  f04f0901          MOV      r9,#1                 ;3681
000068  bbdc              CBNZ     r4,|L24.226|
00006a  4641              MOV      r1,r8                 ;3697
00006c  9883              LDR      r0,[sp,#0x20c]        ;3697
00006e  f7fffffe          BL       clust2sect
000072  4683              MOV      r11,r0                ;3697
000074  9d83              LDR      r5,[sp,#0x20c]        ;3698
000076  f44f7200          MOV      r2,#0x200             ;3699
00007a  2100              MOVS     r1,#0                 ;3699
00007c  4628              MOV      r0,r5                 ;3699
00007e  f7fffffe          BL       mem_set
000082  220b              MOVS     r2,#0xb               ;3700
000084  2120              MOVS     r1,#0x20              ;3700
000086  4628              MOV      r0,r5                 ;3700
000088  f7fffffe          BL       mem_set
00008c  262e              MOVS     r6,#0x2e              ;3701
00008e  702e              STRB     r6,[r5,#0]            ;3701
000090  f885a00b          STRB     r10,[r5,#0xb]
;;;3703   				ST_DWORD(dir + DIR_WrtTime, tm);
000094  2000              MOVS     r0,#0
000096  75a8              STRB     r0,[r5,#0x16]
000098  75e8              STRB     r0,[r5,#0x17]
00009a  20a1              MOVS     r0,#0xa1
00009c  7628              STRB     r0,[r5,#0x18]
00009e  2046              MOVS     r0,#0x46
0000a0  7668              STRB     r0,[r5,#0x19]
;;;3704   				st_clust(dir, dcl);
0000a2  4641              MOV      r1,r8
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       st_clust
;;;3705   				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
0000aa  f1050020          ADD      r0,r5,#0x20
0000ae  2220              MOVS     r2,#0x20
0000b0  4629              MOV      r1,r5
0000b2  908b              STR      r0,[sp,#0x22c]
0000b4  f7fffffe          BL       mem_cpy
;;;3706   				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
0000b8  f8856021          STRB     r6,[r5,#0x21]
0000bc  9985              LDR      r1,[sp,#0x214]
;;;3707   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000be  9883              LDR      r0,[sp,#0x20c]
0000c0  f8900200          LDRB     r0,[r0,#0x200]
0000c4  2803              CMP      r0,#3
0000c6  d105              BNE      |L24.212|
0000c8  9883              LDR      r0,[sp,#0x20c]
0000ca  f8d00224          LDR      r0,[r0,#0x224]
0000ce  4288              CMP      r0,r1
0000d0  d100              BNE      |L24.212|
;;;3708   					pcl = 0;
0000d2  2100              MOVS     r1,#0
                  |L24.212|
;;;3709   				st_clust(dir + SZ_DIRE, pcl);
0000d4  988b              LDR      r0,[sp,#0x22c]
0000d6  f7fffffe          BL       st_clust
;;;3710   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
0000da  9883              LDR      r0,[sp,#0x20c]
0000dc  f8906202          LDRB     r6,[r0,#0x202]
0000e0  e016              B        |L24.272|
                  |L24.226|
0000e2  e017              B        |L24.276|
                  |L24.228|
;;;3711   					dj.fs->winsect = dsc++;
0000e4  9883              LDR      r0,[sp,#0x20c]
0000e6  f8c0b22c          STR      r11,[r0,#0x22c]
0000ea  f10b0b01          ADD      r11,r11,#1
;;;3712   					dj.fs->wflag = 1;
0000ee  9883              LDR      r0,[sp,#0x20c]
0000f0  f8809204          STRB     r9,[r0,#0x204]
;;;3713   					res = sync_window(dj.fs);
0000f4  9883              LDR      r0,[sp,#0x20c]
0000f6  f7fffffe          BL       sync_window
0000fa  4604              MOV      r4,r0
;;;3714   					if (res != FR_OK) break;
0000fc  0020              MOVS     r0,r4
0000fe  d109              BNE      |L24.276|
;;;3715   					mem_set(dir, 0, SS(dj.fs));
000100  f44f7200          MOV      r2,#0x200
000104  2100              MOVS     r1,#0
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       mem_set
00010c  1e76              SUBS     r6,r6,#1              ;3710
00010e  b2f6              UXTB     r6,r6                 ;3710
                  |L24.272|
000110  2e00              CMP      r6,#0                 ;3710
000112  d1e7              BNE      |L24.228|
                  |L24.276|
;;;3716   				}
;;;3717   			}
;;;3718   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
000114  b92c              CBNZ     r4,|L24.290|
000116  e000              B        |L24.282|
                  |L24.280|
000118  e01d              B        |L24.342|
                  |L24.282|
00011a  a803              ADD      r0,sp,#0xc
00011c  f7fffffe          BL       dir_register
000120  4604              MOV      r4,r0
                  |L24.290|
;;;3719   			if (res != FR_OK) {
000122  b124              CBZ      r4,|L24.302|
;;;3720   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
000124  4641              MOV      r1,r8
000126  9883              LDR      r0,[sp,#0x20c]
000128  f7fffffe          BL       remove_chain
00012c  e013              B        |L24.342|
                  |L24.302|
;;;3721   			} else {
;;;3722   				dir = dj.dir;
00012e  9888              LDR      r0,[sp,#0x220]
;;;3723   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
000130  f880a00b          STRB     r10,[r0,#0xb]
;;;3724   				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
000134  7587              STRB     r7,[r0,#0x16]
000136  0a39              LSRS     r1,r7,#8
000138  75c1              STRB     r1,[r0,#0x17]
00013a  0c39              LSRS     r1,r7,#16
00013c  7601              STRB     r1,[r0,#0x18]
00013e  0e39              LSRS     r1,r7,#24
000140  7641              STRB     r1,[r0,#0x19]
;;;3725   				st_clust(dir, dcl);					/* Table start cluster */
000142  4641              MOV      r1,r8
000144  f7fffffe          BL       st_clust
;;;3726   				dj.fs->wflag = 1;
000148  9883              LDR      r0,[sp,#0x20c]
00014a  f8809204          STRB     r9,[r0,#0x204]
;;;3727   				res = sync_fs(dj.fs);
00014e  9883              LDR      r0,[sp,#0x20c]
000150  f7fffffe          BL       sync_fs
000154  4604              MOV      r4,r0
                  |L24.342|
;;;3728   			}
;;;3729   		}
;;;3730   		FREE_BUF();
;;;3731   	}
;;;3732   
;;;3733   	LEAVE_FF(dj.fs, res);
;;;3734   }
000156  f50d7d0d          ADD      sp,sp,#0x234
00015a  4620              MOV      r0,r4                 ;3733
00015c  e8bd8ff0          POP      {r4-r11,pc}
;;;3735   
                          ENDP

                  |L24.352|
                          DCD      0x46a10000

                          AREA ||i.f_mkfs||, CODE, READONLY, ALIGN=2

                  f_mkfs PROC
;;;4137   
;;;4138   FRESULT f_mkfs (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;4139   	const TCHAR* path,	/* Logical drive number */
;;;4140   	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
;;;4141   	UINT au				/* Size of allocation unit in unit of byte or sector */
;;;4142   )
;;;4143   {
000004  b088              SUB      sp,sp,#0x20
000006  4617              MOV      r7,r2
;;;4144   	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
;;;4145   	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
;;;4146   	int vol;
;;;4147   	BYTE fmt, md, sys, *tbl, pdrv, part;
;;;4148   	DWORD n_clst, vs, n, wsect;
;;;4149   	UINT i;
;;;4150   	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
;;;4151   	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
;;;4152   	FATFS *fs;
;;;4153   	DSTATUS stat;
;;;4154   #if _USE_TRIM
;;;4155   	DWORD eb[2];
;;;4156   #endif
;;;4157   
;;;4158   
;;;4159   	/* Check mounted drive and clear work area */
;;;4160   	if (sfd > 1) return FR_INVALID_PARAMETER;
000008  9809              LDR      r0,[sp,#0x24]
00000a  2801              CMP      r0,#1
00000c  d903              BLS      |L25.22|
00000e  2013              MOVS     r0,#0x13
                  |L25.16|
;;;4161   	vol = get_ldnumber(&path);
;;;4162   	if (vol < 0) return FR_INVALID_DRIVE;
;;;4163   	fs = FatFs[vol];
;;;4164   	if (!fs) return FR_NOT_ENABLED;
;;;4165   	fs->fs_type = 0;
;;;4166   	pdrv = LD2PD(vol);	/* Physical drive */
;;;4167   	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
;;;4168   
;;;4169   	/* Get disk statics */
;;;4170   	stat = disk_initialize(pdrv);
;;;4171   	if (stat & STA_NOINIT) return FR_NOT_READY;
;;;4172   	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;;;4173   #if _MAX_SS != _MIN_SS		/* Get disk sector size */
;;;4174   	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
;;;4175   		return FR_DISK_ERR;
;;;4176   #endif
;;;4177   	if (_MULTI_PARTITION && part) {
;;;4178   		/* Get partition information from partition table in the MBR */
;;;4179   		if (disk_read(pdrv, fs->win.d8, 0, 1) != RES_OK) return FR_DISK_ERR;
;;;4180   		if (LD_WORD(fs->win.d8 + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
;;;4181   		tbl = &fs->win.d8[MBR_Table + (part - 1) * SZ_PTE];
;;;4182   		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
;;;4183   		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
;;;4184   		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
;;;4185   	} else {
;;;4186   		/* Create a partition in this function */
;;;4187   		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
;;;4188   			return FR_DISK_ERR;
;;;4189   		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
;;;4190   		n_vol -= b_vol;				/* Volume size */
;;;4191   	}
;;;4192   
;;;4193   	if (au & (au - 1)) au = 0;
;;;4194   	if (!au) {						/* AU auto selection */
;;;4195   		vs = n_vol / (2000 / (SS(fs) / 512));
;;;4196   		for (i = 0; vs < vst[i]; i++) ;
;;;4197   		au = cst[i];
;;;4198   	}
;;;4199   	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
;;;4200   	if (!au) au = 1;
;;;4201   	if (au > 128) au = 128;
;;;4202   
;;;4203   	/* Pre-compute number of clusters and FAT sub-type */
;;;4204   	n_clst = n_vol / au;
;;;4205   	fmt = FS_FAT12;
;;;4206   	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
;;;4207   	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
;;;4208   
;;;4209   	/* Determine offset and size of FAT structure */
;;;4210   	if (fmt == FS_FAT32) {
;;;4211   		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
;;;4212   		n_rsv = 32;
;;;4213   		n_dir = 0;
;;;4214   	} else {
;;;4215   		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
;;;4216   		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
;;;4217   		n_rsv = 1;
;;;4218   		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
;;;4219   	}
;;;4220   	b_fat = b_vol + n_rsv;				/* FAT area start sector */
;;;4221   	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
;;;4222   	b_data = b_dir + n_dir;				/* Data area start sector */
;;;4223   	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
;;;4224   
;;;4225   	/* Align data start sector to erase block boundary (for flash memory media) */
;;;4226   	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
;;;4227   	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
;;;4228   	n = (n - b_data) / N_FATS;
;;;4229   	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
;;;4230   		n_rsv += n;
;;;4231   		b_fat += n;
;;;4232   	} else {					/* FAT12/16: Expand FAT size */
;;;4233   		n_fat += n;
;;;4234   	}
;;;4235   
;;;4236   	/* Determine number of clusters and final check of validity of the FAT sub-type */
;;;4237   	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
;;;4238   	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
;;;4239   		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
;;;4240   		return FR_MKFS_ABORTED;
;;;4241   
;;;4242   	/* Determine system ID in the partition table */
;;;4243   	if (fmt == FS_FAT32) {
;;;4244   		sys = 0x0C;		/* FAT32X */
;;;4245   	} else {
;;;4246   		if (fmt == FS_FAT12 && n_vol < 0x10000) {
;;;4247   			sys = 0x01;	/* FAT12(<65536) */
;;;4248   		} else {
;;;4249   			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
;;;4250   		}
;;;4251   	}
;;;4252   
;;;4253   	if (_MULTI_PARTITION && part) {
;;;4254   		/* Update system ID in the partition table */
;;;4255   		tbl = &fs->win.d8[MBR_Table + (part - 1) * SZ_PTE];
;;;4256   		tbl[4] = sys;
;;;4257   		if (disk_write(pdrv, fs->win.d8, 0, 1) != RES_OK)	/* Write it to teh MBR */
;;;4258   			return FR_DISK_ERR;
;;;4259   		md = 0xF8;
;;;4260   	} else {
;;;4261   		if (sfd) {	/* No partition table (SFD) */
;;;4262   			md = 0xF0;
;;;4263   		} else {	/* Create partition table (FDISK) */
;;;4264   			mem_set(fs->win.d8, 0, SS(fs));
;;;4265   			tbl = fs->win.d8 + MBR_Table;	/* Create partition table for single partition in the drive */
;;;4266   			tbl[1] = 1;						/* Partition start head */
;;;4267   			tbl[2] = 1;						/* Partition start sector */
;;;4268   			tbl[3] = 0;						/* Partition start cylinder */
;;;4269   			tbl[4] = sys;					/* System type */
;;;4270   			tbl[5] = 254;					/* Partition end head */
;;;4271   			n = (b_vol + n_vol) / 63 / 255;
;;;4272   			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
;;;4273   			tbl[7] = (BYTE)n;				/* End cylinder */
;;;4274   			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
;;;4275   			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
;;;4276   			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);	/* MBR signature */
;;;4277   			if (disk_write(pdrv, fs->win.d8, 0, 1) != RES_OK)	/* Write it to the MBR */
;;;4278   				return FR_DISK_ERR;
;;;4279   			md = 0xF8;
;;;4280   		}
;;;4281   	}
;;;4282   
;;;4283   	/* Create BPB in the VBR */
;;;4284   	tbl = fs->win.d8;							/* Clear sector */
;;;4285   	mem_set(tbl, 0, SS(fs));
;;;4286   	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
;;;4287   	i = SS(fs);								/* Sector size */
;;;4288   	ST_WORD(tbl + BPB_BytsPerSec, i);
;;;4289   	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
;;;4290   	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
;;;4291   	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
;;;4292   	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
;;;4293   	ST_WORD(tbl + BPB_RootEntCnt, i);
;;;4294   	if (n_vol < 0x10000) {					/* Number of total sectors */
;;;4295   		ST_WORD(tbl + BPB_TotSec16, n_vol);
;;;4296   	} else {
;;;4297   		ST_DWORD(tbl + BPB_TotSec32, n_vol);
;;;4298   	}
;;;4299   	tbl[BPB_Media] = md;					/* Media descriptor */
;;;4300   	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
;;;4301   	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
;;;4302   	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
;;;4303   	n = GET_FATTIME();						/* Use current time as VSN */
;;;4304   	if (fmt == FS_FAT32) {
;;;4305   		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
;;;4306   		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
;;;4307   		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
;;;4308   		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
;;;4309   		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
;;;4310   		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
;;;4311   		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
;;;4312   		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
;;;4313   	} else {
;;;4314   		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
;;;4315   		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
;;;4316   		tbl[BS_DrvNum] = 0x80;				/* Drive number */
;;;4317   		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
;;;4318   		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
;;;4319   	}
;;;4320   	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
;;;4321   	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
;;;4322   		return FR_DISK_ERR;
;;;4323   	if (fmt == FS_FAT32)					/* Write backup VBR if needed (VBR + 6) */
;;;4324   		disk_write(pdrv, tbl, b_vol + 6, 1);
;;;4325   
;;;4326   	/* Initialize FAT area */
;;;4327   	wsect = b_fat;
;;;4328   	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
;;;4329   		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
;;;4330   		n = md;								/* Media descriptor byte */
;;;4331   		if (fmt != FS_FAT32) {
;;;4332   			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
;;;4333   			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
;;;4334   		} else {
;;;4335   			n |= 0xFFFFFF00;
;;;4336   			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
;;;4337   			ST_DWORD(tbl + 4, 0xFFFFFFFF);
;;;4338   			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
;;;4339   		}
;;;4340   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4341   			return FR_DISK_ERR;
;;;4342   		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
;;;4343   		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
;;;4344   			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4345   				return FR_DISK_ERR;
;;;4346   		}
;;;4347   	}
;;;4348   
;;;4349   	/* Initialize root directory */
;;;4350   	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
;;;4351   	do {
;;;4352   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4353   			return FR_DISK_ERR;
;;;4354   	} while (--i);
;;;4355   
;;;4356   #if _USE_TRIM	/* Erase data area if needed */
;;;4357   	{
;;;4358   		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
;;;4359   		disk_ioctl(pdrv, CTRL_TRIM, eb);
;;;4360   	}
;;;4361   #endif
;;;4362   
;;;4363   	/* Create FSINFO if needed */
;;;4364   	if (fmt == FS_FAT32) {
;;;4365   		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
;;;4366   		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
;;;4367   		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
;;;4368   		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
;;;4369   		ST_WORD(tbl + BS_55AA, 0xAA55);
;;;4370   		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
;;;4371   		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
;;;4372   	}
;;;4373   
;;;4374   	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
;;;4375   }
000010  b00b              ADD      sp,sp,#0x2c
000012  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.22|
000016  a808              ADD      r0,sp,#0x20           ;4161
000018  f7fffffe          BL       get_ldnumber
00001c  2800              CMP      r0,#0                 ;4162
00001e  da01              BGE      |L25.36|
000020  200b              MOVS     r0,#0xb               ;4162
000022  e7f5              B        |L25.16|
                  |L25.36|
000024  49f9              LDR      r1,|L25.1036|
000026  f8514020          LDR      r4,[r1,r0,LSL #2]     ;4163
00002a  b15c              CBZ      r4,|L25.68|
00002c  2100              MOVS     r1,#0                 ;4165
00002e  f8841200          STRB     r1,[r4,#0x200]        ;4165
000032  b2c0              UXTB     r0,r0                 ;4166
000034  9005              STR      r0,[sp,#0x14]         ;4166
000036  9805              LDR      r0,[sp,#0x14]         ;4170
000038  f7fffffe          BL       disk_initialize
00003c  07c1              LSLS     r1,r0,#31             ;4171
00003e  d003              BEQ      |L25.72|
000040  2003              MOVS     r0,#3                 ;4171
000042  e7e5              B        |L25.16|
                  |L25.68|
000044  200c              MOVS     r0,#0xc               ;4164
000046  e7e3              B        |L25.16|
                  |L25.72|
000048  0740              LSLS     r0,r0,#29             ;4172
00004a  d501              BPL      |L25.80|
00004c  200a              MOVS     r0,#0xa               ;4172
00004e  e7df              B        |L25.16|
                  |L25.80|
000050  aa01              ADD      r2,sp,#4              ;4187
000052  2101              MOVS     r1,#1                 ;4187
000054  9805              LDR      r0,[sp,#0x14]         ;4187
000056  f7fffffe          BL       disk_ioctl
00005a  b910              CBNZ     r0,|L25.98|
00005c  9801              LDR      r0,[sp,#4]            ;4187
00005e  2880              CMP      r0,#0x80              ;4187
000060  d201              BCS      |L25.102|
                  |L25.98|
000062  2001              MOVS     r0,#1                 ;4188
000064  e7d4              B        |L25.16|
                  |L25.102|
000066  9909              LDR      r1,[sp,#0x24]         ;4189
000068  b111              CBZ      r1,|L25.112|
00006a  f04f0900          MOV      r9,#0                 ;4189
00006e  e001              B        |L25.116|
                  |L25.112|
000070  f04f093f          MOV      r9,#0x3f              ;4189
                  |L25.116|
000074  eba00109          SUB      r1,r0,r9              ;4190
000078  9101              STR      r1,[sp,#4]            ;4190
00007a  1e78              SUBS     r0,r7,#1              ;4193
00007c  4207              TST      r7,r0                 ;4193
00007e  d000              BEQ      |L25.130|
000080  2700              MOVS     r7,#0                 ;4193
                  |L25.130|
000082  b97f              CBNZ     r7,|L25.164|
000084  f44f60fa          MOV      r0,#0x7d0             ;4195
000088  fbb1f2f0          UDIV     r2,r1,r0              ;4195
00008c  2000              MOVS     r0,#0                 ;4196
00008e  4be0              LDR      r3,|L25.1040|
000090  e000              B        |L25.148|
                  |L25.146|
000092  1c40              ADDS     r0,r0,#1              ;4196
                  |L25.148|
000094  f8335010          LDRH     r5,[r3,r0,LSL #1]     ;4196
000098  4295              CMP      r5,r2                 ;4196
00009a  d8fa              BHI      |L25.146|
00009c  4adc              LDR      r2,|L25.1040|
00009e  3216              ADDS     r2,r2,#0x16           ;4197
0000a0  f8327010          LDRH     r7,[r2,r0,LSL #1]     ;4197
                  |L25.164|
0000a4  f5b77f00          CMP      r7,#0x200             ;4199
0000a8  d300              BCC      |L25.172|
0000aa  0a7f              LSRS     r7,r7,#9              ;4199
                  |L25.172|
0000ac  b907              CBNZ     r7,|L25.176|
0000ae  2701              MOVS     r7,#1                 ;4200
                  |L25.176|
0000b0  2f80              CMP      r7,#0x80              ;4201
0000b2  d900              BLS      |L25.182|
0000b4  2780              MOVS     r7,#0x80              ;4201
                  |L25.182|
0000b6  fbb1f0f7          UDIV     r0,r1,r7              ;4204
0000ba  2601              MOVS     r6,#1                 ;4205
0000bc  f64072f6          MOV      r2,#0xff6             ;4206
0000c0  4290              CMP      r0,r2                 ;4206
0000c2  d300              BCC      |L25.198|
0000c4  2602              MOVS     r6,#2                 ;4206
                  |L25.198|
0000c6  f64f72f6          MOV      r2,#0xfff6            ;4207
0000ca  4290              CMP      r0,r2                 ;4207
0000cc  d300              BCC      |L25.208|
0000ce  2603              MOVS     r6,#3                 ;4207
                  |L25.208|
0000d0  2e03              CMP      r6,#3                 ;4210
0000d2  d018              BEQ      |L25.262|
0000d4  2e01              CMP      r6,#1                 ;4215
0000d6  d020              BEQ      |L25.282|
0000d8  0040              LSLS     r0,r0,#1              ;4215
0000da  1d00              ADDS     r0,r0,#4              ;4215
                  |L25.220|
0000dc  f20010ff          ADD      r0,r0,#0x1ff          ;4216
0000e0  ea4f2850          LSR      r8,r0,#9              ;4216
0000e4  2501              MOVS     r5,#1                 ;4217
0000e6  f04f0a20          MOV      r10,#0x20             ;4218
                  |L25.234|
0000ea  eb090b05          ADD      r11,r9,r5             ;4220
0000ee  eb0b0008          ADD      r0,r11,r8             ;4221
0000f2  4450              ADD      r0,r0,r10             ;4222
0000f4  9002              STR      r0,[sp,#8]            ;4222
0000f6  9802              LDR      r0,[sp,#8]            ;4223
0000f8  4438              ADD      r0,r0,r7              ;4223
0000fa  eba00009          SUB      r0,r0,r9              ;4223
0000fe  4288              CMP      r0,r1                 ;4223
000100  d911              BLS      |L25.294|
000102  200e              MOVS     r0,#0xe               ;4223
000104  e784              B        |L25.16|
                  |L25.262|
000106  f2402207          MOV      r2,#0x207             ;4211
00010a  eb020080          ADD      r0,r2,r0,LSL #2       ;4211
00010e  ea4f2850          LSR      r8,r0,#9              ;4211
000112  2520              MOVS     r5,#0x20              ;4212
000114  f04f0a00          MOV      r10,#0                ;4213
000118  e7e7              B        |L25.234|
                  |L25.282|
00011a  eb000040          ADD      r0,r0,r0,LSL #1       ;4215
00011e  1c40              ADDS     r0,r0,#1              ;4215
000120  0840              LSRS     r0,r0,#1              ;4215
000122  1cc0              ADDS     r0,r0,#3              ;4215
000124  e7da              B        |L25.220|
                  |L25.294|
000126  aa03              ADD      r2,sp,#0xc            ;4226
000128  2103              MOVS     r1,#3                 ;4226
00012a  9805              LDR      r0,[sp,#0x14]         ;4226
00012c  f7fffffe          BL       disk_ioctl
000130  b920              CBNZ     r0,|L25.316|
000132  9803              LDR      r0,[sp,#0xc]          ;4226
000134  b110              CBZ      r0,|L25.316|
000136  f5b04f00          CMP      r0,#0x8000            ;4226
00013a  d901              BLS      |L25.320|
                  |L25.316|
00013c  2001              MOVS     r0,#1                 ;4226
00013e  9003              STR      r0,[sp,#0xc]          ;4226
                  |L25.320|
000140  e9dd1002          LDRD     r1,r0,[sp,#8]         ;4227
000144  4401              ADD      r1,r1,r0              ;4227
000146  1e49              SUBS     r1,r1,#1              ;4227
000148  1e40              SUBS     r0,r0,#1              ;4227
00014a  4381              BICS     r1,r1,r0              ;4227
00014c  9802              LDR      r0,[sp,#8]            ;4228
00014e  1a08              SUBS     r0,r1,r0              ;4228
000150  9003              STR      r0,[sp,#0xc]          ;4228
000152  2e03              CMP      r6,#3                 ;4229
000154  d00c              BEQ      |L25.368|
000156  4480              ADD      r8,r8,r0              ;4233
                  |L25.344|
000158  9801              LDR      r0,[sp,#4]            ;4237
00015a  1b41              SUBS     r1,r0,r5              ;4237
00015c  eba10108          SUB      r1,r1,r8              ;4237
000160  eba1010a          SUB      r1,r1,r10             ;4237
000164  fbb1f1f7          UDIV     r1,r1,r7              ;4237
000168  9104              STR      r1,[sp,#0x10]         ;4237
00016a  2e02              CMP      r6,#2                 ;4238
00016c  d003              BEQ      |L25.374|
00016e  e007              B        |L25.384|
                  |L25.368|
000170  4405              ADD      r5,r5,r0              ;4230
000172  4483              ADD      r11,r11,r0            ;4231
000174  e7f0              B        |L25.344|
                  |L25.374|
000176  9904              LDR      r1,[sp,#0x10]         ;4238
000178  f64072f6          MOV      r2,#0xff6             ;4238
00017c  4291              CMP      r1,r2                 ;4238
00017e  d306              BCC      |L25.398|
                  |L25.384|
000180  2e03              CMP      r6,#3                 ;4239
000182  d106              BNE      |L25.402|
000184  9904              LDR      r1,[sp,#0x10]         ;4239
000186  f64f72f6          MOV      r2,#0xfff6            ;4239
00018a  4291              CMP      r1,r2                 ;4239
00018c  d201              BCS      |L25.402|
                  |L25.398|
00018e  200e              MOVS     r0,#0xe               ;4240
000190  e73e              B        |L25.16|
                  |L25.402|
000192  2e03              CMP      r6,#3                 ;4243
000194  d002              BEQ      |L25.412|
000196  2e01              CMP      r6,#1                 ;4246
000198  d003              BEQ      |L25.418|
00019a  e008              B        |L25.430|
                  |L25.412|
00019c  200c              MOVS     r0,#0xc               ;4244
00019e  9006              STR      r0,[sp,#0x18]         ;4244
0001a0  e00c              B        |L25.444|
                  |L25.418|
0001a2  f5b03f80          CMP      r0,#0x10000           ;4246
0001a6  d202              BCS      |L25.430|
0001a8  2001              MOVS     r0,#1                 ;4247
0001aa  9006              STR      r0,[sp,#0x18]         ;4247
0001ac  e006              B        |L25.444|
                  |L25.430|
0001ae  f5b03f80          CMP      r0,#0x10000           ;4249
0001b2  d201              BCS      |L25.440|
0001b4  2004              MOVS     r0,#4                 ;4249
0001b6  e000              B        |L25.442|
                  |L25.440|
0001b8  2006              MOVS     r0,#6                 ;4249
                  |L25.442|
0001ba  9006              STR      r0,[sp,#0x18]         ;4249
                  |L25.444|
0001bc  9809              LDR      r0,[sp,#0x24]         ;4261
0001be  b110              CBZ      r0,|L25.454|
0001c0  20f0              MOVS     r0,#0xf0              ;4262
0001c2  9007              STR      r0,[sp,#0x1c]         ;4262
0001c4  e03a              B        |L25.572|
                  |L25.454|
0001c6  f44f7200          MOV      r2,#0x200             ;4264
0001ca  2100              MOVS     r1,#0                 ;4264
0001cc  4620              MOV      r0,r4                 ;4264
0001ce  f7fffffe          BL       mem_set
0001d2  f50470df          ADD      r0,r4,#0x1be          ;4265
0001d6  2101              MOVS     r1,#1                 ;4266
0001d8  7041              STRB     r1,[r0,#1]            ;4266
0001da  7081              STRB     r1,[r0,#2]            ;4267
0001dc  2200              MOVS     r2,#0                 ;4268
0001de  70c2              STRB     r2,[r0,#3]            ;4268
0001e0  9906              LDR      r1,[sp,#0x18]         ;4269
0001e2  7101              STRB     r1,[r0,#4]            ;4269
0001e4  21fe              MOVS     r1,#0xfe              ;4270
0001e6  7141              STRB     r1,[r0,#5]            ;4270
0001e8  9901              LDR      r1,[sp,#4]            ;4271
0001ea  f64363c1          MOV      r3,#0x3ec1            ;4271
0001ee  4449              ADD      r1,r1,r9              ;4271
0001f0  fbb1f1f3          UDIV     r1,r1,r3              ;4271
0001f4  9103              STR      r1,[sp,#0xc]          ;4271
0001f6  233f              MOVS     r3,#0x3f              ;4272
0001f8  ea430c91          ORR      r12,r3,r1,LSR #2      ;4272
0001fc  f880c006          STRB     r12,[r0,#6]           ;4272
000200  71c1              STRB     r1,[r0,#7]            ;4273
000202  7203              STRB     r3,[r0,#8]            ;4274
000204  7242              STRB     r2,[r0,#9]            ;4274
000206  7282              STRB     r2,[r0,#0xa]          ;4274
000208  72c2              STRB     r2,[r0,#0xb]          ;4274
00020a  9901              LDR      r1,[sp,#4]            ;4275
00020c  7301              STRB     r1,[r0,#0xc]          ;4275
00020e  0a0a              LSRS     r2,r1,#8              ;4275
000210  7342              STRB     r2,[r0,#0xd]          ;4275
000212  0c0a              LSRS     r2,r1,#16             ;4275
000214  7382              STRB     r2,[r0,#0xe]          ;4275
000216  0e09              LSRS     r1,r1,#24             ;4275
000218  73c1              STRB     r1,[r0,#0xf]          ;4275
00021a  2055              MOVS     r0,#0x55              ;4276
00021c  f88401fe          STRB     r0,[r4,#0x1fe]        ;4276
000220  20aa              MOVS     r0,#0xaa              ;4276
000222  f88401ff          STRB     r0,[r4,#0x1ff]        ;4276
000226  2301              MOVS     r3,#1                 ;4277
000228  2200              MOVS     r2,#0                 ;4277
00022a  4621              MOV      r1,r4                 ;4277
00022c  9805              LDR      r0,[sp,#0x14]         ;4277
00022e  f7fffffe          BL       disk_write
000232  b108              CBZ      r0,|L25.568|
000234  2001              MOVS     r0,#1                 ;4278
000236  e6eb              B        |L25.16|
                  |L25.568|
000238  20f8              MOVS     r0,#0xf8              ;4279
00023a  9007              STR      r0,[sp,#0x1c]         ;4279
                  |L25.572|
00023c  f44f7200          MOV      r2,#0x200             ;4285
000240  2100              MOVS     r1,#0                 ;4285
000242  4620              MOV      r0,r4                 ;4285
000244  f7fffffe          BL       mem_set
000248  220b              MOVS     r2,#0xb               ;4286
00024a  a172              ADR      r1,|L25.1044|
00024c  4620              MOV      r0,r4                 ;4286
00024e  f7fffffe          BL       mem_cpy
000252  2100              MOVS     r1,#0                 ;4288
000254  72e1              STRB     r1,[r4,#0xb]          ;4288
000256  2002              MOVS     r0,#2                 ;4288
000258  7320              STRB     r0,[r4,#0xc]          ;4288
00025a  7367              STRB     r7,[r4,#0xd]          ;4289
00025c  73a5              STRB     r5,[r4,#0xe]          ;4290
00025e  0a28              LSRS     r0,r5,#8              ;4290
000260  73e0              STRB     r0,[r4,#0xf]          ;4290
000262  2001              MOVS     r0,#1                 ;4291
000264  7420              STRB     r0,[r4,#0x10]         ;4291
000266  2e03              CMP      r6,#3                 ;4292
000268  d00b              BEQ      |L25.642|
00026a  0240              LSLS     r0,r0,#9              ;4292
                  |L25.620|
00026c  7460              STRB     r0,[r4,#0x11]         ;4293
00026e  0a00              LSRS     r0,r0,#8              ;4293
000270  74a0              STRB     r0,[r4,#0x12]         ;4293
000272  9801              LDR      r0,[sp,#4]            ;4294
000274  f5b03f80          CMP      r0,#0x10000           ;4294
000278  d205              BCS      |L25.646|
00027a  74e0              STRB     r0,[r4,#0x13]         ;4295
00027c  0a00              LSRS     r0,r0,#8              ;4295
00027e  7520              STRB     r0,[r4,#0x14]         ;4295
000280  e00a              B        |L25.664|
                  |L25.642|
000282  2000              MOVS     r0,#0                 ;4292
000284  e7f2              B        |L25.620|
                  |L25.646|
000286  f8040f20          STRB     r0,[r4,#0x20]!        ;4297
00028a  0a02              LSRS     r2,r0,#8              ;4297
00028c  7062              STRB     r2,[r4,#1]            ;4297
00028e  0c02              LSRS     r2,r0,#16             ;4297
000290  70a2              STRB     r2,[r4,#2]            ;4297
000292  0e00              LSRS     r0,r0,#24             ;4297
000294  70e0              STRB     r0,[r4,#3]            ;4297
000296  3c20              SUBS     r4,r4,#0x20           ;4297
                  |L25.664|
000298  9807              LDR      r0,[sp,#0x1c]         ;4299
00029a  7560              STRB     r0,[r4,#0x15]         ;4299
00029c  203f              MOVS     r0,#0x3f              ;4300
00029e  7620              STRB     r0,[r4,#0x18]         ;4300
0002a0  2000              MOVS     r0,#0                 ;4300
0002a2  7660              STRB     r0,[r4,#0x19]         ;4300
0002a4  21ff              MOVS     r1,#0xff              ;4301
0002a6  76a1              STRB     r1,[r4,#0x1a]         ;4301
0002a8  76e0              STRB     r0,[r4,#0x1b]         ;4301
0002aa  f884901c          STRB     r9,[r4,#0x1c]         ;4302
0002ae  ea4f2019          LSR      r0,r9,#8              ;4302
0002b2  7760              STRB     r0,[r4,#0x1d]         ;4302
0002b4  ea4f4019          LSR      r0,r9,#16             ;4302
0002b8  77a0              STRB     r0,[r4,#0x1e]         ;4302
0002ba  ea4f6019          LSR      r0,r9,#24             ;4302
0002be  77e0              STRB     r0,[r4,#0x1f]         ;4302
0002c0  4857              LDR      r0,|L25.1056|
0002c2  9003              STR      r0,[sp,#0xc]          ;4303
0002c4  2180              MOVS     r1,#0x80              ;4201
0002c6  25a1              MOVS     r5,#0xa1              ;4305
0002c8  2346              MOVS     r3,#0x46              ;4305
0002ca  2229              MOVS     r2,#0x29              ;4311
0002cc  2e03              CMP      r6,#3                 ;4304
0002ce  d022              BEQ      |L25.790|
0002d0  2000              MOVS     r0,#0                 ;4314
0002d2  3416              ADDS     r4,r4,#0x16           ;4314
0002d4  7460              STRB     r0,[r4,#0x11]         ;4314
0002d6  74a0              STRB     r0,[r4,#0x12]         ;4314
0002d8  74e5              STRB     r5,[r4,#0x13]         ;4314
0002da  7523              STRB     r3,[r4,#0x14]         ;4314
0002dc  f8848000          STRB     r8,[r4,#0]            ;4315
0002e0  ea4f2018          LSR      r0,r8,#8              ;4315
0002e4  7060              STRB     r0,[r4,#1]            ;4315
0002e6  73a1              STRB     r1,[r4,#0xe]          ;4316
0002e8  7422              STRB     r2,[r4,#0x10]         ;4317
0002ea  3c16              SUBS     r4,r4,#0x16           ;4317
0002ec  2213              MOVS     r2,#0x13              ;4318
0002ee  a14d              ADR      r1,|L25.1060|
0002f0  f104002b          ADD      r0,r4,#0x2b           ;4318
0002f4  f7fffffe          BL       mem_cpy
                  |L25.760|
0002f8  2055              MOVS     r0,#0x55              ;4320
0002fa  f88401fe          STRB     r0,[r4,#0x1fe]        ;4320
0002fe  20aa              MOVS     r0,#0xaa              ;4320
000300  f88401ff          STRB     r0,[r4,#0x1ff]        ;4320
000304  2301              MOVS     r3,#1                 ;4321
000306  464a              MOV      r2,r9                 ;4321
000308  4621              MOV      r1,r4                 ;4321
00030a  9805              LDR      r0,[sp,#0x14]         ;4321
00030c  f7fffffe          BL       disk_write
000310  b348              CBZ      r0,|L25.870|
000312  2001              MOVS     r0,#1                 ;4322
000314  e67c              B        |L25.16|
                  |L25.790|
000316  2000              MOVS     r0,#0                 ;4305
000318  3425              ADDS     r4,r4,#0x25           ;4305
00031a  77a0              STRB     r0,[r4,#0x1e]         ;4305
00031c  77e0              STRB     r0,[r4,#0x1f]         ;4305
00031e  f8845020          STRB     r5,[r4,#0x20]         ;4305
000322  f8843021          STRB     r3,[r4,#0x21]         ;4305
000326  f8048c01          STRB     r8,[r4,#-1]           ;4306
00032a  ea4f2318          LSR      r3,r8,#8              ;4306
00032e  7023              STRB     r3,[r4,#0]            ;4306
000330  ea4f4318          LSR      r3,r8,#16             ;4306
000334  7063              STRB     r3,[r4,#1]            ;4306
000336  ea4f6318          LSR      r3,r8,#24             ;4306
00033a  70a3              STRB     r3,[r4,#2]            ;4306
00033c  2302              MOVS     r3,#2                 ;4307
00033e  71e3              STRB     r3,[r4,#7]            ;4307
000340  7220              STRB     r0,[r4,#8]            ;4307
000342  7260              STRB     r0,[r4,#9]            ;4307
000344  72a0              STRB     r0,[r4,#0xa]          ;4307
000346  2301              MOVS     r3,#1                 ;4308
000348  72e3              STRB     r3,[r4,#0xb]          ;4308
00034a  7320              STRB     r0,[r4,#0xc]          ;4308
00034c  2306              MOVS     r3,#6                 ;4309
00034e  7363              STRB     r3,[r4,#0xd]          ;4309
000350  73a0              STRB     r0,[r4,#0xe]          ;4309
000352  76e1              STRB     r1,[r4,#0x1b]         ;4310
000354  7762              STRB     r2,[r4,#0x1d]         ;4311
000356  3c25              SUBS     r4,r4,#0x25           ;4311
000358  2213              MOVS     r2,#0x13              ;4312
00035a  a137              ADR      r1,|L25.1080|
00035c  f1040047          ADD      r0,r4,#0x47           ;4312
000360  f7fffffe          BL       mem_cpy
000364  e7c8              B        |L25.760|
                  |L25.870|
000366  2e03              CMP      r6,#3                 ;4323
000368  d106              BNE      |L25.888|
00036a  2301              MOVS     r3,#1                 ;4324
00036c  f1090206          ADD      r2,r9,#6              ;4324
000370  4621              MOV      r1,r4                 ;4324
000372  9805              LDR      r0,[sp,#0x14]         ;4324
000374  f7fffffe          BL       disk_write
                  |L25.888|
000378  465d              MOV      r5,r11                ;4327
00037a  f04f0b00          MOV      r11,#0                ;4328
                  |L25.894|
00037e  f44f7200          MOV      r2,#0x200             ;4329
000382  2100              MOVS     r1,#0                 ;4329
000384  4620              MOV      r0,r4                 ;4329
000386  f7fffffe          BL       mem_set
00038a  9807              LDR      r0,[sp,#0x1c]         ;4330
00038c  9003              STR      r0,[sp,#0xc]          ;4330
00038e  2e03              CMP      r6,#3                 ;4331
000390  d012              BEQ      |L25.952|
000392  2e01              CMP      r6,#1                 ;4332
000394  d00e              BEQ      |L25.948|
000396  f06f01ff          MVN      r1,#0xff              ;4332
                  |L25.922|
00039a  4301              ORRS     r1,r1,r0              ;4332
00039c  9103              STR      r1,[sp,#0xc]          ;4332
00039e  7021              STRB     r1,[r4,#0]            ;4333
0003a0  9803              LDR      r0,[sp,#0xc]          ;4333
0003a2  0a00              LSRS     r0,r0,#8              ;4333
0003a4  7060              STRB     r0,[r4,#1]            ;4333
0003a6  9803              LDR      r0,[sp,#0xc]          ;4333
0003a8  0c00              LSRS     r0,r0,#16             ;4333
0003aa  70a0              STRB     r0,[r4,#2]            ;4333
0003ac  9803              LDR      r0,[sp,#0xc]          ;4333
0003ae  0e00              LSRS     r0,r0,#24             ;4333
0003b0  70e0              STRB     r0,[r4,#3]            ;4333
0003b2  e018              B        |L25.998|
                  |L25.948|
0003b4  4925              LDR      r1,|L25.1100|
0003b6  e7f0              B        |L25.922|
                  |L25.952|
0003b8  f06000ff          ORN      r0,r0,#0xff           ;4335
0003bc  9003              STR      r0,[sp,#0xc]          ;4335
0003be  7020              STRB     r0,[r4,#0]            ;4336
0003c0  9803              LDR      r0,[sp,#0xc]          ;4336
0003c2  0a00              LSRS     r0,r0,#8              ;4336
0003c4  7060              STRB     r0,[r4,#1]            ;4336
0003c6  9803              LDR      r0,[sp,#0xc]          ;4336
0003c8  0c00              LSRS     r0,r0,#16             ;4336
0003ca  70a0              STRB     r0,[r4,#2]            ;4336
0003cc  9803              LDR      r0,[sp,#0xc]          ;4336
0003ce  0e00              LSRS     r0,r0,#24             ;4336
0003d0  70e0              STRB     r0,[r4,#3]            ;4336
0003d2  20ff              MOVS     r0,#0xff              ;4337
0003d4  7120              STRB     r0,[r4,#4]            ;4337
0003d6  7160              STRB     r0,[r4,#5]            ;4337
0003d8  71a0              STRB     r0,[r4,#6]            ;4337
0003da  71e0              STRB     r0,[r4,#7]            ;4337
0003dc  7220              STRB     r0,[r4,#8]            ;4338
0003de  7260              STRB     r0,[r4,#9]            ;4338
0003e0  72a0              STRB     r0,[r4,#0xa]          ;4338
0003e2  200f              MOVS     r0,#0xf               ;4338
0003e4  72e0              STRB     r0,[r4,#0xb]          ;4338
                  |L25.998|
0003e6  462a              MOV      r2,r5                 ;4340
0003e8  1c6d              ADDS     r5,r5,#1              ;4340
0003ea  2301              MOVS     r3,#1                 ;4340
0003ec  4621              MOV      r1,r4                 ;4340
0003ee  9805              LDR      r0,[sp,#0x14]         ;4340
0003f0  f7fffffe          BL       disk_write
0003f4  b108              CBZ      r0,|L25.1018|
0003f6  2001              MOVS     r0,#1                 ;4341
0003f8  e60a              B        |L25.16|
                  |L25.1018|
0003fa  f44f7200          MOV      r2,#0x200             ;4342
0003fe  2100              MOVS     r1,#0                 ;4342
000400  4620              MOV      r0,r4                 ;4342
000402  f7fffffe          BL       mem_set
000406  2001              MOVS     r0,#1                 ;4343
000408  9003              STR      r0,[sp,#0xc]          ;4343
00040a  e02e              B        |L25.1130|
                  |L25.1036|
                          DCD      ||.data||+0x4
                  |L25.1040|
                          DCD      ||.constdata||+0x80
                  |L25.1044|
000414  ebfe904d          DCB      235,254,144,"MSDOS5.0",0
000418  53444f53
00041c  352e3000
                  |L25.1056|
                          DCD      0x46a10000
                  |L25.1060|
000424  4e4f204e          DCB      "NO NAME    FAT     ",0
000428  414d4520
00042c  20202046
000430  41542020
000434  20202000
                  |L25.1080|
000438  4e4f204e          DCB      "NO NAME    FAT32   ",0
00043c  414d4520
000440  20202046
000444  41543332
000448  20202000
                  |L25.1100|
                          DCD      0x00ffff00
                  |L25.1104|
000450  462a              MOV      r2,r5                 ;4344
000452  1c6d              ADDS     r5,r5,#1              ;4344
000454  2301              MOVS     r3,#1                 ;4344
000456  4621              MOV      r1,r4                 ;4344
000458  9805              LDR      r0,[sp,#0x14]         ;4344
00045a  f7fffffe          BL       disk_write
00045e  b108              CBZ      r0,|L25.1124|
000460  2001              MOVS     r0,#1                 ;4345
000462  e5d5              B        |L25.16|
                  |L25.1124|
000464  9803              LDR      r0,[sp,#0xc]          ;4343
000466  1c40              ADDS     r0,r0,#1              ;4343
000468  9003              STR      r0,[sp,#0xc]          ;4343
                  |L25.1130|
00046a  9803              LDR      r0,[sp,#0xc]          ;4343
00046c  4540              CMP      r0,r8                 ;4343
00046e  d3ef              BCC      |L25.1104|
000470  f10b0b01          ADD      r11,r11,#1            ;4328
000474  f1bb0f00          CMP      r11,#0                ;4328
000478  d081              BEQ      |L25.894|
00047a  2e03              CMP      r6,#3                 ;4350
00047c  d000              BEQ      |L25.1152|
00047e  4657              MOV      r7,r10                ;4350
                  |L25.1152|
000480  462a              MOV      r2,r5                 ;4352
000482  1c6d              ADDS     r5,r5,#1              ;4352
000484  2301              MOVS     r3,#1                 ;4352
000486  4621              MOV      r1,r4                 ;4352
000488  9805              LDR      r0,[sp,#0x14]         ;4352
00048a  f7fffffe          BL       disk_write
00048e  b108              CBZ      r0,|L25.1172|
000490  2001              MOVS     r0,#1                 ;4353
000492  e5bd              B        |L25.16|
                  |L25.1172|
000494  1e7f              SUBS     r7,r7,#1              ;4354
000496  d1f3              BNE      |L25.1152|
000498  2e03              CMP      r6,#3                 ;4364
00049a  d13a              BNE      |L25.1298|
00049c  2052              MOVS     r0,#0x52              ;4365
00049e  7020              STRB     r0,[r4,#0]            ;4365
0004a0  7060              STRB     r0,[r4,#1]            ;4365
0004a2  2061              MOVS     r0,#0x61              ;4365
0004a4  70a0              STRB     r0,[r4,#2]            ;4365
0004a6  2141              MOVS     r1,#0x41              ;4365
0004a8  70e1              STRB     r1,[r4,#3]            ;4365
0004aa  2272              MOVS     r2,#0x72              ;4366
0004ac  f88421e4          STRB     r2,[r4,#0x1e4]        ;4366
0004b0  f88421e5          STRB     r2,[r4,#0x1e5]        ;4366
0004b4  f88411e6          STRB     r1,[r4,#0x1e6]        ;4366
0004b8  f88401e7          STRB     r0,[r4,#0x1e7]        ;4366
0004bc  9804              LDR      r0,[sp,#0x10]         ;4367
0004be  1e40              SUBS     r0,r0,#1              ;4367
0004c0  f88401e8          STRB     r0,[r4,#0x1e8]        ;4367
0004c4  0a01              LSRS     r1,r0,#8              ;4367
0004c6  f88411e9          STRB     r1,[r4,#0x1e9]        ;4367
0004ca  0c01              LSRS     r1,r0,#16             ;4367
0004cc  f88411ea          STRB     r1,[r4,#0x1ea]        ;4367
0004d0  0e00              LSRS     r0,r0,#24             ;4367
0004d2  f88401eb          STRB     r0,[r4,#0x1eb]        ;4367
0004d6  2002              MOVS     r0,#2                 ;4368
0004d8  f88401ec          STRB     r0,[r4,#0x1ec]        ;4368
0004dc  2000              MOVS     r0,#0                 ;4368
0004de  f88401ed          STRB     r0,[r4,#0x1ed]        ;4368
0004e2  f88401ee          STRB     r0,[r4,#0x1ee]        ;4368
0004e6  f88401ef          STRB     r0,[r4,#0x1ef]        ;4368
0004ea  2055              MOVS     r0,#0x55              ;4369
0004ec  f88401fe          STRB     r0,[r4,#0x1fe]        ;4369
0004f0  20aa              MOVS     r0,#0xaa              ;4369
0004f2  f88401ff          STRB     r0,[r4,#0x1ff]        ;4369
0004f6  2301              MOVS     r3,#1                 ;4370
0004f8  f1090201          ADD      r2,r9,#1              ;4370
0004fc  4621              MOV      r1,r4                 ;4370
0004fe  9805              LDR      r0,[sp,#0x14]         ;4370
000500  f7fffffe          BL       disk_write
000504  2301              MOVS     r3,#1                 ;4371
000506  f1090207          ADD      r2,r9,#7              ;4371
00050a  4621              MOV      r1,r4                 ;4371
00050c  9805              LDR      r0,[sp,#0x14]         ;4371
00050e  f7fffffe          BL       disk_write
                  |L25.1298|
000512  2200              MOVS     r2,#0                 ;4374
000514  4611              MOV      r1,r2                 ;4374
000516  9805              LDR      r0,[sp,#0x14]         ;4374
000518  f7fffffe          BL       disk_ioctl
00051c  b108              CBZ      r0,|L25.1314|
00051e  2001              MOVS     r0,#1                 ;4374
000520  e576              B        |L25.16|
                  |L25.1314|
000522  2000              MOVS     r0,#0                 ;4374
000524  e574              B        |L25.16|
;;;4376   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2474   
;;;2475   FRESULT f_mount (
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;2476   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;2477   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;2478   	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
;;;2479   )
;;;2480   {
000004  b081              SUB      sp,sp,#4
000006  4616              MOV      r6,r2
;;;2481   	FATFS *cfs;
;;;2482   	int vol;
;;;2483   	FRESULT res;
;;;2484   	const TCHAR *rp = path;
000008  9802              LDR      r0,[sp,#8]
00000a  9000              STR      r0,[sp,#0]
;;;2485   
;;;2486   
;;;2487   	vol = get_ldnumber(&rp);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       get_ldnumber
000012  4604              MOV      r4,r0
;;;2488   	if (vol < 0) return FR_INVALID_DRIVE;
000014  2c00              CMP      r4,#0
000016  da03              BGE      |L26.32|
000018  200b              MOVS     r0,#0xb
                  |L26.26|
;;;2489   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;2490   
;;;2491   	if (cfs) {
;;;2492   #if _FS_LOCK
;;;2493   		clear_lock(cfs);
;;;2494   #endif
;;;2495   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;2496   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;2497   #endif
;;;2498   		cfs->fs_type = 0;				/* Clear old fs object */
;;;2499   	}
;;;2500   
;;;2501   	if (fs) {
;;;2502   		fs->fs_type = 0;				/* Clear new fs object */
;;;2503   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;2504   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;2505   #endif
;;;2506   	}
;;;2507   	FatFs[vol] = fs;					/* Register new fs object */
;;;2508   
;;;2509   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;2510   
;;;2511   	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
;;;2512   	LEAVE_FF(fs, res);
;;;2513   }
00001a  b004              ADD      sp,sp,#0x10
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L26.32|
000020  4f0e              LDR      r7,|L26.92|
000022  f8575024          LDR      r5,[r7,r4,LSL #2]     ;2489
000026  f04f0800          MOV      r8,#0                 ;2491
00002a  b125              CBZ      r5,|L26.54|
00002c  4628              MOV      r0,r5                 ;2493
00002e  f7fffffe          BL       clear_lock
000032  f8858200          STRB     r8,[r5,#0x200]        ;2498
                  |L26.54|
000036  9801              LDR      r0,[sp,#4]            ;2501
000038  2800              CMP      r0,#0                 ;2501
00003a  d001              BEQ      |L26.64|
00003c  f8808200          STRB     r8,[r0,#0x200]        ;2502
                  |L26.64|
000040  f8470024          STR      r0,[r7,r4,LSL #2]     ;2507
000044  d001              BEQ      |L26.74|
000046  2e01              CMP      r6,#1                 ;2509
000048  d001              BEQ      |L26.78|
                  |L26.74|
00004a  2000              MOVS     r0,#0                 ;2509
00004c  e7e5              B        |L26.26|
                  |L26.78|
00004e  2200              MOVS     r2,#0                 ;2511
000050  a902              ADD      r1,sp,#8              ;2511
000052  a801              ADD      r0,sp,#4              ;2511
000054  f7fffffe          BL       find_volume
000058  e7df              B        |L26.26|
;;;2514   
                          ENDP

00005a  0000              DCW      0x0000
                  |L26.92|
                          DCD      ||.data||+0x4

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2521   
;;;2522   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2523   	FIL* fp,			/* Pointer to the blank file object */
;;;2524   	const TCHAR* path,	/* Pointer to the file name */
;;;2525   	BYTE mode			/* Access mode and file open mode flags */
;;;2526   )
;;;2527   {
000004  f5ad7d0b          SUB      sp,sp,#0x22c
000008  4606              MOV      r6,r0
;;;2528   	FRESULT res;
;;;2529   	DIR dj;
;;;2530   	BYTE *dir;
;;;2531   	DEFINE_NAMEBUF;
;;;2532   #if !_FS_READONLY
;;;2533   	DWORD dw, cl;
;;;2534   #endif
;;;2535   
;;;2536   
;;;2537   	if (!fp) return FR_INVALID_OBJECT;
00000a  2e00              CMP      r6,#0
00000c  d00f              BEQ      |L27.46|
;;;2538   	fp->fs = 0;			/* Clear file object */
00000e  f04f0800          MOV      r8,#0
000012  f8c68200          STR      r8,[r6,#0x200]
;;;2539   
;;;2540   	/* Get logical drive number */
;;;2541   #if !_FS_READONLY
;;;2542   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
000016  f002071f          AND      r7,r2,#0x1f
;;;2543   	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
00001a  f0270201          BIC      r2,r7,#1
00001e  a98c              ADD      r1,sp,#0x230
000020  a883              ADD      r0,sp,#0x20c
000022  f7fffffe          BL       find_volume
000026  4604              MOV      r4,r0
;;;2544   #else
;;;2545   	mode &= FA_READ;
;;;2546   	res = find_volume(&dj.fs, &path, 0);
;;;2547   #endif
;;;2548   	if (res == FR_OK) {
000028  0020              MOVS     r0,r4
00002a  d005              BEQ      |L27.56|
00002c  e0b3              B        |L27.406|
                  |L27.46|
00002e  2009              MOVS     r0,#9                 ;2537
                  |L27.48|
;;;2549   		INIT_BUF(dj);
;;;2550   		res = follow_path(&dj, path);	/* Follow the file path */
;;;2551   		dir = dj.dir;
;;;2552   #if !_FS_READONLY	/* R/W configuration */
;;;2553   		if (res == FR_OK) {
;;;2554   			if (!dir)	/* Default directory itself */
;;;2555   				res = FR_INVALID_NAME;
;;;2556   #if _FS_LOCK
;;;2557   			else
;;;2558   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2559   #endif
;;;2560   		}
;;;2561   		/* Create or Open a file */
;;;2562   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;2563   			if (res != FR_OK) {					/* No file, create new */
;;;2564   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;2565   #if _FS_LOCK
;;;2566   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2567   #else
;;;2568   					res = dir_register(&dj);
;;;2569   #endif
;;;2570   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2571   				dir = dj.dir;					/* New entry */
;;;2572   			}
;;;2573   			else {								/* Any object is already existing */
;;;2574   				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2575   					res = FR_DENIED;
;;;2576   				} else {
;;;2577   					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2578   						res = FR_EXIST;
;;;2579   				}
;;;2580   			}
;;;2581   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;2582   				dw = GET_FATTIME();				/* Created time */
;;;2583   				ST_DWORD(dir + DIR_CrtTime, dw);
;;;2584   				dir[DIR_Attr] = 0;				/* Reset attribute */
;;;2585   				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
;;;2586   				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
;;;2587   				st_clust(dir, 0);				/* cluster = 0 */
;;;2588   				dj.fs->wflag = 1;
;;;2589   				if (cl) {						/* Remove the cluster chain if exist */
;;;2590   					dw = dj.fs->winsect;
;;;2591   					res = remove_chain(dj.fs, cl);
;;;2592   					if (res == FR_OK) {
;;;2593   						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;2594   						res = move_window(dj.fs, dw);
;;;2595   					}
;;;2596   				}
;;;2597   			}
;;;2598   		}
;;;2599   		else {	/* Open an existing file */
;;;2600   			if (res == FR_OK) {					/* Follow succeeded */
;;;2601   				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
;;;2602   					res = FR_NO_FILE;
;;;2603   				} else {
;;;2604   					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2605   						res = FR_DENIED;
;;;2606   				}
;;;2607   			}
;;;2608   		}
;;;2609   		if (res == FR_OK) {
;;;2610   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;2611   				mode |= FA__WRITTEN;
;;;2612   			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;;;2613   			fp->dir_ptr = dir;
;;;2614   #if _FS_LOCK
;;;2615   			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2616   			if (!fp->lockid) res = FR_INT_ERR;
;;;2617   #endif
;;;2618   		}
;;;2619   
;;;2620   #else				/* R/O configuration */
;;;2621   		if (res == FR_OK) {					/* Follow succeeded */
;;;2622   			dir = dj.dir;
;;;2623   			if (!dir) {						/* Current directory itself */
;;;2624   				res = FR_INVALID_NAME;
;;;2625   			} else {
;;;2626   				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2627   					res = FR_NO_FILE;
;;;2628   			}
;;;2629   		}
;;;2630   #endif
;;;2631   		FREE_BUF();
;;;2632   
;;;2633   		if (res == FR_OK) {
;;;2634   			fp->flag = mode;					/* File access mode */
;;;2635   			fp->err = 0;						/* Clear error flag */
;;;2636   			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;;;2637   			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
;;;2638   			fp->fptr = 0;						/* File pointer */
;;;2639   			fp->dsect = 0;
;;;2640   #if _USE_FASTSEEK
;;;2641   			fp->cltbl = 0;						/* Normal seek mode */
;;;2642   #endif
;;;2643   			fp->fs = dj.fs;	 					/* Validate file object */
;;;2644   			fp->id = fp->fs->id;
;;;2645   		}
;;;2646   	}
;;;2647   
;;;2648   	LEAVE_FF(dj.fs, res);
;;;2649   }
000030  f50d7d0e          ADD      sp,sp,#0x238
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L27.56|
000038  f8cdd224          STR      sp,[sp,#0x224]        ;2549
00003c  a803              ADD      r0,sp,#0xc            ;2550
00003e  998c              LDR      r1,[sp,#0x230]        ;2550
000040  f7fffffe          BL       follow_path
000044  4604              MOV      r4,r0                 ;2550
000046  9d88              LDR      r5,[sp,#0x220]        ;2551
000048  b95c              CBNZ     r4,|L27.98|
00004a  b11d              CBZ      r5,|L27.84|
00004c  0878              LSRS     r0,r7,#1              ;2558
00004e  d003              BEQ      |L27.88|
000050  2101              MOVS     r1,#1                 ;2558
000052  e002              B        |L27.90|
                  |L27.84|
000054  2406              MOVS     r4,#6                 ;2555
000056  e004              B        |L27.98|
                  |L27.88|
000058  2100              MOVS     r1,#0                 ;2558
                  |L27.90|
00005a  a803              ADD      r0,sp,#0xc            ;2558
00005c  f7fffffe          BL       chk_lock
000060  4604              MOV      r4,r0                 ;2558
                  |L27.98|
000062  f0170f1c          TST      r7,#0x1c              ;2562
000066  d052              BEQ      |L27.270|
000068  b174              CBZ      r4,|L27.136|
00006a  2c04              CMP      r4,#4                 ;2564
00006c  d108              BNE      |L27.128|
00006e  f7fffffe          BL       enq_lock
000072  b120              CBZ      r0,|L27.126|
000074  a803              ADD      r0,sp,#0xc            ;2566
000076  f7fffffe          BL       dir_register
00007a  4604              MOV      r4,r0                 ;2566
00007c  e000              B        |L27.128|
                  |L27.126|
00007e  2412              MOVS     r4,#0x12              ;2566
                  |L27.128|
000080  f0470708          ORR      r7,r7,#8              ;2570
000084  9d88              LDR      r5,[sp,#0x220]        ;2571
000086  e008              B        |L27.154|
                  |L27.136|
000088  7ae8              LDRB     r0,[r5,#0xb]          ;2574
00008a  f0100f11          TST      r0,#0x11              ;2574
00008e  d001              BEQ      |L27.148|
000090  2407              MOVS     r4,#7                 ;2575
000092  e002              B        |L27.154|
                  |L27.148|
000094  0778              LSLS     r0,r7,#29             ;2577
000096  d500              BPL      |L27.154|
000098  2408              MOVS     r4,#8                 ;2578
                  |L27.154|
00009a  bbbc              CBNZ     r4,|L27.268|
00009c  0738              LSLS     r0,r7,#28             ;2581
00009e  d541              BPL      |L27.292|
0000a0  f885800e          STRB     r8,[r5,#0xe]          ;2583
0000a4  f885800f          STRB     r8,[r5,#0xf]          ;2583
0000a8  20a1              MOVS     r0,#0xa1              ;2583
0000aa  7428              STRB     r0,[r5,#0x10]         ;2583
0000ac  2046              MOVS     r0,#0x46              ;2583
0000ae  7468              STRB     r0,[r5,#0x11]         ;2583
0000b0  f885800b          STRB     r8,[r5,#0xb]          ;2584
0000b4  f885801c          STRB     r8,[r5,#0x1c]         ;2585
0000b8  f885801d          STRB     r8,[r5,#0x1d]         ;2585
0000bc  f885801e          STRB     r8,[r5,#0x1e]         ;2585
0000c0  f885801f          STRB     r8,[r5,#0x1f]         ;2585
0000c4  4629              MOV      r1,r5                 ;2586
0000c6  9883              LDR      r0,[sp,#0x20c]        ;2586
0000c8  f7fffffe          BL       ld_clust
0000cc  4681              MOV      r9,r0                 ;2586
0000ce  2100              MOVS     r1,#0                 ;2587
0000d0  4628              MOV      r0,r5                 ;2587
0000d2  f7fffffe          BL       st_clust
0000d6  9983              LDR      r1,[sp,#0x20c]        ;2588
0000d8  2001              MOVS     r0,#1                 ;2588
0000da  f8810204          STRB     r0,[r1,#0x204]        ;2588
0000de  f1b90f00          CMP      r9,#0                 ;2589
0000e2  d01f              BEQ      |L27.292|
0000e4  9883              LDR      r0,[sp,#0x20c]        ;2590
0000e6  f8d0a22c          LDR      r10,[r0,#0x22c]       ;2590
0000ea  4649              MOV      r1,r9                 ;2591
0000ec  9883              LDR      r0,[sp,#0x20c]        ;2591
0000ee  f7fffffe          BL       remove_chain
0000f2  4604              MOV      r4,r0                 ;2591
0000f4  0020              MOVS     r0,r4                 ;2592
0000f6  d115              BNE      |L27.292|
0000f8  9883              LDR      r0,[sp,#0x20c]        ;2593
0000fa  f1a90901          SUB      r9,r9,#1              ;2593
0000fe  f8c0920c          STR      r9,[r0,#0x20c]        ;2593
000102  4651              MOV      r1,r10                ;2594
000104  9883              LDR      r0,[sp,#0x20c]        ;2594
000106  f7fffffe          BL       move_window
00010a  4604              MOV      r4,r0                 ;2594
                  |L27.268|
00010c  e00a              B        |L27.292|
                  |L27.270|
00010e  b94c              CBNZ     r4,|L27.292|
000110  7ae8              LDRB     r0,[r5,#0xb]          ;2601
000112  06c1              LSLS     r1,r0,#27             ;2601
000114  d501              BPL      |L27.282|
000116  2404              MOVS     r4,#4                 ;2602
000118  e004              B        |L27.292|
                  |L27.282|
00011a  07b9              LSLS     r1,r7,#30             ;2604
00011c  d502              BPL      |L27.292|
00011e  07c0              LSLS     r0,r0,#31             ;2604
000120  d000              BEQ      |L27.292|
000122  2407              MOVS     r4,#7                 ;2605
                  |L27.292|
000124  b9b4              CBNZ     r4,|L27.340|
000126  0738              LSLS     r0,r7,#28             ;2610
000128  d501              BPL      |L27.302|
00012a  f0470720          ORR      r7,r7,#0x20           ;2611
                  |L27.302|
00012e  9883              LDR      r0,[sp,#0x20c]        ;2612
000130  f8d0022c          LDR      r0,[r0,#0x22c]        ;2612
000134  f8c6021c          STR      r0,[r6,#0x21c]        ;2612
000138  f8c65220          STR      r5,[r6,#0x220]        ;2613
00013c  0878              LSRS     r0,r7,#1              ;2615
00013e  d001              BEQ      |L27.324|
000140  2101              MOVS     r1,#1                 ;2615
000142  e000              B        |L27.326|
                  |L27.324|
000144  2100              MOVS     r1,#0                 ;2615
                  |L27.326|
000146  a803              ADD      r0,sp,#0xc            ;2615
000148  f7fffffe          BL       inc_lock
00014c  f8c60228          STR      r0,[r6,#0x228]        ;2615
000150  b900              CBNZ     r0,|L27.340|
000152  2402              MOVS     r4,#2                 ;2616
                  |L27.340|
000154  b9fc              CBNZ     r4,|L27.406|
000156  f5067600          ADD      r6,r6,#0x200          ;2634
00015a  71b7              STRB     r7,[r6,#6]            ;2634
00015c  f8868007          STRB     r8,[r6,#7]            ;2635
000160  4629              MOV      r1,r5                 ;2636
000162  9883              LDR      r0,[sp,#0x20c]        ;2636
000164  f7fffffe          BL       ld_clust
000168  6130              STR      r0,[r6,#0x10]         ;2636
00016a  7f28              LDRB     r0,[r5,#0x1c]         ;2637
00016c  7fe9              LDRB     r1,[r5,#0x1f]         ;2637
00016e  7f6a              LDRB     r2,[r5,#0x1d]         ;2637
000170  ea406001          ORR      r0,r0,r1,LSL #24      ;2637
000174  7fa9              LDRB     r1,[r5,#0x1e]         ;2637
000176  0409              LSLS     r1,r1,#16             ;2637
000178  ea412102          ORR      r1,r1,r2,LSL #8       ;2637
00017c  4308              ORRS     r0,r0,r1              ;2637
00017e  60f0              STR      r0,[r6,#0xc]          ;2637
000180  f8c68008          STR      r8,[r6,#8]            ;2638
000184  f8c68018          STR      r8,[r6,#0x18]         ;2639
000188  f8c68024          STR      r8,[r6,#0x24]         ;2641
00018c  9883              LDR      r0,[sp,#0x20c]        ;2643
00018e  6030              STR      r0,[r6,#0]            ;2643
000190  f8b00206          LDRH     r0,[r0,#0x206]        ;2644
000194  80b0              STRH     r0,[r6,#4]            ;2644
                  |L27.406|
000196  4620              MOV      r0,r4                 ;2648
000198  e74a              B        |L27.48|
;;;2650   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;3259   
;;;3260   FRESULT f_opendir (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;3261   	DIR* dp,			/* Pointer to directory object to create */
;;;3262   	const TCHAR* path	/* Pointer to the directory path */
;;;3263   )
;;;3264   {
000002  b084              SUB      sp,sp,#0x10
000004  4605              MOV      r5,r0
;;;3265   	FRESULT res;
;;;3266   	FATFS* fs;
;;;3267   	DEFINE_NAMEBUF;
;;;3268   
;;;3269   
;;;3270   	if (!dp) return FR_INVALID_OBJECT;
000006  2d00              CMP      r5,#0
000008  d008              BEQ      |L28.28|
;;;3271   
;;;3272   	/* Get logical drive number */
;;;3273   	res = find_volume(&fs, &path, 0);
00000a  2200              MOVS     r2,#0
00000c  a905              ADD      r1,sp,#0x14
00000e  a803              ADD      r0,sp,#0xc
000010  f7fffffe          BL       find_volume
000014  4604              MOV      r4,r0
;;;3274   	if (res == FR_OK) {
000016  2600              MOVS     r6,#0
000018  b11c              CBZ      r4,|L28.34|
00001a  e037              B        |L28.140|
                  |L28.28|
00001c  2009              MOVS     r0,#9                 ;3270
                  |L28.30|
;;;3275   		dp->fs = fs;
;;;3276   		INIT_BUF(*dp);
;;;3277   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;3278   		FREE_BUF();
;;;3279   		if (res == FR_OK) {						/* Follow completed */
;;;3280   			if (dp->dir) {						/* It is not the origin directory itself */
;;;3281   				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
;;;3282   					dp->sclust = ld_clust(fs, dp->dir);
;;;3283   				else							/* The object is a file */
;;;3284   					res = FR_NO_PATH;
;;;3285   			}
;;;3286   			if (res == FR_OK) {
;;;3287   				dp->id = fs->id;
;;;3288   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;3289   #if _FS_LOCK
;;;3290   				if (res == FR_OK) {
;;;3291   					if (dp->sclust) {
;;;3292   						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;3293   						if (!dp->lockid)
;;;3294   							res = FR_TOO_MANY_OPEN_FILES;
;;;3295   					} else {
;;;3296   						dp->lockid = 0;	/* Root directory need not to be locked */
;;;3297   					}
;;;3298   				}
;;;3299   #endif
;;;3300   			}
;;;3301   		}
;;;3302   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;3303   	}
;;;3304   	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
;;;3305   
;;;3306   	LEAVE_FF(fs, res);
;;;3307   }
00001e  b006              ADD      sp,sp,#0x18
000020  bd70              POP      {r4-r6,pc}
                  |L28.34|
000022  9803              LDR      r0,[sp,#0xc]          ;3275
000024  f8c50200          STR      r0,[r5,#0x200]        ;3275
000028  f8c5d218          STR      sp,[r5,#0x218]        ;3276
00002c  4628              MOV      r0,r5                 ;3277
00002e  9905              LDR      r1,[sp,#0x14]         ;3277
000030  f7fffffe          BL       follow_path
000034  4604              MOV      r4,r0                 ;3277
000036  bb1c              CBNZ     r4,|L28.128|
000038  f8d51214          LDR      r1,[r5,#0x214]        ;3280
00003c  b149              CBZ      r1,|L28.82|
00003e  7ac8              LDRB     r0,[r1,#0xb]          ;3281
000040  06c0              LSLS     r0,r0,#27             ;3281
000042  d505              BPL      |L28.80|
000044  9803              LDR      r0,[sp,#0xc]          ;3282
000046  f7fffffe          BL       ld_clust
00004a  f8c50208          STR      r0,[r5,#0x208]        ;3282
00004e  e000              B        |L28.82|
                  |L28.80|
000050  2405              MOVS     r4,#5                 ;3284
                  |L28.82|
000052  b9ac              CBNZ     r4,|L28.128|
000054  9803              LDR      r0,[sp,#0xc]          ;3287
000056  f8b00206          LDRH     r0,[r0,#0x206]        ;3287
00005a  f8a50204          STRH     r0,[r5,#0x204]        ;3287
00005e  2100              MOVS     r1,#0                 ;3288
000060  4628              MOV      r0,r5                 ;3288
000062  f7fffffe          BL       dir_sdi
000066  4604              MOV      r4,r0                 ;3288
000068  b954              CBNZ     r4,|L28.128|
00006a  f8d50208          LDR      r0,[r5,#0x208]        ;3291
00006e  b140              CBZ      r0,|L28.130|
000070  2100              MOVS     r1,#0                 ;3292
000072  4628              MOV      r0,r5                 ;3292
000074  f7fffffe          BL       inc_lock
000078  f8c5021c          STR      r0,[r5,#0x21c]        ;3292
00007c  b900              CBNZ     r0,|L28.128|
00007e  2412              MOVS     r4,#0x12              ;3294
                  |L28.128|
000080  e001              B        |L28.134|
                  |L28.130|
000082  f8c5621c          STR      r6,[r5,#0x21c]        ;3296
                  |L28.134|
000086  2c04              CMP      r4,#4                 ;3302
000088  d100              BNE      |L28.140|
00008a  2405              MOVS     r4,#5                 ;3302
                  |L28.140|
00008c  b10c              CBZ      r4,|L28.146|
00008e  f8c56200          STR      r6,[r5,#0x200]        ;3304
                  |L28.146|
000092  4620              MOV      r0,r4                 ;3306
000094  e7c3              B        |L28.30|
;;;3308   
                          ENDP


                          AREA ||i.f_printf||, CODE, READONLY, ALIGN=1

                  f_printf PROC
;;;4653   
;;;4654   int f_printf (
000000  b40f              PUSH     {r0-r3}
;;;4655   	FIL* fp,			/* Pointer to the file object */
;;;4656   	const TCHAR* fmt,	/* Pointer to the format string */
;;;4657   	...					/* Optional arguments... */
;;;4658   )
;;;4659   {
000002  e92d47f0          PUSH     {r4-r10,lr}
000006  b09a              SUB      sp,sp,#0x68
;;;4660   	va_list arp;
;;;4661   	BYTE f, r;
;;;4662   	UINT nw, i, j, w;
;;;4663   	DWORD v;
;;;4664   	TCHAR c, d, s[16], *p;
;;;4665   	putbuff pb;
;;;4666   
;;;4667   
;;;4668   	pb.fp = fp;				/* Initialize output buffer */
000008  9001              STR      r0,[sp,#4]
;;;4669   	pb.nchr = pb.idx = 0;
00000a  f04f0800          MOV      r8,#0
00000e  f8cd8008          STR      r8,[sp,#8]
000012  f8cd800c          STR      r8,[sp,#0xc]
;;;4670   
;;;4671   	va_start(arp, fmt);
000016  a824              ADD      r0,sp,#0x90
000018  9019              STR      r0,[sp,#0x64]
00001a  af14              ADD      r7,sp,#0x50           ;4664
                  |L29.28|
;;;4672   
;;;4673   	for (;;) {
;;;4674   		c = *fmt++;
00001c  9823              LDR      r0,[sp,#0x8c]
00001e  f8101b01          LDRB     r1,[r0],#1
000022  9023              STR      r0,[sp,#0x8c]
;;;4675   		if (c == 0) break;			/* End of string */
000024  2900              CMP      r1,#0
000026  d06e              BEQ      |L29.262|
;;;4676   		if (c != '%') {				/* Non escape character */
000028  2925              CMP      r1,#0x25
00002a  d003              BEQ      |L29.52|
;;;4677   			putc_bfd(&pb, c);
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       putc_bfd
;;;4678   			continue;
000032  e7f3              B        |L29.28|
                  |L29.52|
;;;4679   		}
;;;4680   		w = f = 0;
000034  2500              MOVS     r5,#0
000036  462e              MOV      r6,r5
;;;4681   		c = *fmt++;
000038  f8101b01          LDRB     r1,[r0],#1
00003c  9023              STR      r0,[sp,#0x8c]
;;;4682   		if (c == '0') {				/* Flag: '0' padding */
00003e  2930              CMP      r1,#0x30
000040  d002              BEQ      |L29.72|
;;;4683   			f = 1; c = *fmt++;
;;;4684   		} else {
;;;4685   			if (c == '-') {			/* Flag: left justified */
000042  292d              CMP      r1,#0x2d
000044  d005              BEQ      |L29.82|
000046  e012              B        |L29.110|
                  |L29.72|
000048  2501              MOVS     r5,#1                 ;4683
00004a  f8101b01          LDRB     r1,[r0],#1            ;4683
00004e  9023              STR      r0,[sp,#0x8c]         ;4683
000050  e00d              B        |L29.110|
                  |L29.82|
;;;4686   				f = 2; c = *fmt++;
000052  2502              MOVS     r5,#2
000054  f8101b01          LDRB     r1,[r0],#1
000058  9023              STR      r0,[sp,#0x8c]
00005a  e008              B        |L29.110|
                  |L29.92|
;;;4687   			}
;;;4688   		}
;;;4689   		while (IsDigit(c)) {		/* Precision */
;;;4690   			w = w * 10 + c - '0';
00005c  eb060086          ADD      r0,r6,r6,LSL #2
000060  eb010640          ADD      r6,r1,r0,LSL #1
000064  3e30              SUBS     r6,r6,#0x30
;;;4691   			c = *fmt++;
000066  9823              LDR      r0,[sp,#0x8c]
000068  f8101b01          LDRB     r1,[r0],#1
00006c  9023              STR      r0,[sp,#0x8c]
                  |L29.110|
00006e  f1a10030          SUB      r0,r1,#0x30           ;4689
000072  2809              CMP      r0,#9                 ;4689
000074  d9f2              BLS      |L29.92|
;;;4692   		}
;;;4693   		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
000076  296c              CMP      r1,#0x6c
000078  d001              BEQ      |L29.126|
00007a  294c              CMP      r1,#0x4c
00007c  d105              BNE      |L29.138|
                  |L29.126|
;;;4694   			f |= 4; c = *fmt++;
00007e  f0450504          ORR      r5,r5,#4
000082  9823              LDR      r0,[sp,#0x8c]
000084  f8101b01          LDRB     r1,[r0],#1
000088  9023              STR      r0,[sp,#0x8c]
                  |L29.138|
;;;4695   		}
;;;4696   		if (!c) break;
00008a  2900              CMP      r1,#0
00008c  d03b              BEQ      |L29.262|
;;;4697   		d = c;
00008e  460a              MOV      r2,r1
;;;4698   		if (IsLower(d)) d -= 0x20;
000090  f1a20061          SUB      r0,r2,#0x61
000094  2819              CMP      r0,#0x19
000096  d801              BHI      |L29.156|
000098  3a20              SUBS     r2,r2,#0x20
00009a  b2d2              UXTB     r2,r2
                  |L29.156|
;;;4699   		switch (d) {				/* Type is... */
00009c  2a4f              CMP      r2,#0x4f
00009e  d046              BEQ      |L29.302|
0000a0  dc06              BGT      |L29.176|
0000a2  2a42              CMP      r2,#0x42
0000a4  d041              BEQ      |L29.298|
0000a6  2a43              CMP      r2,#0x43
0000a8  d037              BEQ      |L29.282|
0000aa  2a44              CMP      r2,#0x44
0000ac  d106              BNE      |L29.188|
0000ae  e040              B        |L29.306|
                  |L29.176|
0000b0  2a53              CMP      r2,#0x53
0000b2  d007              BEQ      |L29.196|
0000b4  2a55              CMP      r2,#0x55
0000b6  d03c              BEQ      |L29.306|
0000b8  2a58              CMP      r2,#0x58
0000ba  d03c              BEQ      |L29.310|
                  |L29.188|
;;;4700   		case 'S' :					/* String */
;;;4701   			p = va_arg(arp, TCHAR*);
;;;4702   			for (j = 0; p[j]; j++) ;
;;;4703   			if (!(f & 2)) {
;;;4704   				while (j++ < w) putc_bfd(&pb, ' ');
;;;4705   			}
;;;4706   			while (*p) putc_bfd(&pb, *p++);
;;;4707   			while (j++ < w) putc_bfd(&pb, ' ');
;;;4708   			continue;
;;;4709   		case 'C' :					/* Character */
;;;4710   			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
;;;4711   		case 'B' :					/* Binary */
;;;4712   			r = 2; break;
;;;4713   		case 'O' :					/* Octal */
;;;4714   			r = 8; break;
;;;4715   		case 'D' :					/* Signed decimal */
;;;4716   		case 'U' :					/* Unsigned decimal */
;;;4717   			r = 10; break;
;;;4718   		case 'X' :					/* Hexdecimal */
;;;4719   			r = 16; break;
;;;4720   		default:					/* Unknown type (pass-through) */
;;;4721   			putc_bfd(&pb, c); continue;
0000bc  a801              ADD      r0,sp,#4
0000be  f7fffffe          BL       putc_bfd
0000c2  e7ab              B        |L29.28|
                  |L29.196|
0000c4  9819              LDR      r0,[sp,#0x64]         ;4701
0000c6  f8509b04          LDR      r9,[r0],#4            ;4701
0000ca  9019              STR      r0,[sp,#0x64]         ;4701
0000cc  2400              MOVS     r4,#0                 ;4702
0000ce  e000              B        |L29.210|
                  |L29.208|
0000d0  1c64              ADDS     r4,r4,#1              ;4702
                  |L29.210|
0000d2  f8190004          LDRB     r0,[r9,r4]            ;4702
0000d6  2800              CMP      r0,#0                 ;4702
0000d8  d1fa              BNE      |L29.208|
0000da  07a8              LSLS     r0,r5,#30             ;4703
0000dc  d504              BPL      |L29.232|
0000de  e00d              B        |L29.252|
                  |L29.224|
0000e0  2120              MOVS     r1,#0x20              ;4704
0000e2  a801              ADD      r0,sp,#4              ;4704
0000e4  f7fffffe          BL       putc_bfd
                  |L29.232|
0000e8  4620              MOV      r0,r4                 ;4704
0000ea  1c64              ADDS     r4,r4,#1              ;4704
0000ec  42b0              CMP      r0,r6                 ;4704
0000ee  d3f7              BCC      |L29.224|
0000f0  e004              B        |L29.252|
                  |L29.242|
0000f2  f1090901          ADD      r9,r9,#1              ;4706
0000f6  a801              ADD      r0,sp,#4              ;4706
0000f8  f7fffffe          BL       putc_bfd
                  |L29.252|
0000fc  f8991000          LDRB     r1,[r9,#0]            ;4706
000100  2900              CMP      r1,#0                 ;4706
000102  d1f6              BNE      |L29.242|
000104  e004              B        |L29.272|
                  |L29.262|
000106  e07b              B        |L29.512|
                  |L29.264|
000108  2120              MOVS     r1,#0x20              ;4707
00010a  a801              ADD      r0,sp,#4              ;4707
00010c  f7fffffe          BL       putc_bfd
                  |L29.272|
000110  4620              MOV      r0,r4                 ;4707
000112  1c64              ADDS     r4,r4,#1              ;4707
000114  42b0              CMP      r0,r6                 ;4707
000116  d281              BCS      |L29.28|
000118  e7f6              B        |L29.264|
                  |L29.282|
00011a  9819              LDR      r0,[sp,#0x64]         ;4710
00011c  f8101b04          LDRB     r1,[r0],#4            ;4710
000120  9019              STR      r0,[sp,#0x64]         ;4710
000122  a801              ADD      r0,sp,#4              ;4710
000124  f7fffffe          BL       putc_bfd
                  |L29.296|
000128  e778              B        |L29.28|
                  |L29.298|
00012a  2302              MOVS     r3,#2                 ;4712
00012c  e004              B        |L29.312|
                  |L29.302|
00012e  2308              MOVS     r3,#8                 ;4714
000130  e002              B        |L29.312|
                  |L29.306|
000132  230a              MOVS     r3,#0xa               ;4717
000134  e000              B        |L29.312|
                  |L29.310|
000136  2310              MOVS     r3,#0x10              ;4719
                  |L29.312|
;;;4722   		}
;;;4723   
;;;4724   		/* Get an argument and put it in numeral */
;;;4725   		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
000138  0768              LSLS     r0,r5,#29
00013a  d505              BPL      |L29.328|
00013c  9819              LDR      r0,[sp,#0x64]
00013e  9c19              LDR      r4,[sp,#0x64]
000140  6800              LDR      r0,[r0,#0]
000142  1d24              ADDS     r4,r4,#4
000144  9419              STR      r4,[sp,#0x64]
000146  e006              B        |L29.342|
                  |L29.328|
000148  2a44              CMP      r2,#0x44
00014a  d007              BEQ      |L29.348|
00014c  9819              LDR      r0,[sp,#0x64]
00014e  9c19              LDR      r4,[sp,#0x64]
000150  6800              LDR      r0,[r0,#0]
000152  1d24              ADDS     r4,r4,#4
000154  9419              STR      r4,[sp,#0x64]
                  |L29.342|
;;;4726   		if (d == 'D' && (v & 0x80000000)) {
000156  2a44              CMP      r2,#0x44
000158  d006              BEQ      |L29.360|
00015a  e00a              B        |L29.370|
                  |L29.348|
00015c  9819              LDR      r0,[sp,#0x64]         ;4725
00015e  9c19              LDR      r4,[sp,#0x64]         ;4725
000160  6800              LDR      r0,[r0,#0]            ;4725
000162  1d24              ADDS     r4,r4,#4              ;4725
000164  9419              STR      r4,[sp,#0x64]         ;4725
000166  e7f6              B        |L29.342|
                  |L29.360|
000168  2800              CMP      r0,#0
00016a  da02              BGE      |L29.370|
;;;4727   			v = 0 - v;
00016c  4240              RSBS     r0,r0,#0
;;;4728   			f |= 8;
00016e  f0450508          ORR      r5,r5,#8
                  |L29.370|
;;;4729   		}
;;;4730   		i = 0;
000172  2400              MOVS     r4,#0
                  |L29.372|
;;;4731   		do {
;;;4732   			d = (TCHAR)(v % r); v /= r;
000174  fbb0f2f3          UDIV     r2,r0,r3
000178  fb030212          MLS      r2,r3,r2,r0
00017c  b2d2              UXTB     r2,r2
00017e  fbb0f0f3          UDIV     r0,r0,r3
;;;4733   			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
000182  2a09              CMP      r2,#9
000184  d905              BLS      |L29.402|
000186  2978              CMP      r1,#0x78
000188  d017              BEQ      |L29.442|
00018a  f04f0c07          MOV      r12,#7
                  |L29.398|
00018e  4462              ADD      r2,r2,r12
000190  b2d2              UXTB     r2,r2
                  |L29.402|
;;;4734   			s[i++] = d + '0';
000192  3230              ADDS     r2,r2,#0x30
000194  46a4              MOV      r12,r4
000196  1c64              ADDS     r4,r4,#1
000198  f807200c          STRB     r2,[r7,r12]
;;;4735   		} while (v && i < sizeof s / sizeof s[0]);
00019c  b108              CBZ      r0,|L29.418|
00019e  2c10              CMP      r4,#0x10
0001a0  d3e8              BCC      |L29.372|
                  |L29.418|
;;;4736   		if (f & 8) s[i++] = '-';
0001a2  0728              LSLS     r0,r5,#28
0001a4  d503              BPL      |L29.430|
0001a6  222d              MOVS     r2,#0x2d
0001a8  4620              MOV      r0,r4
0001aa  1c64              ADDS     r4,r4,#1
0001ac  543a              STRB     r2,[r7,r0]
                  |L29.430|
;;;4737   		j = i; d = (f & 1) ? '0' : ' ';
0001ae  46a1              MOV      r9,r4
0001b0  07e8              LSLS     r0,r5,#31
0001b2  d005              BEQ      |L29.448|
0001b4  f04f0a30          MOV      r10,#0x30
0001b8  e009              B        |L29.462|
                  |L29.442|
0001ba  f04f0c27          MOV      r12,#0x27             ;4733
0001be  e7e6              B        |L29.398|
                  |L29.448|
0001c0  f04f0a20          MOV      r10,#0x20
0001c4  e003              B        |L29.462|
                  |L29.454|
;;;4738   		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
0001c6  4651              MOV      r1,r10
0001c8  a801              ADD      r0,sp,#4
0001ca  f7fffffe          BL       putc_bfd
                  |L29.462|
0001ce  07a8              LSLS     r0,r5,#30
0001d0  d404              BMI      |L29.476|
0001d2  4648              MOV      r0,r9
0001d4  f1090901          ADD      r9,r9,#1
0001d8  42b0              CMP      r0,r6
0001da  d3f4              BCC      |L29.454|
                  |L29.476|
;;;4739   		do putc_bfd(&pb, s[--i]); while (i);
0001dc  1e64              SUBS     r4,r4,#1
0001de  a801              ADD      r0,sp,#4
0001e0  5d39              LDRB     r1,[r7,r4]
0001e2  f7fffffe          BL       putc_bfd
0001e6  2c00              CMP      r4,#0
0001e8  d1f8              BNE      |L29.476|
0001ea  e003              B        |L29.500|
                  |L29.492|
;;;4740   		while (j++ < w) putc_bfd(&pb, d);
0001ec  4651              MOV      r1,r10
0001ee  a801              ADD      r0,sp,#4
0001f0  f7fffffe          BL       putc_bfd
                  |L29.500|
0001f4  4648              MOV      r0,r9
0001f6  f1090901          ADD      r9,r9,#1
0001fa  42b0              CMP      r0,r6
0001fc  d294              BCS      |L29.296|
0001fe  e7f5              B        |L29.492|
                  |L29.512|
;;;4741   	}
;;;4742   
;;;4743   	va_end(arp);
000200  f8cd8064          STR      r8,[sp,#0x64]
;;;4744   
;;;4745   	if (   pb.idx >= 0		/* Flush buffered characters to the file */
000204  9802              LDR      r0,[sp,#8]
000206  2800              CMP      r0,#0
000208  db10              BLT      |L29.556|
;;;4746   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
00020a  e9dd0201          LDRD     r0,r2,[sp,#4]
00020e  ab18              ADD      r3,sp,#0x60
000210  a904              ADD      r1,sp,#0x10
000212  f7fffffe          BL       f_write
000216  b948              CBNZ     r0,|L29.556|
;;;4747   		&& (UINT)pb.idx == nw) return pb.nchr;
000218  9918              LDR      r1,[sp,#0x60]
00021a  9802              LDR      r0,[sp,#8]
00021c  4288              CMP      r0,r1
00021e  d105              BNE      |L29.556|
000220  9803              LDR      r0,[sp,#0xc]
                  |L29.546|
;;;4748   	return EOF;
;;;4749   }
000222  b01a              ADD      sp,sp,#0x68
000224  e8bd07f0          POP      {r4-r10}
000228  f85dfb14          LDR      pc,[sp],#0x14
                  |L29.556|
00022c  f04f30ff          MOV      r0,#0xffffffff        ;4748
000230  e7f7              B        |L29.546|
;;;4750   
                          ENDP


                          AREA ||i.f_putc||, CODE, READONLY, ALIGN=1

                  f_putc PROC
;;;4598   
;;;4599   int f_putc (
000000  b500              PUSH     {lr}
;;;4600   	TCHAR c,	/* A character to be output */
;;;4601   	FIL* fp		/* Pointer to the file object */
;;;4602   )
;;;4603   {
000002  b095              SUB      sp,sp,#0x54
;;;4604   	putbuff pb;
;;;4605   	UINT nw;
;;;4606   
;;;4607   
;;;4608   	pb.fp = fp;			/* Initialize output buffer */
000004  9102              STR      r1,[sp,#8]
;;;4609   	pb.nchr = pb.idx = 0;
000006  2100              MOVS     r1,#0
000008  9103              STR      r1,[sp,#0xc]
00000a  9104              STR      r1,[sp,#0x10]
;;;4610   
;;;4611   	putc_bfd(&pb, c);	/* Put a character */
00000c  4601              MOV      r1,r0
00000e  a802              ADD      r0,sp,#8
000010  f7fffffe          BL       putc_bfd
;;;4612   
;;;4613   	if (   pb.idx >= 0	/* Flush buffered characters to the file */
000014  9803              LDR      r0,[sp,#0xc]
000016  2800              CMP      r0,#0
000018  db0d              BLT      |L30.54|
;;;4614   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
00001a  e9dd0202          LDRD     r0,r2,[sp,#8]
00001e  ab01              ADD      r3,sp,#4
000020  a905              ADD      r1,sp,#0x14
000022  f7fffffe          BL       f_write
000026  b930              CBNZ     r0,|L30.54|
;;;4615   		&& (UINT)pb.idx == nw) return pb.nchr;
000028  9901              LDR      r1,[sp,#4]
00002a  9803              LDR      r0,[sp,#0xc]
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L30.54|
000030  9804              LDR      r0,[sp,#0x10]
                  |L30.50|
;;;4616   	return EOF;
;;;4617   }
000032  b015              ADD      sp,sp,#0x54
000034  bd00              POP      {pc}
                  |L30.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;4616
00003a  e7fa              B        |L30.50|
;;;4618   
                          ENDP


                          AREA ||i.f_puts||, CODE, READONLY, ALIGN=1

                  f_puts PROC
;;;4625   
;;;4626   int f_puts (
000000  b510              PUSH     {r4,lr}
;;;4627   	const TCHAR* str,	/* Pointer to the string to be output */
;;;4628   	FIL* fp				/* Pointer to the file object */
;;;4629   )
;;;4630   {
000002  b094              SUB      sp,sp,#0x50
000004  4604              MOV      r4,r0
;;;4631   	putbuff pb;
;;;4632   	UINT nw;
;;;4633   
;;;4634   
;;;4635   	pb.fp = fp;				/* Initialize output buffer */
000006  9101              STR      r1,[sp,#4]
;;;4636   	pb.nchr = pb.idx = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
00000c  9003              STR      r0,[sp,#0xc]
00000e  e003              B        |L31.24|
                  |L31.16|
;;;4637   
;;;4638   	while (*str)			/* Put the string */
;;;4639   		putc_bfd(&pb, *str++);
000010  1c64              ADDS     r4,r4,#1
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       putc_bfd
                  |L31.24|
000018  7821              LDRB     r1,[r4,#0]            ;4638
00001a  2900              CMP      r1,#0                 ;4638
00001c  d1f8              BNE      |L31.16|
;;;4640   
;;;4641   	if (   pb.idx >= 0		/* Flush buffered characters to the file */
00001e  9802              LDR      r0,[sp,#8]
000020  2800              CMP      r0,#0
000022  db0d              BLT      |L31.64|
;;;4642   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
000024  e9dd0201          LDRD     r0,r2,[sp,#4]
000028  466b              MOV      r3,sp
00002a  a904              ADD      r1,sp,#0x10
00002c  f7fffffe          BL       f_write
000030  b930              CBNZ     r0,|L31.64|
;;;4643   		&& (UINT)pb.idx == nw) return pb.nchr;
000032  9900              LDR      r1,[sp,#0]
000034  9802              LDR      r0,[sp,#8]
000036  4288              CMP      r0,r1
000038  d102              BNE      |L31.64|
00003a  9803              LDR      r0,[sp,#0xc]
                  |L31.60|
;;;4644   	return EOF;
;;;4645   }
00003c  b014              ADD      sp,sp,#0x50
00003e  bd10              POP      {r4,pc}
                  |L31.64|
000040  f04f30ff          MOV      r0,#0xffffffff        ;4644
000044  e7fa              B        |L31.60|
;;;4646   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2657   
;;;2658   FRESULT f_read (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2659   	FIL* fp, 		/* Pointer to the file object */
;;;2660   	void* buff,		/* Pointer to data buffer */
;;;2661   	UINT btr,		/* Number of bytes to read */
;;;2662   	UINT* br		/* Pointer to number of bytes read */
;;;2663   )
;;;2664   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;2665   	FRESULT res;
;;;2666   	DWORD clst, sect, remain;
;;;2667   	UINT rcnt, cc;
;;;2668   	BYTE csect, *rbuff = (BYTE*)buff;
;;;2669   
;;;2670   
;;;2671   	*br = 0;	/* Clear read byte counter */
00000c  2000              MOVS     r0,#0
00000e  f8c80000          STR      r0,[r8,#0]
;;;2672   
;;;2673   	res = validate(fp);							/* Check validity */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       validate
;;;2674   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d113              BNE      |L32.68|
;;;2675   	if (fp->err)								/* Check error */
00001c  f8940207          LDRB     r0,[r4,#0x207]
000020  2800              CMP      r0,#0
000022  d10f              BNE      |L32.68|
;;;2676   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2677   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
000024  f8940206          LDRB     r0,[r4,#0x206]
000028  07c0              LSLS     r0,r0,#31
00002a  d00a              BEQ      |L32.66|
;;;2678   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2679   	remain = fp->fsize - fp->fptr;
00002c  f8d41208          LDR      r1,[r4,#0x208]
000030  f8d4020c          LDR      r0,[r4,#0x20c]
000034  1a40              SUBS     r0,r0,r1
;;;2680   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
000036  4286              CMP      r6,r0
000038  d900              BLS      |L32.60|
00003a  4606              MOV      r6,r0
                  |L32.60|
;;;2681   
;;;2682   	for ( ;  btr;								/* Repeat until all data read */
;;;2683   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2684   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2685   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2686   			if (!csect) {						/* On the cluster boundary? */
;;;2687   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2688   					clst = fp->sclust;			/* Follow from the origin */
;;;2689   				} else {						/* Middle or end of the file */
;;;2690   #if _USE_FASTSEEK
;;;2691   					if (fp->cltbl)
;;;2692   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2693   					else
;;;2694   #endif
;;;2695   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2696   				}
;;;2697   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2698   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
00003c  f04f0901          MOV      r9,#1
000040  e0ae              B        |L32.416|
                  |L32.66|
000042  2007              MOVS     r0,#7                 ;2678
                  |L32.68|
;;;2699   				fp->clust = clst;				/* Update current cluster */
;;;2700   			}
;;;2701   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2702   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2703   			sect += csect;
;;;2704   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2705   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2706   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2707   					cc = fp->fs->csize - csect;
;;;2708   				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
;;;2709   					ABORT(fp->fs, FR_DISK_ERR);
;;;2710   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2711   #if _FS_TINY
;;;2712   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2713   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win.d8, SS(fp->fs));
;;;2714   #else
;;;2715   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2716   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf.d8, SS(fp->fs));
;;;2717   #endif
;;;2718   #endif
;;;2719   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2720   				continue;
;;;2721   			}
;;;2722   #if !_FS_TINY
;;;2723   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2724   #if !_FS_READONLY
;;;2725   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2726   					if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
;;;2727   						ABORT(fp->fs, FR_DISK_ERR);
;;;2728   					fp->flag &= ~FA__DIRTY;
;;;2729   				}
;;;2730   #endif
;;;2731   				if (disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2732   					ABORT(fp->fs, FR_DISK_ERR);
;;;2733   			}
;;;2734   #endif
;;;2735   			fp->dsect = sect;
;;;2736   		}
;;;2737   		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2738   		if (rcnt > btr) rcnt = btr;
;;;2739   #if _FS_TINY
;;;2740   		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
;;;2741   			ABORT(fp->fs, FR_DISK_ERR);
;;;2742   		mem_cpy(rbuff, &fp->fs->win.d8[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2743   #else
;;;2744   		mem_cpy(rbuff, &fp->buf.d8[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2745   #endif
;;;2746   	}
;;;2747   
;;;2748   	LEAVE_FF(fp->fs, FR_OK);
;;;2749   }
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L32.72|
000048  f8d41208          LDR      r1,[r4,#0x208]        ;2684
00004c  05c8              LSLS     r0,r1,#23             ;2684
00004e  d176              BNE      |L32.318|
000050  f8d40200          LDR      r0,[r4,#0x200]        ;2685
000054  f8902202          LDRB     r2,[r0,#0x202]        ;2685
000058  1e52              SUBS     r2,r2,#1              ;2685
00005a  ea022251          AND      r2,r2,r1,LSR #9       ;2685
00005e  f0020aff          AND      r10,r2,#0xff          ;2685
000062  f1ba0f00          CMP      r10,#0                ;2686
000066  d118              BNE      |L32.154|
000068  b131              CBZ      r1,|L32.120|
00006a  f8d42224          LDR      r2,[r4,#0x224]        ;2691
00006e  b132              CBZ      r2,|L32.126|
000070  4620              MOV      r0,r4                 ;2692
000072  f7fffffe          BL       clmt_clust
000076  e006              B        |L32.134|
                  |L32.120|
000078  f8d40210          LDR      r0,[r4,#0x210]        ;2688
00007c  e003              B        |L32.134|
                  |L32.126|
00007e  f8d41214          LDR      r1,[r4,#0x214]        ;2695
000082  f7fffffe          BL       get_fat
                  |L32.134|
000086  2802              CMP      r0,#2                 ;2697
000088  d203              BCS      |L32.146|
00008a  2002              MOVS     r0,#2                 ;2697
00008c  f8840207          STRB     r0,[r4,#0x207]        ;2697
000090  e7d8              B        |L32.68|
                  |L32.146|
000092  1c41              ADDS     r1,r0,#1              ;2698
000094  d022              BEQ      |L32.220|
000096  f8c40214          STR      r0,[r4,#0x214]        ;2699
                  |L32.154|
00009a  f8d41214          LDR      r1,[r4,#0x214]        ;2701
00009e  f8d40200          LDR      r0,[r4,#0x200]        ;2701
0000a2  f7fffffe          BL       clust2sect
0000a6  b1e8              CBZ      r0,|L32.228|
0000a8  eb000b0a          ADD      r11,r0,r10            ;2703
0000ac  0a75              LSRS     r5,r6,#9              ;2704
0000ae  b385              CBZ      r5,|L32.274|
0000b0  f8d40200          LDR      r0,[r4,#0x200]        ;2706
0000b4  eb0a0205          ADD      r2,r10,r5             ;2706
0000b8  f8901202          LDRB     r1,[r0,#0x202]        ;2706
0000bc  428a              CMP      r2,r1                 ;2706
0000be  d901              BLS      |L32.196|
0000c0  eba1050a          SUB      r5,r1,r10             ;2707
                  |L32.196|
0000c4  f8900201          LDRB     r0,[r0,#0x201]        ;2708
0000c8  462b              MOV      r3,r5                 ;2708
0000ca  465a              MOV      r2,r11                ;2708
0000cc  4639              MOV      r1,r7                 ;2708
0000ce  f7fffffe          BL       disk_read
0000d2  b158              CBZ      r0,|L32.236|
0000d4  f8849207          STRB     r9,[r4,#0x207]        ;2709
0000d8  2001              MOVS     r0,#1                 ;2709
0000da  e7b3              B        |L32.68|
                  |L32.220|
0000dc  f8849207          STRB     r9,[r4,#0x207]        ;2698
0000e0  2001              MOVS     r0,#1                 ;2698
0000e2  e7af              B        |L32.68|
                  |L32.228|
0000e4  2002              MOVS     r0,#2                 ;2702
0000e6  f8840207          STRB     r0,[r4,#0x207]        ;2702
0000ea  e7ab              B        |L32.68|
                  |L32.236|
0000ec  f8940206          LDRB     r0,[r4,#0x206]        ;2715
0000f0  0640              LSLS     r0,r0,#25             ;2715
0000f2  d50c              BPL      |L32.270|
0000f4  f8d40218          LDR      r0,[r4,#0x218]        ;2715
0000f8  eba0000b          SUB      r0,r0,r11             ;2715
0000fc  42a8              CMP      r0,r5                 ;2715
0000fe  d206              BCS      |L32.270|
000100  eb072040          ADD      r0,r7,r0,LSL #9       ;2716
000104  f44f7200          MOV      r2,#0x200             ;2716
000108  4621              MOV      r1,r4                 ;2716
00010a  f7fffffe          BL       mem_cpy
                  |L32.270|
00010e  026d              LSLS     r5,r5,#9              ;2719
000110  e03a              B        |L32.392|
                  |L32.274|
000112  e7ff              B        |L32.276|
                  |L32.276|
000114  f8d42218          LDR      r2,[r4,#0x218]        ;2723
000118  455a              CMP      r2,r11                ;2723
00011a  d025              BEQ      |L32.360|
00011c  f8940206          LDRB     r0,[r4,#0x206]        ;2725
000120  0640              LSLS     r0,r0,#25             ;2725
000122  d513              BPL      |L32.332|
000124  f8d40200          LDR      r0,[r4,#0x200]        ;2726
000128  2301              MOVS     r3,#1                 ;2726
00012a  4621              MOV      r1,r4                 ;2726
00012c  f8900201          LDRB     r0,[r0,#0x201]        ;2726
000130  f7fffffe          BL       disk_write
000134  b120              CBZ      r0,|L32.320|
000136  f8849207          STRB     r9,[r4,#0x207]        ;2727
00013a  2001              MOVS     r0,#1                 ;2727
00013c  e782              B        |L32.68|
                  |L32.318|
00013e  e015              B        |L32.364|
                  |L32.320|
000140  f8940206          LDRB     r0,[r4,#0x206]        ;2728
000144  f0200040          BIC      r0,r0,#0x40           ;2728
000148  f8840206          STRB     r0,[r4,#0x206]        ;2728
                  |L32.332|
00014c  f8d40200          LDR      r0,[r4,#0x200]        ;2731
000150  2301              MOVS     r3,#1                 ;2731
000152  465a              MOV      r2,r11                ;2731
000154  f8900201          LDRB     r0,[r0,#0x201]        ;2731
000158  4621              MOV      r1,r4                 ;2731
00015a  f7fffffe          BL       disk_read
00015e  b118              CBZ      r0,|L32.360|
000160  f8849207          STRB     r9,[r4,#0x207]        ;2732
000164  2001              MOVS     r0,#1                 ;2732
000166  e76d              B        |L32.68|
                  |L32.360|
000168  f8c4b218          STR      r11,[r4,#0x218]       ;2735
                  |L32.364|
00016c  f8b40208          LDRH     r0,[r4,#0x208]        ;2737
000170  f3c00008          UBFX     r0,r0,#0,#9           ;2737
000174  f5c07500          RSB      r5,r0,#0x200          ;2737
000178  42b5              CMP      r5,r6                 ;2738
00017a  d900              BLS      |L32.382|
00017c  4635              MOV      r5,r6                 ;2738
                  |L32.382|
00017e  1901              ADDS     r1,r0,r4              ;2744
000180  462a              MOV      r2,r5                 ;2744
000182  4638              MOV      r0,r7                 ;2744
000184  f7fffffe          BL       mem_cpy
                  |L32.392|
000188  442f              ADD      r7,r7,r5              ;2683
00018a  f8d40208          LDR      r0,[r4,#0x208]        ;2683
00018e  4428              ADD      r0,r0,r5              ;2683
000190  f8c40208          STR      r0,[r4,#0x208]        ;2683
000194  f8d80000          LDR      r0,[r8,#0]            ;2683
000198  4428              ADD      r0,r0,r5              ;2683
00019a  f8c80000          STR      r0,[r8,#0]            ;2683
00019e  1b76              SUBS     r6,r6,r5              ;2683
                  |L32.416|
0001a0  2e00              CMP      r6,#0                 ;2682
0001a2  f47faf51          BNE      |L32.72|
0001a6  2000              MOVS     r0,#0                 ;2748
0001a8  e74c              B        |L32.68|
;;;2750   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3347   
;;;3348   FRESULT f_readdir (
000000  b5fe              PUSH     {r1-r7,lr}
;;;3349   	DIR* dp,			/* Pointer to the open directory object */
;;;3350   	FILINFO* fno		/* Pointer to file information to return */
;;;3351   )
;;;3352   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;3353   	FRESULT res;
;;;3354   	DEFINE_NAMEBUF;
;;;3355   
;;;3356   
;;;3357   	res = validate(dp);						/* Check validity of the object */
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
;;;3358   	if (res == FR_OK) {
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L33.46|
;;;3359   		if (!fno) {
000010  b14e              CBZ      r6,|L33.38|
;;;3360   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
;;;3361   		} else {
;;;3362   			INIT_BUF(*dp);
000012  f8c4d218          STR      sp,[r4,#0x218]
;;;3363   			res = dir_read(dp, 0);			/* Read an item */
000016  2100              MOVS     r1,#0
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       dir_read
;;;3364   			if (res == FR_NO_FILE) {		/* Reached end of directory */
00001e  2500              MOVS     r5,#0
000020  2804              CMP      r0,#4
000022  d005              BEQ      |L33.48|
000024  e007              B        |L33.54|
                  |L33.38|
000026  2100              MOVS     r1,#0                 ;3360
000028  4620              MOV      r0,r4                 ;3360
00002a  f7fffffe          BL       dir_sdi
                  |L33.46|
;;;3365   				dp->sect = 0;
;;;3366   				res = FR_OK;
;;;3367   			}
;;;3368   			if (res == FR_OK) {				/* A valid entry is found */
;;;3369   				get_fileinfo(dp, fno);		/* Get the object information */
;;;3370   				res = dir_next(dp, 0);		/* Increment index for next */
;;;3371   				if (res == FR_NO_FILE) {
;;;3372   					dp->sect = 0;
;;;3373   					res = FR_OK;
;;;3374   				}
;;;3375   			}
;;;3376   			FREE_BUF();
;;;3377   		}
;;;3378   	}
;;;3379   
;;;3380   	LEAVE_FF(dp->fs, res);
;;;3381   }
00002e  bdfe              POP      {r1-r7,pc}
                  |L33.48|
000030  f8c45210          STR      r5,[r4,#0x210]        ;3365
000034  2000              MOVS     r0,#0                 ;3366
                  |L33.54|
000036  2800              CMP      r0,#0                 ;3368
000038  d1f9              BNE      |L33.46|
00003a  4631              MOV      r1,r6                 ;3369
00003c  4620              MOV      r0,r4                 ;3369
00003e  f7fffffe          BL       get_fileinfo
000042  2100              MOVS     r1,#0                 ;3370
000044  4620              MOV      r0,r4                 ;3370
000046  f7fffffe          BL       dir_next
00004a  2804              CMP      r0,#4                 ;3371
00004c  d1ef              BNE      |L33.46|
00004e  f8c45210          STR      r5,[r4,#0x210]        ;3372
000052  2000              MOVS     r0,#0                 ;3373
000054  bdfe              POP      {r1-r7,pc}
;;;3382   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3785   
;;;3786   FRESULT f_rename (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;3787   	const TCHAR* path_old,	/* Pointer to the object to be renamed */
;;;3788   	const TCHAR* path_new	/* Pointer to the new name */
;;;3789   )
;;;3790   {
000002  f5ad6d8d          SUB      sp,sp,#0x468
;;;3791   	FRESULT res;
;;;3792   	DIR djo, djn;
;;;3793   	BYTE buf[21], *dir;
;;;3794   	DWORD dw;
;;;3795   	DEFINE_NAMEBUF;
;;;3796   
;;;3797   
;;;3798   	/* Get logical drive number of the source object */
;;;3799   	res = find_volume(&djo.fs, &path_old, 1);
000006  2201              MOVS     r2,#1
000008  f50d618d          ADD      r1,sp,#0x468
00000c  f50d6089          ADD      r0,sp,#0x448
000010  f7fffffe          BL       find_volume
000014  4604              MOV      r4,r0
;;;3800   	if (res == FR_OK) {
000016  2c00              CMP      r4,#0
000018  d131              BNE      |L34.126|
;;;3801   		djn.fs = djo.fs;
00001a  f8dd0448          LDR      r0,[sp,#0x448]
00001e  908a              STR      r0,[sp,#0x228]
;;;3802   		INIT_BUF(djo);
000020  a801              ADD      r0,sp,#4
000022  f8cd0460          STR      r0,[sp,#0x460]
;;;3803   		res = follow_path(&djo, path_old);		/* Check old object */
000026  a892              ADD      r0,sp,#0x248
000028  f8dd1468          LDR      r1,[sp,#0x468]
00002c  f7fffffe          BL       follow_path
000030  4604              MOV      r4,r0
;;;3804   		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
;;;3805   			res = FR_INVALID_NAME;
;;;3806   #if _FS_LOCK
;;;3807   		if (res == FR_OK) res = chk_lock(&djo, 2);
000032  b924              CBNZ     r4,|L34.62|
000034  2102              MOVS     r1,#2
000036  a892              ADD      r0,sp,#0x248
000038  f7fffffe          BL       chk_lock
00003c  4604              MOV      r4,r0
                  |L34.62|
;;;3808   #endif
;;;3809   		if (res == FR_OK) {						/* Old object is found */
00003e  2c00              CMP      r4,#0
000040  d170              BNE      |L34.292|
;;;3810   			if (!djo.dir) {						/* Is root dir? */
000042  f8dd045c          LDR      r0,[sp,#0x45c]
000046  b1c8              CBZ      r0,|L34.124|
;;;3811   				res = FR_NO_FILE;
;;;3812   			} else {
;;;3813   				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about object except name */
000048  f8dd145c          LDR      r1,[sp,#0x45c]
00004c  2215              MOVS     r2,#0x15
00004e  310b              ADDS     r1,r1,#0xb
000050  a804              ADD      r0,sp,#0x10
000052  f7fffffe          BL       mem_cpy
;;;3814   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
000056  f44f7208          MOV      r2,#0x220
00005a  a992              ADD      r1,sp,#0x248
00005c  a80a              ADD      r0,sp,#0x28
00005e  f7fffffe          BL       mem_cpy
;;;3815   				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
000062  f20d406c          ADD      r0,sp,#0x46c
000066  f7fffffe          BL       get_ldnumber
00006a  2800              CMP      r0,#0
00006c  db08              BLT      |L34.128|
;;;3816   					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
00006e  a80a              ADD      r0,sp,#0x28
000070  f8dd146c          LDR      r1,[sp,#0x46c]
000074  f7fffffe          BL       follow_path
000078  4604              MOV      r4,r0
00007a  e002              B        |L34.130|
                  |L34.124|
00007c  2404              MOVS     r4,#4                 ;3811
                  |L34.126|
00007e  e051              B        |L34.292|
                  |L34.128|
;;;3817   				else
;;;3818   					res = FR_INVALID_DRIVE;
000080  240b              MOVS     r4,#0xb
                  |L34.130|
;;;3819   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
000082  b904              CBNZ     r4,|L34.134|
000084  2408              MOVS     r4,#8
                  |L34.134|
;;;3820   				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
000086  2c04              CMP      r4,#4
000088  d14c              BNE      |L34.292|
;;;3821   					res = dir_register(&djn);			/* Register the new entry */
00008a  a80a              ADD      r0,sp,#0x28
00008c  f7fffffe          BL       dir_register
000090  4604              MOV      r4,r0
;;;3822   					if (res == FR_OK) {
000092  bb7c              CBNZ     r4,|L34.244|
;;;3823   /* Start of critical section where any interruption can cause a cross-link */
;;;3824   						dir = djn.dir;					/* Copy information about object except name */
000094  9d8f              LDR      r5,[sp,#0x23c]
;;;3825   						mem_cpy(dir + 13, buf + 2, 19);
000096  2213              MOVS     r2,#0x13
000098  f10d0112          ADD      r1,sp,#0x12
00009c  f105000d          ADD      r0,r5,#0xd
0000a0  f7fffffe          BL       mem_cpy
;;;3826   						dir[DIR_Attr] = buf[0] | AM_ARC;
0000a4  f89d0010          LDRB     r0,[sp,#0x10]
0000a8  f0400020          ORR      r0,r0,#0x20
0000ac  72e8              STRB     r0,[r5,#0xb]
;;;3827   						djo.fs->wflag = 1;
0000ae  f8dd0448          LDR      r0,[sp,#0x448]
0000b2  2601              MOVS     r6,#1
0000b4  f8806204          STRB     r6,[r0,#0x204]
;;;3828   						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the sub-directory if needed */
0000b8  7ae8              LDRB     r0,[r5,#0xb]
0000ba  06c0              LSLS     r0,r0,#27
0000bc  d527              BPL      |L34.270|
0000be  998c              LDR      r1,[sp,#0x230]
0000c0  f8dd0450          LDR      r0,[sp,#0x450]
0000c4  4288              CMP      r0,r1
0000c6  d022              BEQ      |L34.270|
;;;3829   							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
0000c8  4629              MOV      r1,r5
0000ca  f8dd0448          LDR      r0,[sp,#0x448]
0000ce  f7fffffe          BL       ld_clust
0000d2  4601              MOV      r1,r0
0000d4  f8dd0448          LDR      r0,[sp,#0x448]
0000d8  f7fffffe          BL       clust2sect
0000dc  4601              MOV      r1,r0
;;;3830   							if (!dw) {
0000de  b151              CBZ      r1,|L34.246|
;;;3831   								res = FR_INT_ERR;
;;;3832   							} else {
;;;3833   								res = move_window(djo.fs, dw);
0000e0  f8dd0448          LDR      r0,[sp,#0x448]
0000e4  f7fffffe          BL       move_window
0000e8  4604              MOV      r4,r0
;;;3834   								dir = djo.fs->win.d8 + SZ_DIRE * 1;	/* Ptr to .. entry */
0000ea  f8dd0448          LDR      r0,[sp,#0x448]
0000ee  3020              ADDS     r0,r0,#0x20
;;;3835   								if (res == FR_OK && dir[1] == '.') {
0000f0  b11c              CBZ      r4,|L34.250|
0000f2  e00c              B        |L34.270|
                  |L34.244|
0000f4  e016              B        |L34.292|
                  |L34.246|
0000f6  2402              MOVS     r4,#2                 ;3831
0000f8  e009              B        |L34.270|
                  |L34.250|
0000fa  7841              LDRB     r1,[r0,#1]
0000fc  292e              CMP      r1,#0x2e
0000fe  d106              BNE      |L34.270|
;;;3836   									st_clust(dir, djn.sclust);
000100  998c              LDR      r1,[sp,#0x230]
000102  f7fffffe          BL       st_clust
;;;3837   									djo.fs->wflag = 1;
000106  f8dd0448          LDR      r0,[sp,#0x448]
00010a  f8806204          STRB     r6,[r0,#0x204]
                  |L34.270|
;;;3838   								}
;;;3839   							}
;;;3840   						}
;;;3841   						if (res == FR_OK) {
00010e  b94c              CBNZ     r4,|L34.292|
;;;3842   							res = dir_remove(&djo);		/* Remove old entry */
000110  a892              ADD      r0,sp,#0x248
000112  f7fffffe          BL       dir_remove
000116  4604              MOV      r4,r0
;;;3843   							if (res == FR_OK)
000118  b924              CBNZ     r4,|L34.292|
;;;3844   								res = sync_fs(djo.fs);
00011a  f8dd0448          LDR      r0,[sp,#0x448]
00011e  f7fffffe          BL       sync_fs
000122  4604              MOV      r4,r0
                  |L34.292|
;;;3845   						}
;;;3846   /* End of critical section */
;;;3847   					}
;;;3848   				}
;;;3849   			}
;;;3850   		}
;;;3851   		FREE_BUF();
;;;3852   	}
;;;3853   
;;;3854   	LEAVE_FF(djo.fs, res);
;;;3855   }
000124  f50d6d8e          ADD      sp,sp,#0x470
000128  4620              MOV      r0,r4                 ;3854
00012a  bd70              POP      {r4-r6,pc}
;;;3856   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3441   
;;;3442   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3443   	const TCHAR* path,	/* Pointer to the file path */
;;;3444   	FILINFO* fno		/* Pointer to file information to return */
;;;3445   )
;;;3446   {
000002  f5ad7d0b          SUB      sp,sp,#0x22c
000006  460d              MOV      r5,r1
;;;3447   	FRESULT res;
;;;3448   	DIR dj;
;;;3449   	DEFINE_NAMEBUF;
;;;3450   
;;;3451   
;;;3452   	/* Get logical drive number */
;;;3453   	res = find_volume(&dj.fs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  a98b              ADD      r1,sp,#0x22c
00000c  a883              ADD      r0,sp,#0x20c
00000e  f7fffffe          BL       find_volume
000012  4604              MOV      r4,r0
;;;3454   	if (res == FR_OK) {
000014  b984              CBNZ     r4,|L35.56|
;;;3455   		INIT_BUF(dj);
000016  f8cdd224          STR      sp,[sp,#0x224]
;;;3456   		res = follow_path(&dj, path);	/* Follow the file path */
00001a  a803              ADD      r0,sp,#0xc
00001c  998b              LDR      r1,[sp,#0x22c]
00001e  f7fffffe          BL       follow_path
000022  4604              MOV      r4,r0
;;;3457   		if (res == FR_OK) {				/* Follow completed */
000024  b944              CBNZ     r4,|L35.56|
;;;3458   			if (dj.dir) {		/* Found an object */
000026  9888              LDR      r0,[sp,#0x220]
000028  b128              CBZ      r0,|L35.54|
;;;3459   				if (fno) get_fileinfo(&dj, fno);
00002a  b12d              CBZ      r5,|L35.56|
00002c  4629              MOV      r1,r5
00002e  a803              ADD      r0,sp,#0xc
000030  f7fffffe          BL       get_fileinfo
000034  e000              B        |L35.56|
                  |L35.54|
;;;3460   			} else {			/* It is root directory */
;;;3461   				res = FR_INVALID_NAME;
000036  2406              MOVS     r4,#6
                  |L35.56|
;;;3462   			}
;;;3463   		}
;;;3464   		FREE_BUF();
;;;3465   	}
;;;3466   
;;;3467   	LEAVE_FF(dj.fs, res);
;;;3468   }
000038  f50d7d0d          ADD      sp,sp,#0x234
00003c  4620              MOV      r0,r4                 ;3467
00003e  bd30              POP      {r4,r5,pc}
;;;3469   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2880   
;;;2881   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2882   	FIL* fp		/* Pointer to the file object */
;;;2883   )
;;;2884   {
000002  4604              MOV      r4,r0
;;;2885   	FRESULT res;
;;;2886   	DWORD tm;
;;;2887   	BYTE *dir;
;;;2888   
;;;2889   
;;;2890   	res = validate(fp);					/* Check validity of the object */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
;;;2891   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d111              BNE      |L36.50|
;;;2892   		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
00000e  f8941206          LDRB     r1,[r4,#0x206]
000012  068a              LSLS     r2,r1,#26
000014  d50d              BPL      |L36.50|
;;;2893   			/* Write-back dirty buffer */
;;;2894   #if !_FS_TINY
;;;2895   			if (fp->flag & FA__DIRTY) {
000016  0648              LSLS     r0,r1,#25
000018  d512              BPL      |L36.64|
;;;2896   				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
00001a  f8d40200          LDR      r0,[r4,#0x200]
00001e  2301              MOVS     r3,#1
000020  4621              MOV      r1,r4
000022  f8900201          LDRB     r0,[r0,#0x201]
000026  f8d42218          LDR      r2,[r4,#0x218]
00002a  f7fffffe          BL       disk_write
00002e  b108              CBZ      r0,|L36.52|
;;;2897   					LEAVE_FF(fp->fs, FR_DISK_ERR);
000030  2001              MOVS     r0,#1
                  |L36.50|
;;;2898   				fp->flag &= ~FA__DIRTY;
;;;2899   			}
;;;2900   #endif
;;;2901   			/* Update the directory entry */
;;;2902   			res = move_window(fp->fs, fp->dir_sect);
;;;2903   			if (res == FR_OK) {
;;;2904   				dir = fp->dir_ptr;
;;;2905   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2906   				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
;;;2907   				st_clust(dir, fp->sclust);					/* Update start cluster */
;;;2908   				tm = GET_FATTIME();							/* Update updated time */
;;;2909   				ST_DWORD(dir + DIR_WrtTime, tm);
;;;2910   				ST_WORD(dir + DIR_LstAccDate, 0);
;;;2911   				fp->flag &= ~FA__WRITTEN;
;;;2912   				fp->fs->wflag = 1;
;;;2913   				res = sync_fs(fp->fs);
;;;2914   			}
;;;2915   		}
;;;2916   	}
;;;2917   
;;;2918   	LEAVE_FF(fp->fs, res);
;;;2919   }
000032  bd70              POP      {r4-r6,pc}
                  |L36.52|
000034  f8940206          LDRB     r0,[r4,#0x206]        ;2898
000038  f0200040          BIC      r0,r0,#0x40           ;2898
00003c  f8840206          STRB     r0,[r4,#0x206]        ;2898
                  |L36.64|
000040  f8d4121c          LDR      r1,[r4,#0x21c]        ;2902
000044  f8d40200          LDR      r0,[r4,#0x200]        ;2902
000048  f7fffffe          BL       move_window
00004c  2800              CMP      r0,#0                 ;2903
00004e  d1f0              BNE      |L36.50|
000050  f5047400          ADD      r4,r4,#0x200          ;2904
000054  6a25              LDR      r5,[r4,#0x20]         ;2904
000056  7ae8              LDRB     r0,[r5,#0xb]          ;2905
000058  f0400020          ORR      r0,r0,#0x20           ;2905
00005c  72e8              STRB     r0,[r5,#0xb]          ;2905
00005e  7b20              LDRB     r0,[r4,#0xc]          ;2906
000060  7728              STRB     r0,[r5,#0x1c]         ;2906
000062  89a0              LDRH     r0,[r4,#0xc]          ;2906
000064  0a00              LSRS     r0,r0,#8              ;2906
000066  7768              STRB     r0,[r5,#0x1d]         ;2906
000068  68e0              LDR      r0,[r4,#0xc]          ;2906
00006a  0c00              LSRS     r0,r0,#16             ;2906
00006c  77a8              STRB     r0,[r5,#0x1e]         ;2906
00006e  68e0              LDR      r0,[r4,#0xc]          ;2906
000070  0e00              LSRS     r0,r0,#24             ;2906
000072  77e8              STRB     r0,[r5,#0x1f]         ;2906
000074  4628              MOV      r0,r5                 ;2907
000076  6921              LDR      r1,[r4,#0x10]         ;2907
000078  f7fffffe          BL       st_clust
00007c  2000              MOVS     r0,#0                 ;2909
00007e  75a8              STRB     r0,[r5,#0x16]         ;2909
000080  75e8              STRB     r0,[r5,#0x17]         ;2909
000082  21a1              MOVS     r1,#0xa1              ;2909
000084  7629              STRB     r1,[r5,#0x18]         ;2909
000086  2146              MOVS     r1,#0x46              ;2909
000088  7669              STRB     r1,[r5,#0x19]         ;2909
00008a  74a8              STRB     r0,[r5,#0x12]         ;2910
00008c  74e8              STRB     r0,[r5,#0x13]         ;2910
00008e  79a0              LDRB     r0,[r4,#6]            ;2911
000090  f0200020          BIC      r0,r0,#0x20           ;2911
000094  71a0              STRB     r0,[r4,#6]            ;2911
000096  6821              LDR      r1,[r4,#0]            ;2912
000098  2001              MOVS     r0,#1                 ;2912
00009a  f8810204          STRB     r0,[r1,#0x204]        ;2912
00009e  6820              LDR      r0,[r4,#0]            ;2913
0000a0  e8bd4070          POP      {r4-r6,lr}            ;2913
0000a4  f7ffbffe          B.W      sync_fs
;;;2920   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3543   
;;;3544   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3545   	FIL* fp		/* Pointer to the file object */
;;;3546   )
;;;3547   {
000002  4604              MOV      r4,r0
;;;3548   	FRESULT res;
;;;3549   	DWORD ncl;
;;;3550   
;;;3551   
;;;3552   	res = validate(fp);						/* Check validity of the object */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
00000a  4605              MOV      r5,r0
;;;3553   	if (res == FR_OK) {
00000c  0028              MOVS     r0,r5
00000e  d109              BNE      |L37.36|
;;;3554   		if (fp->err) {						/* Check error */
000010  f8940207          LDRB     r0,[r4,#0x207]
000014  b108              CBZ      r0,|L37.26|
;;;3555   			res = (FRESULT)fp->err;
000016  4605              MOV      r5,r0
000018  e004              B        |L37.36|
                  |L37.26|
;;;3556   		} else {
;;;3557   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
00001a  f8940206          LDRB     r0,[r4,#0x206]
00001e  0780              LSLS     r0,r0,#30
000020  d400              BMI      |L37.36|
;;;3558   				res = FR_DENIED;
000022  2507              MOVS     r5,#7
                  |L37.36|
;;;3559   		}
;;;3560   	}
;;;3561   	if (res == FR_OK) {
000024  bbf5              CBNZ     r5,|L37.164|
;;;3562   		if (fp->fsize > fp->fptr) {
000026  f5047002          ADD      r0,r4,#0x208
00002a  c803              LDM      r0,{r0,r1}
00002c  4281              CMP      r1,r0
00002e  d951              BLS      |L37.212|
;;;3563   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
000030  f8c4020c          STR      r0,[r4,#0x20c]
;;;3564   			fp->flag |= FA__WRITTEN;
000034  f8941206          LDRB     r1,[r4,#0x206]
000038  f0410120          ORR      r1,r1,#0x20
00003c  f8841206          STRB     r1,[r4,#0x206]
;;;3565   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000040  b148              CBZ      r0,|L37.86|
;;;3566   				res = remove_chain(fp->fs, fp->sclust);
;;;3567   				fp->sclust = 0;
;;;3568   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3569   				ncl = get_fat(fp->fs, fp->clust);
000042  f8d41214          LDR      r1,[r4,#0x214]
000046  f8d40200          LDR      r0,[r4,#0x200]
00004a  f7fffffe          BL       get_fat
00004e  4606              MOV      r6,r0
;;;3570   				res = FR_OK;
;;;3571   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
000050  1c70              ADDS     r0,r6,#1
000052  d00b              BEQ      |L37.108|
000054  e00b              B        |L37.110|
                  |L37.86|
000056  f8d41210          LDR      r1,[r4,#0x210]        ;3566
00005a  f8d40200          LDR      r0,[r4,#0x200]        ;3566
00005e  f7fffffe          BL       remove_chain
000062  4605              MOV      r5,r0                 ;3566
000064  2000              MOVS     r0,#0                 ;3567
000066  f8c40210          STR      r0,[r4,#0x210]        ;3567
00006a  e019              B        |L37.160|
                  |L37.108|
00006c  2501              MOVS     r5,#1
                  |L37.110|
;;;3572   				if (ncl == 1) res = FR_INT_ERR;
00006e  2e01              CMP      r6,#1
000070  d100              BNE      |L37.116|
000072  2502              MOVS     r5,#2
                  |L37.116|
;;;3573   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
000074  b9a5              CBNZ     r5,|L37.160|
000076  f8d40200          LDR      r0,[r4,#0x200]
00007a  f8d01214          LDR      r1,[r0,#0x214]
00007e  42b1              CMP      r1,r6
000080  d90e              BLS      |L37.160|
;;;3574   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
000082  f06f4270          MVN      r2,#0xf0000000
000086  f8d41214          LDR      r1,[r4,#0x214]
00008a  f7fffffe          BL       put_fat
00008e  4605              MOV      r5,r0
;;;3575   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000090  0028              MOVS     r0,r5
000092  d105              BNE      |L37.160|
000094  4631              MOV      r1,r6
000096  f8d40200          LDR      r0,[r4,#0x200]
00009a  f7fffffe          BL       remove_chain
00009e  4605              MOV      r5,r0
                  |L37.160|
;;;3576   				}
;;;3577   			}
;;;3578   #if !_FS_TINY
;;;3579   			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
0000a0  b9c5              CBNZ     r5,|L37.212|
0000a2  e000              B        |L37.166|
                  |L37.164|
0000a4  e019              B        |L37.218|
                  |L37.166|
0000a6  f8940206          LDRB     r0,[r4,#0x206]
0000aa  0640              LSLS     r0,r0,#25
0000ac  d512              BPL      |L37.212|
;;;3580   				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
0000ae  f8d40200          LDR      r0,[r4,#0x200]
0000b2  2301              MOVS     r3,#1
0000b4  4621              MOV      r1,r4
0000b6  f8900201          LDRB     r0,[r0,#0x201]
0000ba  f8d42218          LDR      r2,[r4,#0x218]
0000be  f7fffffe          BL       disk_write
0000c2  b108              CBZ      r0,|L37.200|
;;;3581   					res = FR_DISK_ERR;
0000c4  2501              MOVS     r5,#1
0000c6  e005              B        |L37.212|
                  |L37.200|
;;;3582   				else
;;;3583   					fp->flag &= ~FA__DIRTY;
0000c8  f8940206          LDRB     r0,[r4,#0x206]
0000cc  f0200040          BIC      r0,r0,#0x40
0000d0  f8840206          STRB     r0,[r4,#0x206]
                  |L37.212|
;;;3584   			}
;;;3585   #endif
;;;3586   		}
;;;3587   		if (res != FR_OK) fp->err = (FRESULT)res;
0000d4  b10d              CBZ      r5,|L37.218|
0000d6  f8845207          STRB     r5,[r4,#0x207]
                  |L37.218|
;;;3588   	}
;;;3589   
;;;3590   	LEAVE_FF(fp->fs, res);
0000da  4628              MOV      r0,r5
;;;3591   }
0000dc  bd70              POP      {r4-r6,pc}
;;;3592   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3599   
;;;3600   FRESULT f_unlink (
000000  b571              PUSH     {r0,r4-r6,lr}
;;;3601   	const TCHAR* path		/* Pointer to the file or directory path */
;;;3602   )
;;;3603   {
000002  f2ad4d4c          SUB      sp,sp,#0x44c
;;;3604   	FRESULT res;
;;;3605   	DIR dj, sdj;
;;;3606   	BYTE *dir;
;;;3607   	DWORD dclst = 0;
000006  2500              MOVS     r5,#0
;;;3608   	DEFINE_NAMEBUF;
;;;3609   
;;;3610   
;;;3611   	/* Get logical drive number */
;;;3612   	res = find_volume(&dj.fs, &path, 1);
000008  2201              MOVS     r2,#1
00000a  f20d414c          ADD      r1,sp,#0x44c
00000e  f20d402c          ADD      r0,sp,#0x42c
000012  f7fffffe          BL       find_volume
000016  4604              MOV      r4,r0
;;;3613   	if (res == FR_OK) {
000018  2c00              CMP      r4,#0
00001a  d14f              BNE      |L38.188|
;;;3614   		INIT_BUF(dj);
00001c  f8cdd444          STR      sp,[sp,#0x444]
;;;3615   		res = follow_path(&dj, path);		/* Follow the file path */
000020  a88b              ADD      r0,sp,#0x22c
000022  f8dd144c          LDR      r1,[sp,#0x44c]
000026  f7fffffe          BL       follow_path
00002a  4604              MOV      r4,r0
;;;3616   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3617   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3618   #if _FS_LOCK
;;;3619   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
00002c  b924              CBNZ     r4,|L38.56|
00002e  2102              MOVS     r1,#2
000030  a88b              ADD      r0,sp,#0x22c
000032  f7fffffe          BL       chk_lock
000036  4604              MOV      r4,r0
                  |L38.56|
;;;3620   #endif
;;;3621   		if (res == FR_OK) {					/* The object is accessible */
000038  bbf4              CBNZ     r4,|L38.184|
;;;3622   			dir = dj.dir;
00003a  f8dd6440          LDR      r6,[sp,#0x440]
;;;3623   			if (!dir) {
00003e  b12e              CBZ      r6,|L38.76|
;;;3624   				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
;;;3625   			} else {
;;;3626   				if (dir[DIR_Attr] & AM_RDO)
000040  7af0              LDRB     r0,[r6,#0xb]
000042  07c0              LSLS     r0,r0,#31
000044  d000              BEQ      |L38.72|
;;;3627   					res = FR_DENIED;		/* Cannot remove R/O object */
000046  2407              MOVS     r4,#7
                  |L38.72|
;;;3628   			}
;;;3629   			if (res == FR_OK) {
000048  b114              CBZ      r4,|L38.80|
00004a  e022              B        |L38.146|
                  |L38.76|
00004c  2406              MOVS     r4,#6                 ;3624
00004e  e7fb              B        |L38.72|
                  |L38.80|
;;;3630   				dclst = ld_clust(dj.fs, dir);
000050  4631              MOV      r1,r6
000052  f8dd042c          LDR      r0,[sp,#0x42c]
000056  f7fffffe          BL       ld_clust
00005a  4605              MOV      r5,r0
;;;3631   				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
00005c  b1cd              CBZ      r5,|L38.146|
00005e  7af0              LDRB     r0,[r6,#0xb]
000060  06c0              LSLS     r0,r0,#27
000062  d516              BPL      |L38.146|
;;;3632   #if _FS_RPATH
;;;3633   					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
;;;3634   						res = FR_DENIED;
;;;3635   					} else
;;;3636   #endif
;;;3637   					{
;;;3638   						mem_cpy(&sdj, &dj, sizeof (DIR));	/* Open the sub-directory */
000064  f44f7208          MOV      r2,#0x220
000068  a98b              ADD      r1,sp,#0x22c
00006a  a803              ADD      r0,sp,#0xc
00006c  f7fffffe          BL       mem_cpy
;;;3639   						sdj.sclust = dclst;
000070  9585              STR      r5,[sp,#0x214]
;;;3640   						res = dir_sdi(&sdj, 2);
000072  2102              MOVS     r1,#2
000074  a803              ADD      r0,sp,#0xc
000076  f7fffffe          BL       dir_sdi
00007a  4604              MOV      r4,r0
;;;3641   						if (res == FR_OK) {
00007c  b94c              CBNZ     r4,|L38.146|
;;;3642   							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
00007e  2100              MOVS     r1,#0
000080  a803              ADD      r0,sp,#0xc
000082  f7fffffe          BL       dir_read
000086  4604              MOV      r4,r0
;;;3643   							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
000088  b904              CBNZ     r4,|L38.140|
00008a  2407              MOVS     r4,#7
                  |L38.140|
;;;3644   							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
00008c  2c04              CMP      r4,#4
00008e  d100              BNE      |L38.146|
000090  2400              MOVS     r4,#0
                  |L38.146|
;;;3645   						}
;;;3646   					}
;;;3647   				}
;;;3648   			}
;;;3649   			if (res == FR_OK) {
000092  b98c              CBNZ     r4,|L38.184|
;;;3650   				res = dir_remove(&dj);		/* Remove the directory entry */
000094  a88b              ADD      r0,sp,#0x22c
000096  f7fffffe          BL       dir_remove
00009a  4604              MOV      r4,r0
;;;3651   				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
00009c  b934              CBNZ     r4,|L38.172|
00009e  b12d              CBZ      r5,|L38.172|
;;;3652   					res = remove_chain(dj.fs, dclst);
0000a0  4629              MOV      r1,r5
0000a2  f8dd042c          LDR      r0,[sp,#0x42c]
0000a6  f7fffffe          BL       remove_chain
0000aa  4604              MOV      r4,r0
                  |L38.172|
;;;3653   				if (res == FR_OK) res = sync_fs(dj.fs);
0000ac  b924              CBNZ     r4,|L38.184|
0000ae  f8dd042c          LDR      r0,[sp,#0x42c]
0000b2  f7fffffe          BL       sync_fs
0000b6  e000              B        |L38.186|
                  |L38.184|
0000b8  e000              B        |L38.188|
                  |L38.186|
0000ba  4604              MOV      r4,r0
                  |L38.188|
;;;3654   			}
;;;3655   		}
;;;3656   		FREE_BUF();
;;;3657   	}
;;;3658   
;;;3659   	LEAVE_FF(dj.fs, res);
;;;3660   }
0000bc  f50d6d8a          ADD      sp,sp,#0x450
0000c0  4620              MOV      r0,r4                 ;3659
0000c2  bd70              POP      {r4-r6,pc}
;;;3661   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3863   
;;;3864   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3865   	const TCHAR* path,	/* Pointer to the file/directory name */
;;;3866   	const FILINFO* fno	/* Pointer to the time stamp to be set */
;;;3867   )
;;;3868   {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  460c              MOV      r4,r1
;;;3869   	FRESULT res;
;;;3870   	DIR dj;
;;;3871   	BYTE *dir;
;;;3872   	DEFINE_NAMEBUF;
;;;3873   
;;;3874   
;;;3875   	/* Get logical drive number */
;;;3876   	res = find_volume(&dj.fs, &path, 1);
000008  2201              MOVS     r2,#1
00000a  a98c              ADD      r1,sp,#0x230
00000c  a884              ADD      r0,sp,#0x210
00000e  f7fffffe          BL       find_volume
;;;3877   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d11a              BNE      |L39.76|
;;;3878   		INIT_BUF(dj);
000016  a801              ADD      r0,sp,#4
000018  908a              STR      r0,[sp,#0x228]
;;;3879   		res = follow_path(&dj, path);	/* Follow the file path */
00001a  a804              ADD      r0,sp,#0x10
00001c  998c              LDR      r1,[sp,#0x230]
00001e  f7fffffe          BL       follow_path
;;;3880   		FREE_BUF();
;;;3881   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3882   			res = FR_INVALID_NAME;
;;;3883   		if (res == FR_OK) {
000022  2800              CMP      r0,#0
000024  d112              BNE      |L39.76|
;;;3884   			dir = dj.dir;
000026  9889              LDR      r0,[sp,#0x224]
;;;3885   			if (!dir) {					/* Root directory */
000028  b198              CBZ      r0,|L39.82|
;;;3886   				res = FR_INVALID_NAME;
;;;3887   			} else {					/* File or sub-directory */
;;;3888   				ST_WORD(dir + DIR_WrtTime, fno->ftime);
00002a  79a1              LDRB     r1,[r4,#6]
00002c  7581              STRB     r1,[r0,#0x16]
00002e  88e1              LDRH     r1,[r4,#6]
000030  0a09              LSRS     r1,r1,#8
000032  75c1              STRB     r1,[r0,#0x17]
;;;3889   				ST_WORD(dir + DIR_WrtDate, fno->fdate);
000034  7921              LDRB     r1,[r4,#4]
000036  7601              STRB     r1,[r0,#0x18]
000038  88a1              LDRH     r1,[r4,#4]
00003a  0a09              LSRS     r1,r1,#8
00003c  7641              STRB     r1,[r0,#0x19]
;;;3890   				dj.fs->wflag = 1;
00003e  9984              LDR      r1,[sp,#0x210]
000040  2001              MOVS     r0,#1
000042  f8810204          STRB     r0,[r1,#0x204]
;;;3891   				res = sync_fs(dj.fs);
000046  9884              LDR      r0,[sp,#0x210]
000048  f7fffffe          BL       sync_fs
                  |L39.76|
;;;3892   			}
;;;3893   		}
;;;3894   	}
;;;3895   
;;;3896   	LEAVE_FF(dj.fs, res);
;;;3897   }
00004c  f50d7d0e          ADD      sp,sp,#0x238
000050  bd10              POP      {r4,pc}
                  |L39.82|
000052  2006              MOVS     r0,#6                 ;3886
000054  e7fa              B        |L39.76|
;;;3898   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2758   
;;;2759   FRESULT f_write (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2760   	FIL* fp,			/* Pointer to the file object */
;;;2761   	const void *buff,	/* Pointer to the data to be written */
;;;2762   	UINT btw,			/* Number of bytes to write */
;;;2763   	UINT* bw			/* Pointer to number of bytes written */
;;;2764   )
;;;2765   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;2766   	FRESULT res;
;;;2767   	DWORD clst, sect;
;;;2768   	UINT wcnt, cc;
;;;2769   	const BYTE *wbuff = (const BYTE*)buff;
;;;2770   	BYTE csect;
;;;2771   
;;;2772   
;;;2773   	*bw = 0;	/* Clear write byte counter */
00000c  2000              MOVS     r0,#0
00000e  f8c80000          STR      r0,[r8,#0]
;;;2774   
;;;2775   	res = validate(fp);						/* Check validity */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       validate
;;;2776   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d108              BNE      |L40.46|
;;;2777   	if (fp->err)							/* Check error */
00001c  f8940207          LDRB     r0,[r4,#0x207]
000020  2800              CMP      r0,#0
000022  d104              BNE      |L40.46|
;;;2778   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2779   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
000024  f8940206          LDRB     r0,[r4,#0x206]
000028  0780              LSLS     r0,r0,#30
00002a  d402              BMI      |L40.50|
;;;2780   		LEAVE_FF(fp->fs, FR_DENIED);
00002c  2007              MOVS     r0,#7
                  |L40.46|
;;;2781   	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
;;;2782   
;;;2783   	for ( ;  btw;							/* Repeat until all data written */
;;;2784   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2785   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2786   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2787   			if (!csect) {					/* On the cluster boundary? */
;;;2788   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2789   					clst = fp->sclust;		/* Follow from the origin */
;;;2790   					if (clst == 0)			/* When no cluster is allocated, */
;;;2791   						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2792   				} else {					/* Middle or end of the file */
;;;2793   #if _USE_FASTSEEK
;;;2794   					if (fp->cltbl)
;;;2795   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2796   					else
;;;2797   #endif
;;;2798   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2799   				}
;;;2800   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2801   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2802   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2803   				fp->clust = clst;			/* Update current cluster */
;;;2804   				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
;;;2805   			}
;;;2806   #if _FS_TINY
;;;2807   			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
;;;2808   				ABORT(fp->fs, FR_DISK_ERR);
;;;2809   #else
;;;2810   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2811   				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
;;;2812   					ABORT(fp->fs, FR_DISK_ERR);
;;;2813   				fp->flag &= ~FA__DIRTY;
;;;2814   			}
;;;2815   #endif
;;;2816   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2817   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2818   			sect += csect;
;;;2819   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2820   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2821   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2822   					cc = fp->fs->csize - csect;
;;;2823   				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
;;;2824   					ABORT(fp->fs, FR_DISK_ERR);
;;;2825   #if _FS_MINIMIZE <= 2
;;;2826   #if _FS_TINY
;;;2827   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2828   					mem_cpy(fp->fs->win.d8, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2829   					fp->fs->wflag = 0;
;;;2830   				}
;;;2831   #else
;;;2832   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2833   					mem_cpy(fp->buf.d8, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2834   					fp->flag &= ~FA__DIRTY;
;;;2835   				}
;;;2836   #endif
;;;2837   #endif
;;;2838   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2839   				continue;
;;;2840   			}
;;;2841   #if _FS_TINY
;;;2842   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2843   				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
;;;2844   				fp->fs->winsect = sect;
;;;2845   			}
;;;2846   #else
;;;2847   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2848   				if (fp->fptr < fp->fsize &&
;;;2849   					disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)
;;;2850   						ABORT(fp->fs, FR_DISK_ERR);
;;;2851   			}
;;;2852   #endif
;;;2853   			fp->dsect = sect;
;;;2854   		}
;;;2855   		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2856   		if (wcnt > btw) wcnt = btw;
;;;2857   #if _FS_TINY
;;;2858   		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
;;;2859   			ABORT(fp->fs, FR_DISK_ERR);
;;;2860   		mem_cpy(&fp->fs->win.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2861   		fp->fs->wflag = 1;
;;;2862   #else
;;;2863   		mem_cpy(&fp->buf.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2864   		fp->flag |= FA__DIRTY;
;;;2865   #endif
;;;2866   	}
;;;2867   
;;;2868   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2869   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2870   
;;;2871   	LEAVE_FF(fp->fs, FR_OK);
;;;2872   }
00002e  e8bd9ff0          POP      {r4-r12,pc}
                  |L40.50|
000032  f8d40208          LDR      r0,[r4,#0x208]        ;2781
000036  1981              ADDS     r1,r0,r6              ;2781
000038  d300              BCC      |L40.60|
00003a  2600              MOVS     r6,#0                 ;2781
                  |L40.60|
00003c  f04f0901          MOV      r9,#1                 ;2767
000040  e0c9              B        |L40.470|
                  |L40.66|
000042  f8d41208          LDR      r1,[r4,#0x208]        ;2785
000046  05c8              LSLS     r0,r1,#23             ;2785
000048  d170              BNE      |L40.300|
00004a  f8d42200          LDR      r2,[r4,#0x200]        ;2786
00004e  f8920202          LDRB     r0,[r2,#0x202]        ;2786
000052  1e40              SUBS     r0,r0,#1              ;2786
000054  ea002051          AND      r0,r0,r1,LSR #9       ;2786
000058  f0000aff          AND      r10,r0,#0xff          ;2786
00005c  f1ba0f00          CMP      r10,#0                ;2787
000060  d12a              BNE      |L40.184|
000062  b131              CBZ      r1,|L40.114|
000064  f8d40224          LDR      r0,[r4,#0x224]        ;2794
000068  b158              CBZ      r0,|L40.130|
00006a  4620              MOV      r0,r4                 ;2795
00006c  f7fffffe          BL       clmt_clust
000070  e00c              B        |L40.140|
                  |L40.114|
000072  f8d40210          LDR      r0,[r4,#0x210]        ;2789
000076  b948              CBNZ     r0,|L40.140|
000078  2100              MOVS     r1,#0                 ;2791
00007a  4610              MOV      r0,r2                 ;2791
00007c  f7fffffe          BL       create_chain
000080  e004              B        |L40.140|
                  |L40.130|
000082  4610              MOV      r0,r2                 ;2798
000084  f8d41214          LDR      r1,[r4,#0x214]        ;2798
000088  f7fffffe          BL       create_chain
                  |L40.140|
00008c  2800              CMP      r0,#0                 ;2800
00008e  d068              BEQ      |L40.354|
000090  2801              CMP      r0,#1                 ;2801
000092  d007              BEQ      |L40.164|
000094  1c41              ADDS     r1,r0,#1              ;2802
000096  d009              BEQ      |L40.172|
000098  f8c40214          STR      r0,[r4,#0x214]        ;2803
00009c  f8d41210          LDR      r1,[r4,#0x210]        ;2804
0000a0  b141              CBZ      r1,|L40.180|
0000a2  e009              B        |L40.184|
                  |L40.164|
0000a4  2002              MOVS     r0,#2                 ;2801
0000a6  f8840207          STRB     r0,[r4,#0x207]        ;2801
0000aa  e7c0              B        |L40.46|
                  |L40.172|
0000ac  f8849207          STRB     r9,[r4,#0x207]        ;2802
0000b0  2001              MOVS     r0,#1                 ;2802
0000b2  e7bc              B        |L40.46|
                  |L40.180|
0000b4  f8c40210          STR      r0,[r4,#0x210]        ;2804
                  |L40.184|
0000b8  f8940206          LDRB     r0,[r4,#0x206]        ;2810
0000bc  0640              LSLS     r0,r0,#25             ;2810
0000be  d514              BPL      |L40.234|
0000c0  f8d40200          LDR      r0,[r4,#0x200]        ;2811
0000c4  2301              MOVS     r3,#1                 ;2811
0000c6  4621              MOV      r1,r4                 ;2811
0000c8  f8900201          LDRB     r0,[r0,#0x201]        ;2811
0000cc  f8d42218          LDR      r2,[r4,#0x218]        ;2811
0000d0  f7fffffe          BL       disk_write
0000d4  b118              CBZ      r0,|L40.222|
0000d6  f8849207          STRB     r9,[r4,#0x207]        ;2812
0000da  2001              MOVS     r0,#1                 ;2812
0000dc  e7a7              B        |L40.46|
                  |L40.222|
0000de  f8940206          LDRB     r0,[r4,#0x206]        ;2813
0000e2  f0200040          BIC      r0,r0,#0x40           ;2813
0000e6  f8840206          STRB     r0,[r4,#0x206]        ;2813
                  |L40.234|
0000ea  f8d41214          LDR      r1,[r4,#0x214]        ;2816
0000ee  f8d40200          LDR      r0,[r4,#0x200]        ;2816
0000f2  f7fffffe          BL       clust2sect
0000f6  b1d0              CBZ      r0,|L40.302|
0000f8  eb000b0a          ADD      r11,r0,r10            ;2818
0000fc  0a75              LSRS     r5,r6,#9              ;2819
0000fe  b37d              CBZ      r5,|L40.352|
000100  f8d41200          LDR      r1,[r4,#0x200]        ;2821
000104  eb0a0205          ADD      r2,r10,r5             ;2821
000108  f8910202          LDRB     r0,[r1,#0x202]        ;2821
00010c  4282              CMP      r2,r0                 ;2821
00010e  d901              BLS      |L40.276|
000110  eba0050a          SUB      r5,r0,r10             ;2822
                  |L40.276|
000114  f8910201          LDRB     r0,[r1,#0x201]        ;2823
000118  462b              MOV      r3,r5                 ;2823
00011a  465a              MOV      r2,r11                ;2823
00011c  4639              MOV      r1,r7                 ;2823
00011e  f7fffffe          BL       disk_write
000122  b140              CBZ      r0,|L40.310|
000124  f8849207          STRB     r9,[r4,#0x207]        ;2824
000128  2001              MOVS     r0,#1                 ;2824
00012a  e780              B        |L40.46|
                  |L40.300|
00012c  e033              B        |L40.406|
                  |L40.302|
00012e  2002              MOVS     r0,#2                 ;2817
000130  f8840207          STRB     r0,[r4,#0x207]        ;2817
000134  e77b              B        |L40.46|
                  |L40.310|
000136  f8d40218          LDR      r0,[r4,#0x218]        ;2832
00013a  eba0000b          SUB      r0,r0,r11             ;2832
00013e  42a8              CMP      r0,r5                 ;2832
000140  d20c              BCS      |L40.348|
000142  eb072140          ADD      r1,r7,r0,LSL #9       ;2833
000146  f44f7200          MOV      r2,#0x200             ;2833
00014a  4620              MOV      r0,r4                 ;2833
00014c  f7fffffe          BL       mem_cpy
000150  f8940206          LDRB     r0,[r4,#0x206]        ;2834
000154  f0200040          BIC      r0,r0,#0x40           ;2834
000158  f8840206          STRB     r0,[r4,#0x206]        ;2834
                  |L40.348|
00015c  026d              LSLS     r5,r5,#9              ;2838
00015e  e02e              B        |L40.446|
                  |L40.352|
000160  e000              B        |L40.356|
                  |L40.354|
000162  e03b              B        |L40.476|
                  |L40.356|
000164  f8d40218          LDR      r0,[r4,#0x218]        ;2847
000168  4558              CMP      r0,r11                ;2847
00016a  d012              BEQ      |L40.402|
00016c  f5047002          ADD      r0,r4,#0x208          ;2848
000170  c803              LDM      r0,{r0,r1}            ;2848
000172  4288              CMP      r0,r1                 ;2848
000174  d20d              BCS      |L40.402|
000176  f8d40200          LDR      r0,[r4,#0x200]        ;2849
00017a  2301              MOVS     r3,#1                 ;2849
00017c  465a              MOV      r2,r11                ;2849
00017e  f8900201          LDRB     r0,[r0,#0x201]        ;2849
000182  4621              MOV      r1,r4                 ;2849
000184  f7fffffe          BL       disk_read
000188  b118              CBZ      r0,|L40.402|
00018a  f8849207          STRB     r9,[r4,#0x207]        ;2850
00018e  2001              MOVS     r0,#1                 ;2850
000190  e74d              B        |L40.46|
                  |L40.402|
000192  f8c4b218          STR      r11,[r4,#0x218]       ;2853
                  |L40.406|
000196  f8b40208          LDRH     r0,[r4,#0x208]        ;2855
00019a  f3c00008          UBFX     r0,r0,#0,#9           ;2855
00019e  f5c07500          RSB      r5,r0,#0x200          ;2855
0001a2  42b5              CMP      r5,r6                 ;2856
0001a4  d900              BLS      |L40.424|
0001a6  4635              MOV      r5,r6                 ;2856
                  |L40.424|
0001a8  4420              ADD      r0,r0,r4              ;2863
0001aa  462a              MOV      r2,r5                 ;2863
0001ac  4639              MOV      r1,r7                 ;2863
0001ae  f7fffffe          BL       mem_cpy
0001b2  f8940206          LDRB     r0,[r4,#0x206]        ;2864
0001b6  f0400040          ORR      r0,r0,#0x40           ;2864
0001ba  f8840206          STRB     r0,[r4,#0x206]        ;2864
                  |L40.446|
0001be  442f              ADD      r7,r7,r5              ;2784
0001c0  f8d40208          LDR      r0,[r4,#0x208]        ;2784
0001c4  4428              ADD      r0,r0,r5              ;2784
0001c6  f8c40208          STR      r0,[r4,#0x208]        ;2784
0001ca  f8d80000          LDR      r0,[r8,#0]            ;2784
0001ce  4428              ADD      r0,r0,r5              ;2784
0001d0  f8c80000          STR      r0,[r8,#0]            ;2784
0001d4  1b76              SUBS     r6,r6,r5              ;2784
                  |L40.470|
0001d6  2e00              CMP      r6,#0                 ;2783
0001d8  f47faf33          BNE      |L40.66|
                  |L40.476|
0001dc  f5047002          ADD      r0,r4,#0x208          ;2868
0001e0  c803              LDM      r0,{r0,r1}            ;2868
0001e2  4288              CMP      r0,r1                 ;2868
0001e4  d901              BLS      |L40.490|
0001e6  f8c4020c          STR      r0,[r4,#0x20c]        ;2868
                  |L40.490|
0001ea  f8940206          LDRB     r0,[r4,#0x206]        ;2869
0001ee  f0400020          ORR      r0,r0,#0x20           ;2869
0001f2  f8840206          STRB     r0,[r4,#0x206]        ;2869
0001f6  2000              MOVS     r0,#0                 ;2871
0001f8  e719              B        |L40.46|
;;;2873   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2275   static
;;;2276   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;2277   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2278   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2279   	BYTE wmode			/* !=0: Check write protection for write access */
;;;2280   )
;;;2281   {
000004  4680              MOV      r8,r0
000006  4608              MOV      r0,r1
000008  4616              MOV      r6,r2
;;;2282   	BYTE fmt, *pt;
;;;2283   	int vol;
;;;2284   	DSTATUS stat;
;;;2285   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
;;;2286   	WORD nrsv;
;;;2287   	FATFS *fs;
;;;2288   	UINT i;
;;;2289   
;;;2290   
;;;2291   	/* Get logical drive number from the path name */
;;;2292   	*rfs = 0;
00000a  2700              MOVS     r7,#0
00000c  f8c87000          STR      r7,[r8,#0]
;;;2293   	vol = get_ldnumber(path);
000010  f7fffffe          BL       get_ldnumber
000014  4605              MOV      r5,r0
;;;2294   	if (vol < 0) return FR_INVALID_DRIVE;
000016  0028              MOVS     r0,r5
000018  d503              BPL      |L41.34|
00001a  200b              MOVS     r0,#0xb
                  |L41.28|
;;;2295   
;;;2296   	/* Check if the file system object is valid or not */
;;;2297   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;2298   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2299   
;;;2300   	ENTER_FF(fs);						/* Lock the volume */
;;;2301   	*rfs = fs;							/* Return pointer to the file system object */
;;;2302   
;;;2303   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2304   		stat = disk_status(fs->drv);
;;;2305   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;2306   			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2307   				return FR_WRITE_PROTECTED;
;;;2308   			return FR_OK;				/* The file system object is valid */
;;;2309   		}
;;;2310   	}
;;;2311   
;;;2312   	/* The file system object is not valid. */
;;;2313   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2314   
;;;2315   	fs->fs_type = 0;					/* Clear the file system object */
;;;2316   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2317   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2318   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2319   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2320   	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2321   		return FR_WRITE_PROTECTED;
;;;2322   #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
;;;2323   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
;;;2324   		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
;;;2325   #endif
;;;2326   	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;;;2327   	bsect = 0;
;;;2328   	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
;;;2329   	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
;;;2330   		for (i = 0; i < 4; i++) {			/* Get partition offset */
;;;2331   			pt = fs->win.d8 + MBR_Table + i * SZ_PTE;
;;;2332   			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
;;;2333   		}
;;;2334   		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;;;2335   		if (i) i--;
;;;2336   		do {								/* Find an FAT volume */
;;;2337   			bsect = br[i];
;;;2338   			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
;;;2339   		} while (!LD2PT(vol) && fmt && ++i < 4);
;;;2340   	}
;;;2341   	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;2342   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2343   
;;;2344   	/* An FAT volume is found. Following code initializes the file system object */
;;;2345   
;;;2346   	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2347   		return FR_NO_FILESYSTEM;
;;;2348   
;;;2349   	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
;;;2350   	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
;;;2351   	fs->fsize = fasize;
;;;2352   
;;;2353   	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
;;;2354   	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
;;;2355   		return FR_NO_FILESYSTEM;
;;;2356   	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;;;2357   
;;;2358   	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
;;;2359   	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
;;;2360   		return FR_NO_FILESYSTEM;
;;;2361   
;;;2362   	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
;;;2363   	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
;;;2364   		return FR_NO_FILESYSTEM;
;;;2365   
;;;2366   	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
;;;2367   	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
;;;2368   
;;;2369   	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
;;;2370   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
;;;2371   
;;;2372   	/* Determine the FAT sub type */
;;;2373   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
;;;2374   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2375   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2376   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2377   	fmt = FS_FAT12;
;;;2378   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2379   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2380   
;;;2381   	/* Boundaries and Limits */
;;;2382   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2383   	fs->volbase = bsect;								/* Volume start sector */
;;;2384   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2385   	fs->database = bsect + sysect;						/* Data start sector */
;;;2386   	if (fmt == FS_FAT32) {
;;;2387   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2388   		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
;;;2389   		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
;;;2390   	} else {
;;;2391   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2392   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2393   		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
;;;2394   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2395   	}
;;;2396   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
;;;2397   		return FR_NO_FILESYSTEM;
;;;2398   
;;;2399   #if !_FS_READONLY
;;;2400   	/* Initialize cluster allocation information */
;;;2401   	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
;;;2402   
;;;2403   	/* Get fsinfo if available */
;;;2404   	fs->fsi_flag = 0x80;
;;;2405   #if (_FS_NOFSINFO & 3) != 3
;;;2406   	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
;;;2407   		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
;;;2408   		&& move_window(fs, bsect + 1) == FR_OK)
;;;2409   	{
;;;2410   		fs->fsi_flag = 0;
;;;2411   		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;2412   			&& LD_DWORD(fs->win.d8 + FSI_LeadSig) == 0x41615252
;;;2413   			&& LD_DWORD(fs->win.d8 + FSI_StrucSig) == 0x61417272)
;;;2414   		{
;;;2415   #if (_FS_NOFSINFO & 1) == 0
;;;2416   			fs->free_clust = LD_DWORD(fs->win.d8 + FSI_Free_Count);
;;;2417   #endif
;;;2418   #if (_FS_NOFSINFO & 2) == 0
;;;2419   			fs->last_clust = LD_DWORD(fs->win.d8 + FSI_Nxt_Free);
;;;2420   #endif
;;;2421   		}
;;;2422   	}
;;;2423   #endif
;;;2424   #endif
;;;2425   	fs->fs_type = fmt;	/* FAT sub-type */
;;;2426   	fs->id = ++Fsid;	/* File system mount ID */
;;;2427   #if _FS_RPATH
;;;2428   	fs->cdir = 0;		/* Set current directory to root */
;;;2429   #endif
;;;2430   #if _FS_LOCK			/* Clear file lock semaphores */
;;;2431   	clear_lock(fs);
;;;2432   #endif
;;;2433   
;;;2434   	return FR_OK;
;;;2435   }
00001c  b004              ADD      sp,sp,#0x10
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L41.34|
000022  48ba              LDR      r0,|L41.780|
000024  f8504025          LDR      r4,[r0,r5,LSL #2]     ;2297
000028  b1ac              CBZ      r4,|L41.86|
00002a  f8c84000          STR      r4,[r8,#0]            ;2301
00002e  f8940200          LDRB     r0,[r4,#0x200]        ;2303
000032  b128              CBZ      r0,|L41.64|
000034  f8940201          LDRB     r0,[r4,#0x201]        ;2304
000038  f7fffffe          BL       disk_status
00003c  07c1              LSLS     r1,r0,#31             ;2305
00003e  d00c              BEQ      |L41.90|
                  |L41.64|
000040  f8847200          STRB     r7,[r4,#0x200]        ;2315
000044  b2e8              UXTB     r0,r5                 ;2316
000046  f8840201          STRB     r0,[r4,#0x201]        ;2316
00004a  f7fffffe          BL       disk_initialize
00004e  07c1              LSLS     r1,r0,#31             ;2318
000050  d00a              BEQ      |L41.104|
000052  2003              MOVS     r0,#3                 ;2319
000054  e7e2              B        |L41.28|
                  |L41.86|
000056  200c              MOVS     r0,#0xc               ;2298
000058  e7e0              B        |L41.28|
                  |L41.90|
00005a  b11e              CBZ      r6,|L41.100|
00005c  0740              LSLS     r0,r0,#29             ;2306
00005e  d501              BPL      |L41.100|
000060  200a              MOVS     r0,#0xa               ;2307
000062  e7db              B        |L41.28|
                  |L41.100|
000064  2000              MOVS     r0,#0                 ;2308
000066  e7d9              B        |L41.28|
                  |L41.104|
000068  b11e              CBZ      r6,|L41.114|
00006a  0740              LSLS     r0,r0,#29             ;2320
00006c  d501              BPL      |L41.114|
00006e  200a              MOVS     r0,#0xa               ;2321
000070  e7d4              B        |L41.28|
                  |L41.114|
000072  2500              MOVS     r5,#0                 ;2327
000074  4629              MOV      r1,r5                 ;2328
000076  4620              MOV      r0,r4                 ;2328
000078  f7fffffe          BL       check_fs
00007c  2801              CMP      r0,#1                 ;2329
00007e  d126              BNE      |L41.206|
000080  2100              MOVS     r1,#0                 ;2330
000082  46e8              MOV      r8,sp                 ;2285
                  |L41.132|
000084  eb041001          ADD      r0,r4,r1,LSL #4       ;2331
000088  f50070df          ADD      r0,r0,#0x1be          ;2331
00008c  7902              LDRB     r2,[r0,#4]            ;2332
00008e  b152              CBZ      r2,|L41.166|
000090  7a02              LDRB     r2,[r0,#8]            ;2332
000092  7ac3              LDRB     r3,[r0,#0xb]          ;2332
000094  ea426203          ORR      r2,r2,r3,LSL #24      ;2332
000098  7a83              LDRB     r3,[r0,#0xa]          ;2332
00009a  7a40              LDRB     r0,[r0,#9]            ;2332
00009c  041b              LSLS     r3,r3,#16             ;2332
00009e  ea432000          ORR      r0,r3,r0,LSL #8       ;2332
0000a2  4302              ORRS     r2,r2,r0              ;2332
0000a4  e000              B        |L41.168|
                  |L41.166|
0000a6  2200              MOVS     r2,#0                 ;2332
                  |L41.168|
0000a8  f8482021          STR      r2,[r8,r1,LSL #2]     ;2332
0000ac  1c49              ADDS     r1,r1,#1              ;2330
0000ae  2904              CMP      r1,#4                 ;2330
0000b0  d3e8              BCC      |L41.132|
0000b2  2600              MOVS     r6,#0                 ;2334
                  |L41.180|
0000b4  f8585026          LDR      r5,[r8,r6,LSL #2]     ;2337
0000b8  b125              CBZ      r5,|L41.196|
0000ba  4629              MOV      r1,r5                 ;2338
0000bc  4620              MOV      r0,r4                 ;2338
0000be  f7fffffe          BL       check_fs
0000c2  e000              B        |L41.198|
                  |L41.196|
0000c4  2002              MOVS     r0,#2                 ;2338
                  |L41.198|
0000c6  b110              CBZ      r0,|L41.206|
0000c8  1c76              ADDS     r6,r6,#1              ;2339
0000ca  2e04              CMP      r6,#4                 ;2339
0000cc  d3f2              BCC      |L41.180|
                  |L41.206|
0000ce  2803              CMP      r0,#3                 ;2341
0000d0  d002              BEQ      |L41.216|
0000d2  b118              CBZ      r0,|L41.220|
0000d4  200d              MOVS     r0,#0xd               ;2342
0000d6  e7a1              B        |L41.28|
                  |L41.216|
0000d8  2001              MOVS     r0,#1                 ;2341
0000da  e79f              B        |L41.28|
                  |L41.220|
0000dc  7ae0              LDRB     r0,[r4,#0xb]          ;2346
0000de  7b21              LDRB     r1,[r4,#0xc]          ;2346
0000e0  ea402001          ORR      r0,r0,r1,LSL #8       ;2346
0000e4  f5b07f00          CMP      r0,#0x200             ;2346
0000e8  d001              BEQ      |L41.238|
0000ea  200d              MOVS     r0,#0xd               ;2347
0000ec  e796              B        |L41.28|
                  |L41.238|
0000ee  7da0              LDRB     r0,[r4,#0x16]         ;2349
0000f0  7de1              LDRB     r1,[r4,#0x17]         ;2349
0000f2  ea402101          ORR      r1,r0,r1,LSL #8       ;2349
0000f6  b959              CBNZ     r1,|L41.272|
0000f8  f8140f24          LDRB     r0,[r4,#0x24]!        ;2350
0000fc  78e1              LDRB     r1,[r4,#3]            ;2350
0000fe  7862              LDRB     r2,[r4,#1]            ;2350
000100  ea406101          ORR      r1,r0,r1,LSL #24      ;2350
000104  78a0              LDRB     r0,[r4,#2]            ;2350
000106  0400              LSLS     r0,r0,#16             ;2350
000108  3c24              SUBS     r4,r4,#0x24           ;2350
00010a  ea402002          ORR      r0,r0,r2,LSL #8       ;2350
00010e  4301              ORRS     r1,r1,r0              ;2350
                  |L41.272|
000110  f8c41218          STR      r1,[r4,#0x218]        ;2351
000114  f8949010          LDRB     r9,[r4,#0x10]         ;2353
000118  f8849203          STRB     r9,[r4,#0x203]        ;2353
00011c  f1b90f01          CMP      r9,#1                 ;2354
000120  d004              BEQ      |L41.300|
000122  f1b90f02          CMP      r9,#2                 ;2354
000126  d001              BEQ      |L41.300|
000128  200d              MOVS     r0,#0xd               ;2355
00012a  e777              B        |L41.28|
                  |L41.300|
00012c  fb09f901          MUL      r9,r9,r1              ;2356
000130  7b62              LDRB     r2,[r4,#0xd]          ;2358
000132  f8842202          STRB     r2,[r4,#0x202]        ;2358
000136  b112              CBZ      r2,|L41.318|
000138  1e50              SUBS     r0,r2,#1              ;2359
00013a  4202              TST      r2,r0                 ;2359
00013c  d001              BEQ      |L41.322|
                  |L41.318|
00013e  200d              MOVS     r0,#0xd               ;2360
000140  e76c              B        |L41.28|
                  |L41.322|
000142  7c60              LDRB     r0,[r4,#0x11]         ;2362
000144  7ca3              LDRB     r3,[r4,#0x12]         ;2362
000146  ea402303          ORR      r3,r0,r3,LSL #8       ;2362
00014a  f8a43208          STRH     r3,[r4,#0x208]        ;2362
00014e  0718              LSLS     r0,r3,#28             ;2363
000150  d001              BEQ      |L41.342|
000152  200d              MOVS     r0,#0xd               ;2364
000154  e762              B        |L41.28|
                  |L41.342|
000156  7ce0              LDRB     r0,[r4,#0x13]         ;2366
000158  7d26              LDRB     r6,[r4,#0x14]         ;2366
00015a  ea402006          ORR      r0,r0,r6,LSL #8       ;2366
00015e  b960              CBNZ     r0,|L41.378|
000160  f8140f20          LDRB     r0,[r4,#0x20]!        ;2367
000164  78e6              LDRB     r6,[r4,#3]            ;2367
000166  f894c001          LDRB     r12,[r4,#1]           ;2367
00016a  ea406006          ORR      r0,r0,r6,LSL #24      ;2367
00016e  78a6              LDRB     r6,[r4,#2]            ;2367
000170  0436              LSLS     r6,r6,#16             ;2367
000172  3c20              SUBS     r4,r4,#0x20           ;2367
000174  ea46260c          ORR      r6,r6,r12,LSL #8      ;2367
000178  4330              ORRS     r0,r0,r6              ;2367
                  |L41.378|
00017a  7ba6              LDRB     r6,[r4,#0xe]          ;2369
00017c  f894c00f          LDRB     r12,[r4,#0xf]         ;2369
000180  ea46280c          ORR      r8,r6,r12,LSL #8      ;2369
000184  f1b80f00          CMP      r8,#0                 ;2370
000188  d007              BEQ      |L41.410|
00018a  eb080609          ADD      r6,r8,r9              ;2373
00018e  eb061c13          ADD      r12,r6,r3,LSR #4      ;2373
000192  4560              CMP      r0,r12                ;2374
000194  d203              BCS      |L41.414|
000196  200d              MOVS     r0,#0xd               ;2374
000198  e740              B        |L41.28|
                  |L41.410|
00019a  200d              MOVS     r0,#0xd               ;2370
00019c  e73e              B        |L41.28|
                  |L41.414|
00019e  eba0000c          SUB      r0,r0,r12             ;2375
0001a2  fbb0f0f2          UDIV     r0,r0,r2              ;2375
0001a6  b358              CBZ      r0,|L41.512|
0001a8  2601              MOVS     r6,#1                 ;2377
0001aa  f64072f6          MOV      r2,#0xff6             ;2378
0001ae  4290              CMP      r0,r2                 ;2378
0001b0  d300              BCC      |L41.436|
0001b2  2602              MOVS     r6,#2                 ;2378
                  |L41.436|
0001b4  f64f72f6          MOV      r2,#0xfff6            ;2379
0001b8  4290              CMP      r0,r2                 ;2379
0001ba  d300              BCC      |L41.446|
0001bc  2603              MOVS     r6,#3                 ;2379
                  |L41.446|
0001be  1c80              ADDS     r0,r0,#2              ;2382
0001c0  f8c40214          STR      r0,[r4,#0x214]        ;2382
0001c4  f8c4521c          STR      r5,[r4,#0x21c]        ;2383
0001c8  eb050208          ADD      r2,r5,r8              ;2384
0001cc  f8c42220          STR      r2,[r4,#0x220]        ;2384
0001d0  44ac              ADD      r12,r12,r5            ;2385
0001d2  f8c4c228          STR      r12,[r4,#0x228]       ;2385
0001d6  2e03              CMP      r6,#3                 ;2386
0001d8  d014              BEQ      |L41.516|
0001da  b33b              CBZ      r3,|L41.556|
0001dc  444a              ADD      r2,r2,r9              ;2392
0001de  f8c42224          STR      r2,[r4,#0x224]        ;2392
0001e2  2e02              CMP      r6,#2                 ;2393
0001e4  d024              BEQ      |L41.560|
0001e6  f0000201          AND      r2,r0,#1              ;2394
0001ea  eb000040          ADD      r0,r0,r0,LSL #1       ;2394
0001ee  eb020050          ADD      r0,r2,r0,LSR #1       ;2394
                  |L41.498|
0001f2  f20010ff          ADD      r0,r0,#0x1ff          ;2396
0001f6  ebb12f50          CMP      r1,r0,LSR #9          ;2396
0001fa  d21b              BCS      |L41.564|
0001fc  200d              MOVS     r0,#0xd               ;2397
0001fe  e70d              B        |L41.28|
                  |L41.512|
000200  200d              MOVS     r0,#0xd               ;2376
000202  e70b              B        |L41.28|
                  |L41.516|
000204  b10b              CBZ      r3,|L41.522|
000206  200d              MOVS     r0,#0xd               ;2387
000208  e708              B        |L41.28|
                  |L41.522|
00020a  f8142f2c          LDRB     r2,[r4,#0x2c]!        ;2388
00020e  78e3              LDRB     r3,[r4,#3]            ;2388
000210  f894c001          LDRB     r12,[r4,#1]           ;2388
000214  ea426203          ORR      r2,r2,r3,LSL #24      ;2388
000218  78a3              LDRB     r3,[r4,#2]            ;2388
00021a  041b              LSLS     r3,r3,#16             ;2388
00021c  ea43230c          ORR      r3,r3,r12,LSL #8      ;2388
000220  431a              ORRS     r2,r2,r3              ;2388
000222  f8c421f8          STR      r2,[r4,#0x1f8]        ;2388
000226  3c2c              SUBS     r4,r4,#0x2c           ;2388
000228  0080              LSLS     r0,r0,#2              ;2389
00022a  e7e2              B        |L41.498|
                  |L41.556|
00022c  200d              MOVS     r0,#0xd               ;2391
00022e  e6f5              B        |L41.28|
                  |L41.560|
000230  0040              LSLS     r0,r0,#1              ;2394
000232  e7de              B        |L41.498|
                  |L41.564|
000234  f04f30ff          MOV      r0,#0xffffffff        ;2401
000238  f8c40210          STR      r0,[r4,#0x210]        ;2401
00023c  f8c4020c          STR      r0,[r4,#0x20c]        ;2401
000240  2080              MOVS     r0,#0x80              ;2404
000242  f8840205          STRB     r0,[r4,#0x205]        ;2404
000246  2e03              CMP      r6,#3                 ;2406
000248  d152              BNE      |L41.752|
00024a  f8940030          LDRB     r0,[r4,#0x30]         ;2407
00024e  f8941031          LDRB     r1,[r4,#0x31]         ;2407
000252  ea402001          ORR      r0,r0,r1,LSL #8       ;2407
000256  2801              CMP      r0,#1                 ;2407
000258  d14a              BNE      |L41.752|
00025a  1c69              ADDS     r1,r5,#1              ;2408
00025c  4620              MOV      r0,r4                 ;2408
00025e  f7fffffe          BL       move_window
000262  bbe8              CBNZ     r0,|L41.736|
000264  f8847205          STRB     r7,[r4,#0x205]        ;2410
000268  f89401fe          LDRB     r0,[r4,#0x1fe]        ;2411
00026c  f89411ff          LDRB     r1,[r4,#0x1ff]        ;2411
000270  ea402001          ORR      r0,r0,r1,LSL #8       ;2411
000274  f5a0412a          SUB      r1,r0,#0xaa00         ;2411
000278  3955              SUBS     r1,r1,#0x55           ;2411
00027a  d139              BNE      |L41.752|
00027c  7820              LDRB     r0,[r4,#0]            ;2412
00027e  78e1              LDRB     r1,[r4,#3]            ;2412
000280  7862              LDRB     r2,[r4,#1]            ;2412
000282  ea406001          ORR      r0,r0,r1,LSL #24      ;2412
000286  78a1              LDRB     r1,[r4,#2]            ;2412
000288  0409              LSLS     r1,r1,#16             ;2412
00028a  ea412102          ORR      r1,r1,r2,LSL #8       ;2412
00028e  4308              ORRS     r0,r0,r1              ;2412
000290  491f              LDR      r1,|L41.784|
000292  4288              CMP      r0,r1                 ;2412
000294  d12c              BNE      |L41.752|
000296  f89401e4          LDRB     r0,[r4,#0x1e4]        ;2413
00029a  f89411e7          LDRB     r1,[r4,#0x1e7]        ;2413
00029e  f89421e5          LDRB     r2,[r4,#0x1e5]        ;2413
0002a2  ea406001          ORR      r0,r0,r1,LSL #24      ;2413
0002a6  f89411e6          LDRB     r1,[r4,#0x1e6]        ;2413
0002aa  0409              LSLS     r1,r1,#16             ;2413
0002ac  ea412102          ORR      r1,r1,r2,LSL #8       ;2413
0002b0  4308              ORRS     r0,r0,r1              ;2413
0002b2  4918              LDR      r1,|L41.788|
0002b4  4288              CMP      r0,r1                 ;2413
0002b6  d11b              BNE      |L41.752|
0002b8  f50474f4          ADD      r4,r4,#0x1e8          ;2416
0002bc  7820              LDRB     r0,[r4,#0]            ;2416
0002be  78e1              LDRB     r1,[r4,#3]            ;2416
0002c0  7862              LDRB     r2,[r4,#1]            ;2416
0002c2  ea406001          ORR      r0,r0,r1,LSL #24      ;2416
0002c6  78a1              LDRB     r1,[r4,#2]            ;2416
0002c8  0409              LSLS     r1,r1,#16             ;2416
0002ca  ea412102          ORR      r1,r1,r2,LSL #8       ;2416
0002ce  4308              ORRS     r0,r0,r1              ;2416
0002d0  62a0              STR      r0,[r4,#0x28]         ;2416
0002d2  7920              LDRB     r0,[r4,#4]            ;2419
0002d4  79e1              LDRB     r1,[r4,#7]            ;2419
0002d6  ea406001          ORR      r0,r0,r1,LSL #24      ;2419
0002da  79a1              LDRB     r1,[r4,#6]            ;2419
0002dc  0409              LSLS     r1,r1,#16             ;2419
0002de  e000              B        |L41.738|
                  |L41.736|
0002e0  e006              B        |L41.752|
                  |L41.738|
0002e2  7962              LDRB     r2,[r4,#5]            ;2419
0002e4  ea412102          ORR      r1,r1,r2,LSL #8       ;2419
0002e8  4308              ORRS     r0,r0,r1              ;2419
0002ea  6260              STR      r0,[r4,#0x24]         ;2419
0002ec  f5a474f4          SUB      r4,r4,#0x1e8          ;2419
                  |L41.752|
0002f0  f8846200          STRB     r6,[r4,#0x200]        ;2425
0002f4  4905              LDR      r1,|L41.780|
0002f6  1f09              SUBS     r1,r1,#4              ;2426
0002f8  8808              LDRH     r0,[r1,#0]            ;2426  ; Fsid
0002fa  1c40              ADDS     r0,r0,#1              ;2426
0002fc  8008              STRH     r0,[r1,#0]            ;2426
0002fe  f8a40206          STRH     r0,[r4,#0x206]        ;2426
000302  4620              MOV      r0,r4                 ;2431
000304  f7fffffe          BL       clear_lock
000308  2000              MOVS     r0,#0                 ;2434
00030a  e687              B        |L41.28|
;;;2436   
                          ENDP

                  |L41.780|
                          DCD      ||.data||+0x4
                  |L41.784|
                          DCD      0x41615252
                  |L41.788|
                          DCD      0x61417272

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2124   static
;;;2125   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2126   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2127   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2128   )
;;;2129   {
000002  4604              MOV      r4,r0
;;;2130   	FRESULT res;
;;;2131   	BYTE *dir, ns;
;;;2132   
;;;2133   
;;;2134   #if _FS_RPATH
;;;2135   	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
;;;2136   		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
;;;2137   	} else {								/* No heading separator */
;;;2138   		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
;;;2139   	}
;;;2140   #else
;;;2141   	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
000004  9901              LDR      r1,[sp,#4]
000006  7808              LDRB     r0,[r1,#0]
000008  282f              CMP      r0,#0x2f
00000a  d001              BEQ      |L42.16|
00000c  285c              CMP      r0,#0x5c
00000e  d101              BNE      |L42.20|
                  |L42.16|
;;;2142   		path++;
000010  1c49              ADDS     r1,r1,#1
000012  9101              STR      r1,[sp,#4]
                  |L42.20|
;;;2143   	dp->sclust = 0;							/* Always start from the root directory */
000014  2500              MOVS     r5,#0
000016  f8c45208          STR      r5,[r4,#0x208]
;;;2144   #endif
;;;2145   
;;;2146   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
00001a  9801              LDR      r0,[sp,#4]
00001c  7800              LDRB     r0,[r0,#0]
00001e  2820              CMP      r0,#0x20
000020  d206              BCS      |L42.48|
;;;2147   		res = dir_sdi(dp, 0);
000022  2100              MOVS     r1,#0
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       dir_sdi
;;;2148   		dp->dir = 0;
00002a  f8c45214          STR      r5,[r4,#0x214]
                  |L42.46|
;;;2149   	} else {								/* Follow path */
;;;2150   		for (;;) {
;;;2151   			res = create_name(dp, &path);	/* Get a segment name of the path */
;;;2152   			if (res != FR_OK) break;
;;;2153   			res = dir_find(dp);				/* Find an object with the sagment name */
;;;2154   			ns = dp->fn[NSFLAG];
;;;2155   			if (res != FR_OK) {				/* Failed to find the object */
;;;2156   				if (res == FR_NO_FILE) {	/* Object is not found */
;;;2157   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
;;;2158   						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
;;;2159   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2160   						res = FR_OK;					/* Ended at the root directroy. Function completed. */
;;;2161   					} else {							/* Could not find the object */
;;;2162   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
;;;2163   					}
;;;2164   				}
;;;2165   				break;
;;;2166   			}
;;;2167   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
;;;2168   			dir = dp->dir;						/* Follow the sub-directory */
;;;2169   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
;;;2170   				res = FR_NO_PATH; break;
;;;2171   			}
;;;2172   			dp->sclust = ld_clust(dp->fs, dir);
;;;2173   		}
;;;2174   	}
;;;2175   
;;;2176   	return res;
;;;2177   }
00002e  bd7c              POP      {r2-r6,pc}
                  |L42.48|
000030  a901              ADD      r1,sp,#4              ;2151
000032  4620              MOV      r0,r4                 ;2151
000034  f7fffffe          BL       create_name
000038  2800              CMP      r0,#0                 ;2152
00003a  d1f8              BNE      |L42.46|
00003c  4620              MOV      r0,r4                 ;2153
00003e  f7fffffe          BL       dir_find
000042  f8d41218          LDR      r1,[r4,#0x218]        ;2154
000046  7ac9              LDRB     r1,[r1,#0xb]          ;2154
000048  b128              CBZ      r0,|L42.86|
00004a  2804              CMP      r0,#4                 ;2156
00004c  d1ef              BNE      |L42.46|
00004e  0749              LSLS     r1,r1,#29             ;2162
000050  d4ed              BMI      |L42.46|
000052  2005              MOVS     r0,#5                 ;2162
                  |L42.84|
000054  bd7c              POP      {r2-r6,pc}
                  |L42.86|
000056  0749              LSLS     r1,r1,#29             ;2167
000058  d4fc              BMI      |L42.84|
00005a  f8d41214          LDR      r1,[r4,#0x214]        ;2168
00005e  7ac8              LDRB     r0,[r1,#0xb]          ;2169
000060  06c0              LSLS     r0,r0,#27             ;2169
000062  d401              BMI      |L42.104|
000064  2005              MOVS     r0,#5                 ;2170
000066  bd7c              POP      {r2-r6,pc}
                  |L42.104|
000068  f8d40200          LDR      r0,[r4,#0x200]        ;2172
00006c  f7fffffe          BL       ld_clust
000070  f8c40208          STR      r0,[r4,#0x208]        ;2172
000074  e7dc              B        |L42.48|
;;;2178   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;890    
;;;891    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;892    	FATFS* fs,	/* File system object */
;;;893    	DWORD clst	/* FAT index number (cluster number) to get the value */
;;;894    )
;;;895    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;896    	UINT wc, bc;
;;;897    	BYTE *p;
;;;898    	DWORD val;
;;;899    
;;;900    
;;;901    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2d02              CMP      r5,#2
00000a  d303              BCC      |L43.20|
00000c  f8d40214          LDR      r0,[r4,#0x214]
000010  42a8              CMP      r0,r5
000012  d801              BHI      |L43.24|
                  |L43.20|
;;;902    		val = 1;	/* Internal error */
000014  2601              MOVS     r6,#1
000016  e00a              B        |L43.46|
                  |L43.24|
;;;903    
;;;904    	} else {
;;;905    		val = 0xFFFFFFFF;	/* Default value falls on disk error */
000018  f04f36ff          MOV      r6,#0xffffffff
;;;906    
;;;907    		switch (fs->fs_type) {
00001c  f8940200          LDRB     r0,[r4,#0x200]
000020  2801              CMP      r0,#1
000022  d007              BEQ      |L43.52|
000024  2802              CMP      r0,#2
000026  d02b              BEQ      |L43.128|
000028  2803              CMP      r0,#3
00002a  d03a              BEQ      |L43.162|
;;;908    		case FS_FAT12 :
;;;909    			bc = (UINT)clst; bc += bc / 2;
;;;910    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;911    			wc = fs->win.d8[bc++ % SS(fs)];
;;;912    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;913    			wc |= fs->win.d8[bc % SS(fs)] << 8;
;;;914    			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
;;;915    			break;
;;;916    
;;;917    		case FS_FAT16 :
;;;918    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
;;;919    			p = &fs->win.d8[clst * 2 % SS(fs)];
;;;920    			val = LD_WORD(p);
;;;921    			break;
;;;922    
;;;923    		case FS_FAT32 :
;;;924    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
;;;925    			p = &fs->win.d8[clst * 4 % SS(fs)];
;;;926    			val = LD_DWORD(p) & 0x0FFFFFFF;
;;;927    			break;
;;;928    
;;;929    		default:
;;;930    			val = 1;	/* Internal error */
00002c  2601              MOVS     r6,#1
                  |L43.46|
;;;931    		}
;;;932    	}
;;;933    
;;;934    	return val;
00002e  4630              MOV      r0,r6
;;;935    }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L43.52|
000034  eb050755          ADD      r7,r5,r5,LSR #1       ;909
000038  f8d40220          LDR      r0,[r4,#0x220]        ;910
00003c  eb002157          ADD      r1,r0,r7,LSR #9       ;910
000040  4620              MOV      r0,r4                 ;910
000042  f7fffffe          BL       move_window
000046  2800              CMP      r0,#0                 ;910
000048  d1f1              BNE      |L43.46|
00004a  f3c70008          UBFX     r0,r7,#0,#9           ;911
00004e  f1070801          ADD      r8,r7,#1              ;911
000052  f8149000          LDRB     r9,[r4,r0]            ;911
000056  f8d40220          LDR      r0,[r4,#0x220]        ;912
00005a  eb002158          ADD      r1,r0,r8,LSR #9       ;912
00005e  4620              MOV      r0,r4                 ;912
000060  f7fffffe          BL       move_window
000064  2800              CMP      r0,#0                 ;912
000066  d1e2              BNE      |L43.46|
000068  f3c80008          UBFX     r0,r8,#0,#9           ;913
00006c  5c20              LDRB     r0,[r4,r0]            ;913
00006e  ea492000          ORR      r0,r9,r0,LSL #8       ;913
000072  07e9              LSLS     r1,r5,#31             ;914
000074  d001              BEQ      |L43.122|
000076  0906              LSRS     r6,r0,#4              ;914
000078  e7d9              B        |L43.46|
                  |L43.122|
00007a  f3c0060b          UBFX     r6,r0,#0,#12          ;914
00007e  e7d6              B        |L43.46|
                  |L43.128|
000080  f8d40220          LDR      r0,[r4,#0x220]        ;918
000084  eb002115          ADD      r1,r0,r5,LSR #8       ;918
000088  4620              MOV      r0,r4                 ;918
00008a  f7fffffe          BL       move_window
00008e  2800              CMP      r0,#0                 ;918
000090  d1cd              BNE      |L43.46|
000092  b2e8              UXTB     r0,r5                 ;919
000094  eb040040          ADD      r0,r4,r0,LSL #1       ;919
000098  7801              LDRB     r1,[r0,#0]            ;920
00009a  7840              LDRB     r0,[r0,#1]            ;920
00009c  ea412600          ORR      r6,r1,r0,LSL #8       ;920
0000a0  e7c5              B        |L43.46|
                  |L43.162|
0000a2  f8d40220          LDR      r0,[r4,#0x220]        ;924
0000a6  eb0011d5          ADD      r1,r0,r5,LSR #7       ;924
0000aa  4620              MOV      r0,r4                 ;924
0000ac  f7fffffe          BL       move_window
0000b0  2800              CMP      r0,#0                 ;924
0000b2  d1bc              BNE      |L43.46|
0000b4  f24010ff          MOV      r0,#0x1ff             ;925
0000b8  ea000085          AND      r0,r0,r5,LSL #2       ;925
0000bc  4420              ADD      r0,r0,r4              ;925
0000be  7801              LDRB     r1,[r0,#0]            ;926
0000c0  78c2              LDRB     r2,[r0,#3]            ;926
0000c2  ea416102          ORR      r1,r1,r2,LSL #24      ;926
0000c6  7882              LDRB     r2,[r0,#2]            ;926
0000c8  7840              LDRB     r0,[r0,#1]            ;926
0000ca  0412              LSLS     r2,r2,#16             ;926
0000cc  ea422000          ORR      r0,r2,r0,LSL #8       ;926
0000d0  4301              ORRS     r1,r1,r0              ;926
0000d2  f0214670          BIC      r6,r1,#0xf0000000     ;926
0000d6  e7aa              B        |L43.46|
;;;936    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1772   static
;;;1773   void get_fileinfo (		/* No return code */
000000  b530              PUSH     {r4,r5,lr}
;;;1774   	DIR* dp,			/* Pointer to the directory object */
;;;1775   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;1776   )
;;;1777   {
;;;1778   	UINT i;
;;;1779   	TCHAR *p, c;
;;;1780   	BYTE *dir;
;;;1781   #if _USE_LFN
;;;1782   	WCHAR w, *lfn;
;;;1783   #endif
;;;1784   
;;;1785   	p = fno->fname;
000002  f1010209          ADD      r2,r1,#9
;;;1786   	if (dp->sect) {		/* Get SFN */
000006  f8d03210          LDR      r3,[r0,#0x210]
00000a  2b00              CMP      r3,#0
00000c  d02a              BEQ      |L44.100|
;;;1787   		dir = dp->dir;
00000e  f8d00214          LDR      r0,[r0,#0x214]
;;;1788   		i = 0;
000012  2300              MOVS     r3,#0
;;;1789   		while (i < 11) {		/* Copy name body and extension */
;;;1790   			c = (TCHAR)dir[i++];
;;;1791   			if (c == ' ') continue;				/* Skip padding spaces */
;;;1792   			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;1793   			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
000014  252e              MOVS     r5,#0x2e
                  |L44.22|
000016  461c              MOV      r4,r3                 ;1790
000018  1c5b              ADDS     r3,r3,#1              ;1790
00001a  5d04              LDRB     r4,[r0,r4]            ;1790
00001c  2c20              CMP      r4,#0x20              ;1791
00001e  d008              BEQ      |L44.50|
000020  2c05              CMP      r4,#5                 ;1792
000022  d100              BNE      |L44.38|
000024  24e5              MOVS     r4,#0xe5              ;1792
                  |L44.38|
000026  2b09              CMP      r3,#9
000028  d101              BNE      |L44.46|
00002a  f8025b01          STRB     r5,[r2],#1
                  |L44.46|
;;;1794   #if _USE_LFN
;;;1795   			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
;;;1796   				c += 0x20;			/* To lower */
;;;1797   #if _LFN_UNICODE
;;;1798   			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
;;;1799   				c = c << 8 | dir[i++];
;;;1800   			c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;1801   			if (!c) c = '?';
;;;1802   #endif
;;;1803   #endif
;;;1804   			*p++ = c;
00002e  f8024b01          STRB     r4,[r2],#1
                  |L44.50|
000032  2b0b              CMP      r3,#0xb               ;1789
000034  d3ef              BCC      |L44.22|
;;;1805   		}
;;;1806   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000036  7ac3              LDRB     r3,[r0,#0xb]
000038  720b              STRB     r3,[r1,#8]
;;;1807   		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
00003a  7f03              LDRB     r3,[r0,#0x1c]
00003c  7fc4              LDRB     r4,[r0,#0x1f]
00003e  7f45              LDRB     r5,[r0,#0x1d]
000040  ea436304          ORR      r3,r3,r4,LSL #24
000044  7f84              LDRB     r4,[r0,#0x1e]
000046  0424              LSLS     r4,r4,#16
000048  ea442405          ORR      r4,r4,r5,LSL #8
00004c  4323              ORRS     r3,r3,r4
00004e  600b              STR      r3,[r1,#0]
;;;1808   		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
000050  7e03              LDRB     r3,[r0,#0x18]
000052  7e44              LDRB     r4,[r0,#0x19]
000054  ea432304          ORR      r3,r3,r4,LSL #8
000058  808b              STRH     r3,[r1,#4]
;;;1809   		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
00005a  7d83              LDRB     r3,[r0,#0x16]
00005c  7dc0              LDRB     r0,[r0,#0x17]
00005e  ea432000          ORR      r0,r3,r0,LSL #8
000062  80c8              STRH     r0,[r1,#6]
                  |L44.100|
;;;1810   	}
;;;1811   	*p = 0;		/* Terminate SFN string by a \0 */
000064  2000              MOVS     r0,#0
000066  7010              STRB     r0,[r2,#0]
;;;1812   
;;;1813   #if _USE_LFN
;;;1814   	if (fno->lfname) {
;;;1815   		i = 0; p = fno->lfname;
;;;1816   		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
;;;1817   			lfn = dp->lfn;
;;;1818   			while ((w = *lfn++) != 0) {		/* Get an LFN character */
;;;1819   #if !_LFN_UNICODE
;;;1820   				w = ff_convert(w, 0);		/* Unicode -> OEM */
;;;1821   				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
;;;1822   				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
;;;1823   					p[i++] = (TCHAR)(w >> 8);
;;;1824   #endif
;;;1825   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
;;;1826   				p[i++] = (TCHAR)w;
;;;1827   			}
;;;1828   		}
;;;1829   		p[i] = 0;	/* Terminate LFN string by a \0 */
;;;1830   	}
;;;1831   #endif
;;;1832   }
000068  bd30              POP      {r4,r5,pc}
;;;1833   #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;2186   static
;;;2187   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b510              PUSH     {r4,lr}
;;;2188   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2189   )
;;;2190   {
000002  4604              MOV      r4,r0
;;;2191   	const TCHAR *tp, *tt;
;;;2192   	UINT i;
;;;2193   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
;;;2194   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2195   	static const char* const str[] = {_VOLUME_STRS};
;;;2196   	const char *sp;
;;;2197   	char c;
;;;2198   	TCHAR tc;
;;;2199   #endif
;;;2200   
;;;2201   
;;;2202   	if (*path) {	/* If the pointer is not a null */
000008  6823              LDR      r3,[r4,#0]
00000a  2b00              CMP      r3,#0
00000c  d00b              BEQ      |L45.38|
;;;2203   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
00000e  4619              MOV      r1,r3
000010  e000              B        |L45.20|
                  |L45.18|
000012  1c49              ADDS     r1,r1,#1
                  |L45.20|
000014  780a              LDRB     r2,[r1,#0]
000016  2a21              CMP      r2,#0x21
000018  d301              BCC      |L45.30|
00001a  2a3a              CMP      r2,#0x3a
00001c  d1f9              BNE      |L45.18|
                  |L45.30|
;;;2204   		if (*tt == ':') {	/* If a ':' is exist in the path name */
00001e  780a              LDRB     r2,[r1,#0]
000020  2a3a              CMP      r2,#0x3a
000022  d001              BEQ      |L45.40|
;;;2205   			tp = *path;
;;;2206   			i = *tp++ - '0'; 
;;;2207   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
;;;2208   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2209   					vol = (int)i;
;;;2210   					*path = ++tt;
;;;2211   				}
;;;2212   			}
;;;2213   #if _STR_VOLUME_ID
;;;2214   			 else {	/* No numeric drive number, find string drive id */
;;;2215   				i = 0; tt++;
;;;2216   				do {
;;;2217   					sp = str[i]; tp = *path;
;;;2218   					do {	/* Compare a string drive id with path name */
;;;2219   						c = *sp++; tc = *tp++;
;;;2220   						if (IsLower(tc)) tc -= 0x20;
;;;2221   					} while (c && (TCHAR)c == tc);
;;;2222   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2223   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2224   					vol = (int)i;
;;;2225   					*path = tt;
;;;2226   				}
;;;2227   			}
;;;2228   #endif
;;;2229   			return vol;
;;;2230   		}
;;;2231   #if _FS_RPATH && _VOLUMES >= 2
;;;2232   		vol = CurrVol;	/* Current drive */
;;;2233   #else
;;;2234   		vol = 0;		/* Drive 0 */
000024  2000              MOVS     r0,#0
                  |L45.38|
;;;2235   #endif
;;;2236   	}
;;;2237   	return vol;
;;;2238   }
000026  bd10              POP      {r4,pc}
                  |L45.40|
000028  f8132b01          LDRB     r2,[r3],#1            ;2206
00002c  3a30              SUBS     r2,r2,#0x30           ;2206
00002e  2a0a              CMP      r2,#0xa               ;2207
000030  d2f9              BCS      |L45.38|
000032  428b              CMP      r3,r1                 ;2207
000034  d1f7              BNE      |L45.38|
000036  2a00              CMP      r2,#0                 ;2208
000038  d1f5              BNE      |L45.38|
00003a  4610              MOV      r0,r2                 ;2209
00003c  1c49              ADDS     r1,r1,#1              ;2210
00003e  6021              STR      r1,[r4,#0]            ;2210
000040  bd10              POP      {r4,pc}
;;;2239   
                          ENDP


                          AREA ||i.inc_lock||, CODE, READONLY, ALIGN=2

                  inc_lock PROC
;;;697    static
;;;698    UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
000000  b5f0              PUSH     {r4-r7,lr}
;;;699    	DIR* dp,	/* Directory object pointing the file to register or increment */
;;;700    	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;;;701    )
;;;702    {
000002  4602              MOV      r2,r0
;;;703    	UINT i;
;;;704    
;;;705    
;;;706    	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
000004  2000              MOVS     r0,#0
;;;707    		if (Files[i].fs == dp->fs &&
000006  4c28              LDR      r4,|L46.168|
000008  f8d25200          LDR      r5,[r2,#0x200]
                  |L46.12|
00000c  eb000340          ADD      r3,r0,r0,LSL #1
000010  f8546023          LDR      r6,[r4,r3,LSL #2]
000014  42ae              CMP      r6,r5
000016  d10b              BNE      |L46.48|
;;;708    			Files[i].clu == dp->sclust &&
000018  eb040383          ADD      r3,r4,r3,LSL #2
00001c  f8d27208          LDR      r7,[r2,#0x208]
000020  685e              LDR      r6,[r3,#4]
000022  42be              CMP      r6,r7
000024  d104              BNE      |L46.48|
;;;709    			Files[i].idx == dp->index) break;
000026  891b              LDRH     r3,[r3,#8]
000028  f8b26206          LDRH     r6,[r2,#0x206]
00002c  42b3              CMP      r3,r6
00002e  d002              BEQ      |L46.54|
                  |L46.48|
000030  1c40              ADDS     r0,r0,#1              ;706
000032  280c              CMP      r0,#0xc               ;706
000034  d3ea              BCC      |L46.12|
                  |L46.54|
;;;710    	}
;;;711    
;;;712    	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
000036  280c              CMP      r0,#0xc
000038  d11a              BNE      |L46.112|
;;;713    		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
00003a  2000              MOVS     r0,#0
00003c  e000              B        |L46.64|
                  |L46.62|
00003e  1c40              ADDS     r0,r0,#1
                  |L46.64|
000040  280c              CMP      r0,#0xc
000042  d205              BCS      |L46.80|
000044  eb000340          ADD      r3,r0,r0,LSL #1
000048  f8543023          LDR      r3,[r4,r3,LSL #2]
00004c  2b00              CMP      r3,#0
00004e  d1f6              BNE      |L46.62|
                  |L46.80|
;;;714    		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
000050  280c              CMP      r0,#0xc
000052  d016              BEQ      |L46.130|
;;;715    		Files[i].fs = dp->fs;
000054  eb000340          ADD      r3,r0,r0,LSL #1
000058  f8445023          STR      r5,[r4,r3,LSL #2]
;;;716    		Files[i].clu = dp->sclust;
00005c  eb040383          ADD      r3,r4,r3,LSL #2
000060  f8d25208          LDR      r5,[r2,#0x208]
000064  605d              STR      r5,[r3,#4]
;;;717    		Files[i].idx = dp->index;
000066  f8b22206          LDRH     r2,[r2,#0x206]
00006a  811a              STRH     r2,[r3,#8]
;;;718    		Files[i].ctr = 0;
00006c  2200              MOVS     r2,#0
00006e  815a              STRH     r2,[r3,#0xa]
                  |L46.112|
;;;719    	}
;;;720    
;;;721    	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
000070  b149              CBZ      r1,|L46.134|
000072  eb000240          ADD      r2,r0,r0,LSL #1
000076  eb040282          ADD      r2,r4,r2,LSL #2
00007a  8952              LDRH     r2,[r2,#0xa]
00007c  b11a              CBZ      r2,|L46.134|
00007e  2000              MOVS     r0,#0
;;;722    
;;;723    	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
;;;724    
;;;725    	return i + 1;
;;;726    }
000080  bdf0              POP      {r4-r7,pc}
                  |L46.130|
000082  2000              MOVS     r0,#0                 ;714
000084  bdf0              POP      {r4-r7,pc}
                  |L46.134|
000086  b111              CBZ      r1,|L46.142|
000088  f44f7180          MOV      r1,#0x100             ;723
00008c  e005              B        |L46.154|
                  |L46.142|
00008e  eb000140          ADD      r1,r0,r0,LSL #1       ;723
000092  eb040181          ADD      r1,r4,r1,LSL #2       ;723
000096  8949              LDRH     r1,[r1,#0xa]          ;723
000098  1c49              ADDS     r1,r1,#1              ;723
                  |L46.154|
00009a  eb000240          ADD      r2,r0,r0,LSL #1       ;723
00009e  eb040282          ADD      r2,r4,r2,LSL #2       ;723
0000a2  8151              STRH     r1,[r2,#0xa]          ;723
0000a4  1c40              ADDS     r0,r0,#1              ;725
0000a6  bdf0              POP      {r4-r7,pc}
;;;727    
                          ENDP

                  |L46.168|
                          DCD      ||.bss||

                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1307   static
;;;1308   DWORD ld_clust (
000000  4602              MOV      r2,r0
;;;1309   	FATFS* fs,	/* Pointer to the fs object */
;;;1310   	BYTE* dir	/* Pointer to the directory entry */
;;;1311   )
;;;1312   {
;;;1313   	DWORD cl;
;;;1314   
;;;1315   	cl = LD_WORD(dir + DIR_FstClusLO);
000002  7e88              LDRB     r0,[r1,#0x1a]
000004  7ecb              LDRB     r3,[r1,#0x1b]
000006  ea402003          ORR      r0,r0,r3,LSL #8
;;;1316   	if (fs->fs_type == FS_FAT32)
00000a  f8922200          LDRB     r2,[r2,#0x200]
00000e  2a03              CMP      r2,#3
000010  d105              BNE      |L47.30|
;;;1317   		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
000012  7d0a              LDRB     r2,[r1,#0x14]
000014  7d49              LDRB     r1,[r1,#0x15]
000016  ea422101          ORR      r1,r2,r1,LSL #8
00001a  ea404001          ORR      r0,r0,r1,LSL #16
                  |L47.30|
;;;1318   
;;;1319   	return cl;
;;;1320   }
00001e  4770              BX       lr
;;;1321   
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;605    static
;;;606    int mem_cmp (const void* dst, const void* src, UINT cnt) {
000000  b510              PUSH     {r4,lr}
;;;607    	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
;;;608    	int r = 0;
000002  2300              MOVS     r3,#0
                  |L48.4|
;;;609    
;;;610    	while (cnt-- && (r = *d++ - *s++) == 0) ;
000004  1e52              SUBS     r2,r2,#1
000006  1c54              ADDS     r4,r2,#1
000008  d005              BEQ      |L48.22|
00000a  f8103b01          LDRB     r3,[r0],#1
00000e  f8114b01          LDRB     r4,[r1],#1
000012  1b1b              SUBS     r3,r3,r4
000014  d0f6              BEQ      |L48.4|
                  |L48.22|
;;;611    	return r;
000016  4618              MOV      r0,r3
;;;612    }
000018  bd10              POP      {r4,pc}
;;;613    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;579    static
;;;580    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e003              B        |L49.10|
                  |L49.2|
;;;581    	BYTE *d = (BYTE*)dst;
;;;582    	const BYTE *s = (const BYTE*)src;
;;;583    
;;;584    #if _WORD_ACCESS == 1
;;;585    	while (cnt >= sizeof (int)) {
;;;586    		*(int*)d = *(int*)s;
;;;587    		d += sizeof (int); s += sizeof (int);
;;;588    		cnt -= sizeof (int);
;;;589    	}
;;;590    #endif
;;;591    	while (cnt--)
;;;592    		*d++ = *s++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
                  |L49.10|
00000a  1e52              SUBS     r2,r2,#1              ;591
00000c  1c53              ADDS     r3,r2,#1              ;591
00000e  d1f8              BNE      |L49.2|
;;;593    }
000010  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;596    static
;;;597    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
000002  e001              B        |L50.8|
                  |L50.4|
;;;598    	BYTE *d = (BYTE*)dst;
;;;599    
;;;600    	while (cnt--)
;;;601    		*d++ = (BYTE)val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L50.8|
000008  1e52              SUBS     r2,r2,#1              ;600
00000a  1c53              ADDS     r3,r2,#1              ;600
00000c  d1fa              BNE      |L50.4|
;;;602    }
00000e  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;801    static
;;;802    FRESULT move_window (
000000  b570              PUSH     {r4-r6,lr}
;;;803    	FATFS* fs,		/* File system object */
;;;804    	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
;;;805    )
;;;806    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;807    	FRESULT res = FR_OK;
000006  2400              MOVS     r4,#0
;;;808    
;;;809    
;;;810    	if (sector != fs->winsect) {	/* Window offset changed? */
000008  f8d5022c          LDR      r0,[r5,#0x22c]
00000c  42b0              CMP      r0,r6
00000e  d011              BEQ      |L51.52|
;;;811    #if !_FS_READONLY
;;;812    		res = sync_window(fs);		/* Write-back changes */
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       sync_window
000016  4604              MOV      r4,r0
;;;813    #endif
;;;814    		if (res == FR_OK) {			/* Fill sector window with new data */
000018  b964              CBNZ     r4,|L51.52|
;;;815    			if (disk_read(fs->drv, fs->win.d8, sector, 1) != RES_OK) {
00001a  f8950201          LDRB     r0,[r5,#0x201]
00001e  2301              MOVS     r3,#1
000020  4632              MOV      r2,r6
000022  4629              MOV      r1,r5
000024  f7fffffe          BL       disk_read
000028  b110              CBZ      r0,|L51.48|
;;;816    				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
00002a  f04f36ff          MOV      r6,#0xffffffff
;;;817    				res = FR_DISK_ERR;
00002e  2401              MOVS     r4,#1
                  |L51.48|
;;;818    			}
;;;819    			fs->winsect = sector;
000030  f8c5622c          STR      r6,[r5,#0x22c]
                  |L51.52|
;;;820    		}
;;;821    	}
;;;822    	return res;
000034  4620              MOV      r0,r4
;;;823    }
000036  bd70              POP      {r4-r6,pc}
;;;824    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;945    #if !_FS_READONLY
;;;946    FRESULT put_fat (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;947    	FATFS* fs,	/* File system object */
;;;948    	DWORD clst,	/* FAT index number (cluster number) to be changed */
;;;949    	DWORD val	/* New value to be set to the entry */
;;;950    )
;;;951    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;952    	UINT bc;
;;;953    	BYTE *p;
;;;954    	FRESULT res;
;;;955    
;;;956    
;;;957    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
00000a  2d02              CMP      r5,#2
00000c  d303              BCC      |L52.22|
00000e  f8d40214          LDR      r0,[r4,#0x214]
000012  42a8              CMP      r0,r5
000014  d802              BHI      |L52.28|
                  |L52.22|
;;;958    		res = FR_INT_ERR;
000016  2002              MOVS     r0,#2
                  |L52.24|
;;;959    
;;;960    	} else {
;;;961    		switch (fs->fs_type) {
;;;962    		case FS_FAT12 :
;;;963    			bc = (UINT)clst; bc += bc / 2;
;;;964    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;965    			if (res != FR_OK) break;
;;;966    			p = &fs->win.d8[bc++ % SS(fs)];
;;;967    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;968    			fs->wflag = 1;
;;;969    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;970    			if (res != FR_OK) break;
;;;971    			p = &fs->win.d8[bc % SS(fs)];
;;;972    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;973    			fs->wflag = 1;
;;;974    			break;
;;;975    
;;;976    		case FS_FAT16 :
;;;977    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;978    			if (res != FR_OK) break;
;;;979    			p = &fs->win.d8[clst * 2 % SS(fs)];
;;;980    			ST_WORD(p, (WORD)val);
;;;981    			fs->wflag = 1;
;;;982    			break;
;;;983    
;;;984    		case FS_FAT32 :
;;;985    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;986    			if (res != FR_OK) break;
;;;987    			p = &fs->win.d8[clst * 4 % SS(fs)];
;;;988    			val |= LD_DWORD(p) & 0xF0000000;
;;;989    			ST_DWORD(p, val);
;;;990    			fs->wflag = 1;
;;;991    			break;
;;;992    
;;;993    		default :
;;;994    			res = FR_INT_ERR;
;;;995    		}
;;;996    	}
;;;997    
;;;998    	return res;
;;;999    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L52.28|
00001c  f8940200          LDRB     r0,[r4,#0x200]        ;961
000020  f00609ff          AND      r9,r6,#0xff           ;967
000024  f04f0801          MOV      r8,#1                 ;961
000028  2801              CMP      r0,#1                 ;961
00002a  d005              BEQ      |L52.56|
00002c  2802              CMP      r0,#2                 ;961
00002e  d038              BEQ      |L52.162|
000030  2803              CMP      r0,#3                 ;961
000032  d049              BEQ      |L52.200|
000034  2002              MOVS     r0,#2                 ;994
000036  e7ef              B        |L52.24|
                  |L52.56|
000038  eb050755          ADD      r7,r5,r5,LSR #1       ;963
00003c  f8d40220          LDR      r0,[r4,#0x220]        ;964
000040  eb002157          ADD      r1,r0,r7,LSR #9       ;964
000044  4620              MOV      r0,r4                 ;964
000046  f7fffffe          BL       move_window
00004a  2800              CMP      r0,#0                 ;965
00004c  d1e4              BNE      |L52.24|
00004e  f3c70008          UBFX     r0,r7,#0,#9           ;966
000052  f1070a01          ADD      r10,r7,#1             ;966
000056  4420              ADD      r0,r0,r4              ;966
000058  07e9              LSLS     r1,r5,#31             ;967
00005a  d003              BEQ      |L52.100|
00005c  7801              LDRB     r1,[r0,#0]            ;967
00005e  f369111f          BFI      r1,r9,#4,#28          ;967
000062  e000              B        |L52.102|
                  |L52.100|
000064  4631              MOV      r1,r6                 ;967
                  |L52.102|
000066  7001              STRB     r1,[r0,#0]            ;967
000068  f8848204          STRB     r8,[r4,#0x204]        ;968
00006c  f8d40220          LDR      r0,[r4,#0x220]        ;969
000070  eb00215a          ADD      r1,r0,r10,LSR #9      ;969
000074  4620              MOV      r0,r4                 ;969
000076  f7fffffe          BL       move_window
00007a  2800              CMP      r0,#0                 ;970
00007c  d1cc              BNE      |L52.24|
00007e  f3ca0108          UBFX     r1,r10,#0,#9          ;971
000082  4421              ADD      r1,r1,r4              ;971
000084  07ea              LSLS     r2,r5,#31             ;972
000086  d002              BEQ      |L52.142|
000088  f3c61207          UBFX     r2,r6,#4,#8           ;972
00008c  e005              B        |L52.154|
                  |L52.142|
00008e  780a              LDRB     r2,[r1,#0]            ;972
000090  f3c62303          UBFX     r3,r6,#8,#4           ;972
000094  f00202f0          AND      r2,r2,#0xf0           ;972
000098  431a              ORRS     r2,r2,r3              ;972
                  |L52.154|
00009a  700a              STRB     r2,[r1,#0]            ;972
00009c  f8848204          STRB     r8,[r4,#0x204]        ;973
0000a0  e7ba              B        |L52.24|
                  |L52.162|
0000a2  f8d40220          LDR      r0,[r4,#0x220]        ;977
0000a6  eb002115          ADD      r1,r0,r5,LSR #8       ;977
0000aa  4620              MOV      r0,r4                 ;977
0000ac  f7fffffe          BL       move_window
0000b0  2800              CMP      r0,#0                 ;978
0000b2  d1b1              BNE      |L52.24|
0000b4  b2e9              UXTB     r1,r5                 ;979
0000b6  eb040141          ADD      r1,r4,r1,LSL #1       ;979
0000ba  f8819000          STRB     r9,[r1,#0]            ;980
0000be  0a32              LSRS     r2,r6,#8              ;980
0000c0  704a              STRB     r2,[r1,#1]            ;980
0000c2  f8848204          STRB     r8,[r4,#0x204]        ;981
0000c6  e7a7              B        |L52.24|
                  |L52.200|
0000c8  f8d40220          LDR      r0,[r4,#0x220]        ;985
0000cc  eb0011d5          ADD      r1,r0,r5,LSR #7       ;985
0000d0  4620              MOV      r0,r4                 ;985
0000d2  f7fffffe          BL       move_window
0000d6  2800              CMP      r0,#0                 ;986
0000d8  d19e              BNE      |L52.24|
0000da  f24011ff          MOV      r1,#0x1ff             ;987
0000de  ea010185          AND      r1,r1,r5,LSL #2       ;987
0000e2  4421              ADD      r1,r1,r4              ;987
0000e4  f04f4370          MOV      r3,#0xf0000000        ;988
0000e8  78ca              LDRB     r2,[r1,#3]            ;988
0000ea  ea036202          AND      r2,r3,r2,LSL #24      ;988
0000ee  4332              ORRS     r2,r2,r6              ;988
0000f0  700a              STRB     r2,[r1,#0]            ;989
0000f2  0a13              LSRS     r3,r2,#8              ;989
0000f4  704b              STRB     r3,[r1,#1]            ;989
0000f6  0c13              LSRS     r3,r2,#16             ;989
0000f8  708b              STRB     r3,[r1,#2]            ;989
0000fa  0e12              LSRS     r2,r2,#24             ;989
0000fc  70ca              STRB     r2,[r1,#3]            ;989
0000fe  f8848204          STRB     r8,[r4,#0x204]        ;990
000102  e789              B        |L52.24|
;;;1000   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.putc_bfd||, CODE, READONLY, ALIGN=1

                  putc_bfd PROC
;;;4543   static
;;;4544   void putc_bfd (
000000  b5f8              PUSH     {r3-r7,lr}
;;;4545   	putbuff* pb,
;;;4546   	TCHAR c
;;;4547   )
;;;4548   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;4549   	UINT bw;
;;;4550   	int i;
;;;4551   
;;;4552   
;;;4553   	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
000006  2e0a              CMP      r6,#0xa
000008  d103              BNE      |L53.18|
;;;4554   		putc_bfd(pb, '\r');
00000a  210d              MOVS     r1,#0xd
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       putc_bfd
                  |L53.18|
;;;4555   
;;;4556   	i = pb->idx;	/* Buffer write index (-1:error) */
000012  6860              LDR      r0,[r4,#4]
;;;4557   	if (i < 0) return;
000014  2800              CMP      r0,#0
000016  db16              BLT      |L53.70|
;;;4558   
;;;4559   #if _USE_LFN && _LFN_UNICODE
;;;4560   #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
;;;4561   	if (c < 0x80) {				/* 7-bit */
;;;4562   		pb->buf[i++] = (BYTE)c;
;;;4563   	} else {
;;;4564   		if (c < 0x800) {		/* 11-bit */
;;;4565   			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
;;;4566   		} else {				/* 16-bit */
;;;4567   			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
;;;4568   			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
;;;4569   		}
;;;4570   		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
;;;4571   	}
;;;4572   #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
;;;4573   	pb->buf[i++] = (BYTE)(c >> 8);
;;;4574   	pb->buf[i++] = (BYTE)c;
;;;4575   #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
;;;4576   	pb->buf[i++] = (BYTE)c;
;;;4577   	pb->buf[i++] = (BYTE)(c >> 8);
;;;4578   #else							/* Write a character in ANSI/OEM */
;;;4579   	c = ff_convert(c, 0);	/* Unicode -> OEM */
;;;4580   	if (!c) c = '?';
;;;4581   	if (c >= 0x100)
;;;4582   		pb->buf[i++] = (BYTE)(c >> 8);
;;;4583   	pb->buf[i++] = (BYTE)c;
;;;4584   #endif
;;;4585   #else							/* Write a character without conversion */
;;;4586   	pb->buf[i++] = (BYTE)c;
000018  1c45              ADDS     r5,r0,#1
00001a  4420              ADD      r0,r0,r4
00001c  7306              STRB     r6,[r0,#0xc]
;;;4587   #endif
;;;4588   
;;;4589   	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
00001e  2d3d              CMP      r5,#0x3d
000020  db0d              BLT      |L53.62|
;;;4590   		f_write(pb->fp, pb->buf, (UINT)i, &bw);
000022  466b              MOV      r3,sp
000024  462a              MOV      r2,r5
000026  f104010c          ADD      r1,r4,#0xc
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       f_write
;;;4591   		i = (bw == (UINT)i) ? 0 : -1;
000030  9800              LDR      r0,[sp,#0]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L53.58|
000036  2500              MOVS     r5,#0
000038  e001              B        |L53.62|
                  |L53.58|
00003a  f04f35ff          MOV      r5,#0xffffffff
                  |L53.62|
;;;4592   	}
;;;4593   	pb->idx = i;
00003e  6065              STR      r5,[r4,#4]
;;;4594   	pb->nchr++;
000040  68a0              LDR      r0,[r4,#8]
000042  1c40              ADDS     r0,r0,#1
000044  60a0              STR      r0,[r4,#8]
                  |L53.70|
;;;4595   }
000046  bdf8              POP      {r3-r7,pc}
;;;4596   
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;1009   static
;;;1010   FRESULT remove_chain (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1011   	FATFS* fs,			/* File system object */
;;;1012   	DWORD clst			/* Cluster# to remove a chain from */
;;;1013   )
;;;1014   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1015   	FRESULT res;
;;;1016   	DWORD nxt;
;;;1017   #if _USE_TRIM
;;;1018   	DWORD scl = clst, ecl = clst, rt[2];
;;;1019   #endif
;;;1020   
;;;1021   	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2f02              CMP      r7,#2
00000a  d303              BCC      |L54.20|
00000c  f8d40214          LDR      r0,[r4,#0x214]
000010  42b8              CMP      r0,r7
000012  d801              BHI      |L54.24|
                  |L54.20|
;;;1022   		res = FR_INT_ERR;
000014  2602              MOVS     r6,#2
000016  e029              B        |L54.108|
                  |L54.24|
;;;1023   
;;;1024   	} else {
;;;1025   		res = FR_OK;
000018  2600              MOVS     r6,#0
;;;1026   		while (clst < fs->n_fatent) {			/* Not a last link? */
00001a  e023              B        |L54.100|
                  |L54.28|
;;;1027   			nxt = get_fat(fs, clst);			/* Get cluster status */
00001c  4639              MOV      r1,r7
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       get_fat
000024  4605              MOV      r5,r0
;;;1028   			if (nxt == 0) break;				/* Empty cluster? */
000026  b30d              CBZ      r5,|L54.108|
;;;1029   			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
000028  2d01              CMP      r5,#1
00002a  d009              BEQ      |L54.64|
;;;1030   			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
00002c  1c68              ADDS     r0,r5,#1
00002e  d009              BEQ      |L54.68|
;;;1031   			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
000030  2200              MOVS     r2,#0
000032  4639              MOV      r1,r7
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       put_fat
00003a  4606              MOV      r6,r0
;;;1032   			if (res != FR_OK) break;
00003c  b9b6              CBNZ     r6,|L54.108|
00003e  e003              B        |L54.72|
                  |L54.64|
000040  2602              MOVS     r6,#2                 ;1029
000042  e013              B        |L54.108|
                  |L54.68|
000044  2601              MOVS     r6,#1                 ;1030
000046  e011              B        |L54.108|
                  |L54.72|
;;;1033   			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
000048  f8d40210          LDR      r0,[r4,#0x210]
00004c  1c41              ADDS     r1,r0,#1
00004e  d008              BEQ      |L54.98|
;;;1034   				fs->free_clust++;
000050  1c40              ADDS     r0,r0,#1
000052  f8c40210          STR      r0,[r4,#0x210]
;;;1035   				fs->fsi_flag |= 1;
000056  f8940205          LDRB     r0,[r4,#0x205]
00005a  f0400001          ORR      r0,r0,#1
00005e  f8840205          STRB     r0,[r4,#0x205]
                  |L54.98|
;;;1036   			}
;;;1037   #if _USE_TRIM
;;;1038   			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;1039   				ecl = nxt;
;;;1040   			} else {				/* End of contiguous clusters */ 
;;;1041   				rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;1042   				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;1043   				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
;;;1044   				scl = ecl = nxt;
;;;1045   			}
;;;1046   #endif
;;;1047   			clst = nxt;	/* Next cluster */
000062  462f              MOV      r7,r5
                  |L54.100|
000064  f8d40214          LDR      r0,[r4,#0x214]        ;1026
000068  42b8              CMP      r0,r7                 ;1026
00006a  d8d7              BHI      |L54.28|
                  |L54.108|
;;;1048   		}
;;;1049   	}
;;;1050   
;;;1051   	return res;
00006c  4630              MOV      r0,r6
;;;1052   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1053   #endif
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1324   static
;;;1325   void st_clust (
000000  7681              STRB     r1,[r0,#0x1a]
;;;1326   	BYTE* dir,	/* Pointer to the directory entry */
;;;1327   	DWORD cl	/* Value to be set */
;;;1328   )
;;;1329   {
;;;1330   	ST_WORD(dir + DIR_FstClusLO, cl);
000002  0a0a              LSRS     r2,r1,#8
000004  76c2              STRB     r2,[r0,#0x1b]
;;;1331   	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
000006  0c0a              LSRS     r2,r1,#16
000008  7502              STRB     r2,[r0,#0x14]
00000a  0e09              LSRS     r1,r1,#24
00000c  7541              STRB     r1,[r0,#0x15]
;;;1332   }
00000e  4770              BX       lr
;;;1333   #endif
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=1

                  sync_fs PROC
;;;832    static
;;;833    FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
000000  b570              PUSH     {r4-r6,lr}
;;;834    	FATFS* fs		/* File system object */
;;;835    )
;;;836    {
000002  4604              MOV      r4,r0
;;;837    	FRESULT res;
;;;838    
;;;839    
;;;840    	res = sync_window(fs);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       sync_window
00000a  4605              MOV      r5,r0
;;;841    	if (res == FR_OK) {
00000c  0028              MOVS     r0,r5
00000e  d152              BNE      |L56.182|
;;;842    		/* Update FSINFO sector if needed */
;;;843    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
000010  f8940200          LDRB     r0,[r4,#0x200]
000014  2803              CMP      r0,#3
000016  d146              BNE      |L56.166|
000018  f8940205          LDRB     r0,[r4,#0x205]
00001c  2801              CMP      r0,#1
00001e  d142              BNE      |L56.166|
;;;844    			/* Create FSINFO structure */
;;;845    			mem_set(fs->win.d8, 0, SS(fs));
000020  0242              LSLS     r2,r0,#9
000022  2100              MOVS     r1,#0
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       mem_set
;;;846    			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
00002a  2055              MOVS     r0,#0x55
00002c  f88401fe          STRB     r0,[r4,#0x1fe]
000030  20aa              MOVS     r0,#0xaa
000032  f88401ff          STRB     r0,[r4,#0x1ff]
;;;847    			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
000036  2052              MOVS     r0,#0x52
000038  7020              STRB     r0,[r4,#0]
00003a  7060              STRB     r0,[r4,#1]
00003c  2061              MOVS     r0,#0x61
00003e  70a0              STRB     r0,[r4,#2]
000040  2141              MOVS     r1,#0x41
000042  70e1              STRB     r1,[r4,#3]
;;;848    			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
000044  2272              MOVS     r2,#0x72
000046  f88421e4          STRB     r2,[r4,#0x1e4]
00004a  f88421e5          STRB     r2,[r4,#0x1e5]
00004e  f88411e6          STRB     r1,[r4,#0x1e6]
000052  f88401e7          STRB     r0,[r4,#0x1e7]
;;;849    			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
000056  f8d40210          LDR      r0,[r4,#0x210]
00005a  f88401e8          STRB     r0,[r4,#0x1e8]
00005e  0a01              LSRS     r1,r0,#8
000060  f88411e9          STRB     r1,[r4,#0x1e9]
000064  0c01              LSRS     r1,r0,#16
000066  f88411ea          STRB     r1,[r4,#0x1ea]
00006a  0e00              LSRS     r0,r0,#24
00006c  f88401eb          STRB     r0,[r4,#0x1eb]
;;;850    			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
000070  f8d4020c          LDR      r0,[r4,#0x20c]
000074  f88401ec          STRB     r0,[r4,#0x1ec]
000078  0a01              LSRS     r1,r0,#8
00007a  f88411ed          STRB     r1,[r4,#0x1ed]
00007e  0c01              LSRS     r1,r0,#16
000080  f88411ee          STRB     r1,[r4,#0x1ee]
000084  0e00              LSRS     r0,r0,#24
000086  f88401ef          STRB     r0,[r4,#0x1ef]
;;;851    			/* Write it into the FSINFO sector */
;;;852    			fs->winsect = fs->volbase + 1;
00008a  f8d4221c          LDR      r2,[r4,#0x21c]
00008e  1c52              ADDS     r2,r2,#1
000090  f8c4222c          STR      r2,[r4,#0x22c]
;;;853    			disk_write(fs->drv, fs->win.d8, fs->winsect, 1);
000094  f8940201          LDRB     r0,[r4,#0x201]
000098  2301              MOVS     r3,#1
00009a  4621              MOV      r1,r4
00009c  f7fffffe          BL       disk_write
;;;854    			fs->fsi_flag = 0;
0000a0  2000              MOVS     r0,#0
0000a2  f8840205          STRB     r0,[r4,#0x205]
                  |L56.166|
;;;855    		}
;;;856    		/* Make sure that no pending write process in the physical drive */
;;;857    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
0000a6  2200              MOVS     r2,#0
0000a8  f8940201          LDRB     r0,[r4,#0x201]
0000ac  4611              MOV      r1,r2
0000ae  f7fffffe          BL       disk_ioctl
0000b2  b100              CBZ      r0,|L56.182|
;;;858    			res = FR_DISK_ERR;
0000b4  2501              MOVS     r5,#1
                  |L56.182|
;;;859    	}
;;;860    
;;;861    	return res;
0000b6  4628              MOV      r0,r5
;;;862    }
0000b8  bd70              POP      {r4-r6,pc}
;;;863    #endif
                          ENDP


                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;772    static
;;;773    FRESULT sync_window (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;774    	FATFS* fs		/* File system object */
;;;775    )
;;;776    {
000004  4604              MOV      r4,r0
;;;777    	DWORD wsect;
;;;778    	UINT nf;
;;;779    	FRESULT res = FR_OK;
000006  2700              MOVS     r7,#0
;;;780    
;;;781    
;;;782    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000008  f8940204          LDRB     r0,[r4,#0x204]
00000c  2800              CMP      r0,#0
00000e  d025              BEQ      |L57.92|
;;;783    		wsect = fs->winsect;	/* Current sector number */
000010  f8d4622c          LDR      r6,[r4,#0x22c]
;;;784    		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
000014  f8940201          LDRB     r0,[r4,#0x201]
000018  2301              MOVS     r3,#1
00001a  4632              MOV      r2,r6
00001c  4621              MOV      r1,r4
00001e  f7fffffe          BL       disk_write
000022  b108              CBZ      r0,|L57.40|
;;;785    			res = FR_DISK_ERR;
000024  2701              MOVS     r7,#1
000026  e019              B        |L57.92|
                  |L57.40|
;;;786    		} else {
;;;787    			fs->wflag = 0;
000028  2000              MOVS     r0,#0
00002a  f8840204          STRB     r0,[r4,#0x204]
;;;788    			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
00002e  f8d40220          LDR      r0,[r4,#0x220]
000032  f8d41218          LDR      r1,[r4,#0x218]
000036  1a30              SUBS     r0,r6,r0
000038  4288              CMP      r0,r1
00003a  d20f              BCS      |L57.92|
;;;789    				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
00003c  f8945203          LDRB     r5,[r4,#0x203]
000040  e00a              B        |L57.88|
                  |L57.66|
;;;790    					wsect += fs->fsize;
000042  f8d40218          LDR      r0,[r4,#0x218]
000046  4406              ADD      r6,r6,r0
;;;791    					disk_write(fs->drv, fs->win.d8, wsect, 1);
000048  f8940201          LDRB     r0,[r4,#0x201]
00004c  2301              MOVS     r3,#1
00004e  4632              MOV      r2,r6
000050  4621              MOV      r1,r4
000052  f7fffffe          BL       disk_write
000056  1e6d              SUBS     r5,r5,#1              ;789
                  |L57.88|
000058  2d02              CMP      r5,#2                 ;789
00005a  d2f2              BCS      |L57.66|
                  |L57.92|
;;;792    				}
;;;793    			}
;;;794    		}
;;;795    	}
;;;796    	return res;
00005c  4638              MOV      r0,r7
;;;797    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;798    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2444   static
;;;2445   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2446   	void* obj		/* Pointer to the object FIL/DIR to check validity */
;;;2447   )
;;;2448   {
;;;2449   	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
;;;2450   
;;;2451   
;;;2452   	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
000002  2800              CMP      r0,#0
000004  d011              BEQ      |L58.42|
000006  f8d01200          LDR      r1,[r0,#0x200]
00000a  b171              CBZ      r1,|L58.42|
00000c  f8912200          LDRB     r2,[r1,#0x200]
000010  b15a              CBZ      r2,|L58.42|
000012  f8b12206          LDRH     r2,[r1,#0x206]
000016  f8b00204          LDRH     r0,[r0,#0x204]
00001a  4282              CMP      r2,r0
00001c  d105              BNE      |L58.42|
00001e  f8910201          LDRB     r0,[r1,#0x201]
000022  f7fffffe          BL       disk_status
000026  07c0              LSLS     r0,r0,#31
000028  d001              BEQ      |L58.46|
                  |L58.42|
;;;2453   		return FR_INVALID_OBJECT;
00002a  2009              MOVS     r0,#9
;;;2454   
;;;2455   	ENTER_FF(fil->fs);		/* Lock file system */
;;;2456   
;;;2457   	return FR_OK;
;;;2458   }
00002c  bd10              POP      {r4,pc}
                  |L58.46|
00002e  2000              MOVS     r0,#0                 ;2457
000030  bd10              POP      {r4,pc}
;;;2459   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Files
                          %        144

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  ExCvt
000000  80818283          DCB      0x80,0x81,0x82,0x83
000004  84858687          DCB      0x84,0x85,0x86,0x87
000008  88898a8b          DCB      0x88,0x89,0x8a,0x8b
00000c  8c8d8e8f          DCB      0x8c,0x8d,0x8e,0x8f
000010  90919293          DCB      0x90,0x91,0x92,0x93
000014  94959697          DCB      0x94,0x95,0x96,0x97
000018  9899ad9b          DCB      0x98,0x99,0xad,0x9b
00001c  8c9dae9f          DCB      0x8c,0x9d,0xae,0x9f
000020  a021a2a3          DCB      0xa0,0x21,0xa2,0xa3
000024  a4a5a6a7          DCB      0xa4,0xa5,0xa6,0xa7
000028  a8a9aaab          DCB      0xa8,0xa9,0xaa,0xab
00002c  acadaeaf          DCB      0xac,0xad,0xae,0xaf
000030  b0b1b2b3          DCB      0xb0,0xb1,0xb2,0xb3
000034  b4b5b6b7          DCB      0xb4,0xb5,0xb6,0xb7
000038  b8b9babb          DCB      0xb8,0xb9,0xba,0xbb
00003c  bcbdbebf          DCB      0xbc,0xbd,0xbe,0xbf
000040  c0c1c2c3          DCB      0xc0,0xc1,0xc2,0xc3
000044  c4c5c6c7          DCB      0xc4,0xc5,0xc6,0xc7
000048  c8c9cacb          DCB      0xc8,0xc9,0xca,0xcb
00004c  cccdcecf          DCB      0xcc,0xcd,0xce,0xcf
000050  d0d1d2d3          DCB      0xd0,0xd1,0xd2,0xd3
000054  d4d5d6d7          DCB      0xd4,0xd5,0xd6,0xd7
000058  d8d9dadb          DCB      0xd8,0xd9,0xda,0xdb
00005c  dcdddedf          DCB      0xdc,0xdd,0xde,0xdf
000060  c0c1c2c3          DCB      0xc0,0xc1,0xc2,0xc3
000064  c4c5c6c7          DCB      0xc4,0xc5,0xc6,0xc7
000068  c8c9cacb          DCB      0xc8,0xc9,0xca,0xcb
00006c  cccdcecf          DCB      0xcc,0xcd,0xce,0xcf
000070  d0d1d2d3          DCB      0xd0,0xd1,0xd2,0xd3
000074  d4d5d6f7          DCB      0xd4,0xd5,0xd6,0xf7
000078  d8d9dadb          DCB      0xd8,0xd9,0xda,0xdb
00007c  dcddde9f          DCB      0xdc,0xdd,0xde,0x9f
                  vst
000080  04000200          DCW      0x0400,0x0200
000084  01000080          DCW      0x0100,0x0080
000088  00400020          DCW      0x0040,0x0020
00008c  00100008          DCW      0x0010,0x0008
000090  00040002          DCW      0x0004,0x0002
000094  0000              DCW      0x0000
                  ||cst||
000096  8000              DCW      0x8000
000098  40002000          DCW      0x4000,0x2000
00009c  10000800          DCW      0x1000,0x0800
0000a0  40002000          DCW      0x4000,0x2000
0000a4  10000800          DCW      0x1000,0x0800
0000a8  04000200          DCW      0x0400,0x0200

                          AREA ||.data||, DATA, ALIGN=2

                  Fsid
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  FatFs
                          DCD      0x00000000
