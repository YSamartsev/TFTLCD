; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otft_lcd\stm32f1xx_nucleo.o --asm_dir=./ --list_dir=--list --depend=tft_lcd\stm32f1xx_nucleo.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I../Drivers/BSP/Components -I../Drivers/BSP\Components/Common -I..\Middlewares\Third_Party\FatFs\src -I..\Drivers\BSP\Adafruit_Shield -I..\Drivers\BSP\STM32F1xx_Nucleo -I..\Middlewares\Third_Party\FatFs\src\drivers -I..\Drivers\BSP\Components\st7789 -I.\RTE\_TFT_LCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F103xB --omf_browse=tft_lcd\stm32f1xx_nucleo.crf ..\Drivers\BSP\STM32F1xx_Nucleo\stm32f1xx_nucleo.c]
                          THUMB

                          AREA ||i.ADCx_DeInit||, CODE, READONLY, ALIGN=2

                  ADCx_DeInit PROC
;;;752      */
;;;753    static void ADCx_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;754    {
;;;755        hnucleo_Adc.Instance   = NUCLEO_ADCx;
000002  4906              LDR      r1,|L1.28|
000004  4804              LDR      r0,|L1.24|
000006  6008              STR      r0,[r1,#0]  ; hnucleo_Adc
;;;756        
;;;757        HAL_ADC_DeInit(&hnucleo_Adc);
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       HAL_ADC_DeInit
;;;758        ADCx_MspDeInit(&hnucleo_Adc);
00000e  e8bd4010          POP      {r4,lr}
000012  4802              LDR      r0,|L1.28|
000014  f7ffbffe          B.W      ADCx_MspDeInit
;;;759    }
;;;760    
                          ENDP

                  |L1.24|
                          DCD      0x40012400
                  |L1.28|
                          DCD      ||.bss||

                          AREA ||i.ADCx_Init||, CODE, READONLY, ALIGN=2

                  ADCx_Init PROC
;;;714      */
;;;715    static HAL_StatusTypeDef ADCx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;716    {
;;;717      /* Set ADC instance */
;;;718      hnucleo_Adc.Instance = NUCLEO_ADCx;
000002  4c12              LDR      r4,|L2.76|
000004  4810              LDR      r0,|L2.72|
000006  6020              STR      r0,[r4,#0]  ; hnucleo_Adc
;;;719    
;;;720      if(HAL_ADC_GetState(&hnucleo_Adc) == HAL_ADC_STATE_RESET)
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       HAL_ADC_GetState
00000e  b9c8              CBNZ     r0,|L2.68|
;;;721      {
;;;722        /* ADC Config */
;;;723        hnucleo_Adc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
000010  2000              MOVS     r0,#0
000012  6060              STR      r0,[r4,#4]  ; hnucleo_Adc
;;;724        hnucleo_Adc.Init.ScanConvMode = ADC_SCAN_DISABLE;
000014  60a0              STR      r0,[r4,#8]  ; hnucleo_Adc
;;;725        hnucleo_Adc.Init.ContinuousConvMode = DISABLE;
000016  7320              STRB     r0,[r4,#0xc]
;;;726        hnucleo_Adc.Init.NbrOfConversion = 1;
000018  2101              MOVS     r1,#1
00001a  6121              STR      r1,[r4,#0x10]  ; hnucleo_Adc
;;;727        hnucleo_Adc.Init.DiscontinuousConvMode = DISABLE;
00001c  7520              STRB     r0,[r4,#0x14]
;;;728        hnucleo_Adc.Init.NbrOfDiscConversion = 1;
00001e  61a1              STR      r1,[r4,#0x18]  ; hnucleo_Adc
;;;729        hnucleo_Adc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
000020  f44f2060          MOV      r0,#0xe0000
000024  61e0              STR      r0,[r4,#0x1c]  ; hnucleo_Adc
;;;730        
;;;731        /* Initialize MSP related to ADC */
;;;732        ADCx_MspInit(&hnucleo_Adc);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       ADCx_MspInit
;;;733        
;;;734        /* Initialize ADC */
;;;735        if (HAL_ADC_Init(&hnucleo_Adc) != HAL_OK)
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       HAL_ADC_Init
000032  b108              CBZ      r0,|L2.56|
;;;736        {
;;;737          return HAL_ERROR;
000034  2001              MOVS     r0,#1
;;;738        }
;;;739        
;;;740        /* Run ADC calibration */
;;;741        if (HAL_ADCEx_Calibration_Start(&hnucleo_Adc) != HAL_OK)
;;;742        {
;;;743          return HAL_ERROR;
;;;744        }
;;;745      }
;;;746    
;;;747      return HAL_OK;
;;;748    }  
000036  bd10              POP      {r4,pc}
                  |L2.56|
000038  4804              LDR      r0,|L2.76|
00003a  f7fffffe          BL       HAL_ADCEx_Calibration_Start
00003e  b108              CBZ      r0,|L2.68|
000040  2001              MOVS     r0,#1                 ;743
000042  bd10              POP      {r4,pc}
                  |L2.68|
000044  2000              MOVS     r0,#0                 ;747
000046  bd10              POP      {r4,pc}
;;;749    
                          ENDP

                  |L2.72|
                          DCD      0x40012400
                  |L2.76|
                          DCD      ||.bss||

                          AREA ||i.ADCx_MspDeInit||, CODE, READONLY, ALIGN=2

                  ADCx_MspDeInit PROC
;;;695      */
;;;696    static void ADCx_MspDeInit(ADC_HandleTypeDef *hadc)
000000  4804              LDR      r0,|L3.20|
;;;697    {
;;;698      GPIO_InitTypeDef  gpioinitstruct;
;;;699    
;;;700      /*** DeInit the ADC peripheral ***/ 
;;;701      /* Disable ADC clock */
;;;702      NUCLEO_ADCx_CLK_DISABLE(); 
000002  6981              LDR      r1,[r0,#0x18]
000004  f4217100          BIC      r1,r1,#0x200
000008  6181              STR      r1,[r0,#0x18]
;;;703    
;;;704      /* Configure the selected ADC Channel as analog input */
;;;705      gpioinitstruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
00000a  2101              MOVS     r1,#1
;;;706      HAL_GPIO_DeInit(NUCLEO_ADCx_GPIO_PORT, gpioinitstruct.Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  f7ffbffe          B.W      HAL_GPIO_DeInit
;;;707    
;;;708      /* Disable GPIO clock has to be done by the application*/
;;;709      /* NUCLEO_ADCx_GPIO_CLK_DISABLE(); */
;;;710    }
;;;711    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000
                  |L3.24|
                          DCD      0x40010c00

                          AREA ||i.ADCx_MspInit||, CODE, READONLY, ALIGN=2

                  ADCx_MspInit PROC
;;;671      */
;;;672    static void ADCx_MspInit(ADC_HandleTypeDef *hadc)
000000  b510              PUSH     {r4,lr}
;;;673    {
000002  b086              SUB      sp,sp,#0x18
;;;674      GPIO_InitTypeDef  gpioinitstruct;
;;;675      
;;;676      /*** Configure the GPIOs ***/  
;;;677      /* Enable GPIO clock */
;;;678      NUCLEO_ADCx_GPIO_CLK_ENABLE();
000004  4c0e              LDR      r4,|L4.64|
000006  69a0              LDR      r0,[r4,#0x18]
000008  f0400008          ORR      r0,r0,#8
00000c  61a0              STR      r0,[r4,#0x18]
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0000008          AND      r0,r0,#8
000014  9001              STR      r0,[sp,#4]
;;;679      
;;;680      /* Configure ADC1 Channel8 as analog input */
;;;681      gpioinitstruct.Pin    = NUCLEO_ADCx_GPIO_PIN ;
000016  2001              MOVS     r0,#1
000018  9002              STR      r0,[sp,#8]
;;;682      gpioinitstruct.Mode   = GPIO_MODE_ANALOG;
00001a  2103              MOVS     r1,#3
00001c  9103              STR      r1,[sp,#0xc]
;;;683      gpioinitstruct.Pull   = GPIO_NOPULL;
00001e  2100              MOVS     r1,#0
000020  9104              STR      r1,[sp,#0x10]
;;;684      gpioinitstruct.Speed  = GPIO_SPEED_FREQ_MEDIUM;
000022  9005              STR      r0,[sp,#0x14]
;;;685      HAL_GPIO_Init(NUCLEO_ADCx_GPIO_PORT, &gpioinitstruct);
000024  a902              ADD      r1,sp,#8
000026  4807              LDR      r0,|L4.68|
000028  f7fffffe          BL       HAL_GPIO_Init
;;;686    
;;;687      /*** Configure the ADC peripheral ***/ 
;;;688      /* Enable ADC clock */
;;;689      NUCLEO_ADCx_CLK_ENABLE(); 
00002c  69a0              LDR      r0,[r4,#0x18]
00002e  f4407000          ORR      r0,r0,#0x200
000032  61a0              STR      r0,[r4,#0x18]
000034  69a0              LDR      r0,[r4,#0x18]
000036  f4007000          AND      r0,r0,#0x200
00003a  9001              STR      r0,[sp,#4]
;;;690    }
00003c  b006              ADD      sp,sp,#0x18
00003e  bd10              POP      {r4,pc}
;;;691    
                          ENDP

                  |L4.64|
                          DCD      0x40021000
                  |L4.68|
                          DCD      0x40010c00

                          AREA ||i.BSP_GetVersion||, CODE, READONLY, ALIGN=2

                  BSP_GetVersion PROC
;;;133      */
;;;134    uint32_t BSP_GetVersion(void)
000000  4800              LDR      r0,|L5.4|
;;;135    {
;;;136      return __STM32F1XX_NUCLEO_BSP_VERSION;
;;;137    }
000002  4770              BX       lr
;;;138    
                          ENDP

                  |L5.4|
                          DCD      0x01000400

                          AREA ||i.BSP_JOY_DeInit||, CODE, READONLY, ALIGN=1

                  BSP_JOY_DeInit PROC
;;;787      */
;;;788    void BSP_JOY_DeInit(void)
000000  f7ffbffe          B.W      ADCx_DeInit
;;;789    {
;;;790        ADCx_DeInit();
;;;791    }
;;;792    
                          ENDP


                          AREA ||i.BSP_JOY_GetState||, CODE, READONLY, ALIGN=2

                  BSP_JOY_GetState PROC
;;;804      */
;;;805    JOYState_TypeDef BSP_JOY_GetState(void)
000000  b570              PUSH     {r4-r6,lr}
;;;806    {
;;;807      JOYState_TypeDef state = JOY_NONE;
000002  2500              MOVS     r5,#0
;;;808      uint16_t  keyconvertedvalue = 0; 
000004  2400              MOVS     r4,#0
;;;809    
;;;810     /* Start the conversion process */
;;;811      HAL_ADC_Start(&hnucleo_Adc);
000006  4817              LDR      r0,|L7.100|
000008  f7fffffe          BL       HAL_ADC_Start
;;;812      
;;;813      /* Wait for the end of conversion */
;;;814      if (HAL_ADC_PollForConversion(&hnucleo_Adc, 10) != HAL_TIMEOUT)
00000c  210a              MOVS     r1,#0xa
00000e  4815              LDR      r0,|L7.100|
000010  f7fffffe          BL       HAL_ADC_PollForConversion
000014  2803              CMP      r0,#3
000016  d003              BEQ      |L7.32|
;;;815      {
;;;816        /* Get the converted value of regular channel */
;;;817        keyconvertedvalue = HAL_ADC_GetValue(&hnucleo_Adc);
000018  4812              LDR      r0,|L7.100|
00001a  f7fffffe          BL       HAL_ADC_GetValue
00001e  b284              UXTH     r4,r0
                  |L7.32|
;;;818      }
;;;819      
;;;820      if((keyconvertedvalue > 1800) && (keyconvertedvalue < 2090))
000020  f2a47009          SUB      r0,r4,#0x709
000024  f5b07f90          CMP      r0,#0x120
000028  d801              BHI      |L7.46|
;;;821      {
;;;822        state = JOY_UP;
00002a  2505              MOVS     r5,#5
00002c  e018              B        |L7.96|
                  |L7.46|
;;;823      }
;;;824      else if((keyconvertedvalue > 500) && (keyconvertedvalue < 780))
00002e  f2a410f5          SUB      r0,r4,#0x1f5
000032  f5b07f8b          CMP      r0,#0x116
000036  d801              BHI      |L7.60|
;;;825      {
;;;826        state = JOY_RIGHT;
000038  2504              MOVS     r5,#4
00003a  e011              B        |L7.96|
                  |L7.60|
;;;827      }
;;;828      else if((keyconvertedvalue > 1200) && (keyconvertedvalue < 1350))
00003c  f2a440b1          SUB      r0,r4,#0x4b1
000040  2895              CMP      r0,#0x95
000042  d201              BCS      |L7.72|
;;;829      {
;;;830        state = JOY_SEL;
000044  2501              MOVS     r5,#1
000046  e00b              B        |L7.96|
                  |L7.72|
;;;831      }
;;;832      else if((keyconvertedvalue > 10) && (keyconvertedvalue < 130))
000048  f1a4000b          SUB      r0,r4,#0xb
00004c  2877              CMP      r0,#0x77
00004e  d201              BCS      |L7.84|
;;;833      {
;;;834        state = JOY_DOWN;
000050  2502              MOVS     r5,#2
000052  e005              B        |L7.96|
                  |L7.84|
;;;835      }
;;;836      else if((keyconvertedvalue > 3500) && (keyconvertedvalue < 3760))
000054  f6a454ad          SUB      r4,r4,#0xdad
000058  f5b47f81          CMP      r4,#0x102
00005c  d800              BHI      |L7.96|
;;;837      {
;;;838        state = JOY_LEFT;
00005e  2503              MOVS     r5,#3
                  |L7.96|
;;;839      }
;;;840      else
;;;841      {
;;;842        state = JOY_NONE;
;;;843      }
;;;844      
;;;845      /* Return the code of the Joystick key pressed*/
;;;846      return state;
000060  4628              MOV      r0,r5
;;;847    }
000062  bd70              POP      {r4-r6,pc}
;;;848    
                          ENDP

                  |L7.100|
                          DCD      ||.bss||

                          AREA ||i.BSP_JOY_Init||, CODE, READONLY, ALIGN=2

                  BSP_JOY_Init PROC
;;;767      */
;;;768    uint8_t BSP_JOY_Init(void)
000000  b510              PUSH     {r4,lr}
;;;769    {
;;;770      if (ADCx_Init() != HAL_OK)
000002  f7fffffe          BL       ADCx_Init
000006  b108              CBZ      r0,|L8.12|
;;;771      {
;;;772        return (uint8_t) HAL_ERROR; 
000008  2001              MOVS     r0,#1
;;;773      }
;;;774      
;;;775      /* Select Channel 8 to be converted */
;;;776      sConfig.Channel       = ADC_CHANNEL_8;
;;;777      sConfig.SamplingTime  = ADC_SAMPLETIME_71CYCLES_5;
;;;778      sConfig.Rank          = 1;
;;;779    
;;;780      /* Return Joystick initialization status */
;;;781      return (uint8_t)HAL_ADC_ConfigChannel(&hnucleo_Adc, &sConfig);
;;;782    }
00000a  bd10              POP      {r4,pc}
                  |L8.12|
00000c  4806              LDR      r0,|L8.40|
00000e  2108              MOVS     r1,#8                 ;776
000010  6001              STR      r1,[r0,#0]            ;776  ; sConfig
000012  2106              MOVS     r1,#6                 ;777
000014  6081              STR      r1,[r0,#8]            ;777  ; sConfig
000016  2101              MOVS     r1,#1                 ;778
000018  6041              STR      r1,[r0,#4]            ;778  ; sConfig
00001a  4601              MOV      r1,r0                 ;781
00001c  e8bd4010          POP      {r4,lr}               ;781
000020  3830              SUBS     r0,r0,#0x30           ;781
000022  f7ffbffe          B.W      HAL_ADC_ConfigChannel
;;;783    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      ||.bss||+0x30

                          AREA ||i.BSP_LED_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_LED_DeInit PROC
;;;174      */
;;;175    void BSP_LED_DeInit(Led_TypeDef Led)
000000  b57f              PUSH     {r0-r6,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177      GPIO_InitTypeDef  gpio_init_structure;
;;;178    
;;;179      /* Turn off LED */
;;;180      HAL_GPIO_WritePin(LED_PORT[Led],LED_PIN[Led], GPIO_PIN_RESET);
000004  4e09              LDR      r6,|L9.44|
000006  4d0a              LDR      r5,|L9.48|
000008  2200              MOVS     r2,#0
00000a  f8361014          LDRH     r1,[r6,r4,LSL #1]
00000e  f8550024          LDR      r0,[r5,r4,LSL #2]
000012  f7fffffe          BL       HAL_GPIO_WritePin
;;;181      /* DeInit the GPIO_LED pin */
;;;182      gpio_init_structure.Pin = LED_PIN[Led];
000016  f8361014          LDRH     r1,[r6,r4,LSL #1]
00001a  9100              STR      r1,[sp,#0]
;;;183      HAL_GPIO_DeInit(LED_PORT[Led], gpio_init_structure.Pin);
00001c  f8550024          LDR      r0,[r5,r4,LSL #2]
000020  b004              ADD      sp,sp,#0x10
000022  e8bd4070          POP      {r4-r6,lr}
000026  f7ffbffe          B.W      HAL_GPIO_DeInit
;;;184    }
;;;185    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      ||.constdata||+0x2
                  |L9.48|
                          DCD      ||.data||

                          AREA ||i.BSP_LED_Init||, CODE, READONLY, ALIGN=2

                  BSP_LED_Init PROC
;;;148      */
;;;149    void BSP_LED_Init(Led_TypeDef Led)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;151      GPIO_InitTypeDef  gpioinitstruct;
;;;152      
;;;153      /* Enable the GPIO_LED Clock */
;;;154      LEDx_GPIO_CLK_ENABLE(Led);
000006  2c00              CMP      r4,#0
000008  d108              BNE      |L10.28|
00000a  4811              LDR      r0,|L10.80|
00000c  6981              LDR      r1,[r0,#0x18]
00000e  f0410110          ORR      r1,r1,#0x10
000012  6181              STR      r1,[r0,#0x18]
000014  6980              LDR      r0,[r0,#0x18]
000016  f0000010          AND      r0,r0,#0x10
00001a  9001              STR      r0,[sp,#4]
                  |L10.28|
;;;155    
;;;156      /* Configure the GPIO_LED pin */
;;;157      gpioinitstruct.Pin    = LED_PIN[Led];
00001c  4d0d              LDR      r5,|L10.84|
00001e  f8350014          LDRH     r0,[r5,r4,LSL #1]
000022  9002              STR      r0,[sp,#8]
;;;158      gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
000024  2001              MOVS     r0,#1
000026  9003              STR      r0,[sp,#0xc]
;;;159      gpioinitstruct.Pull   = GPIO_NOPULL;
000028  2000              MOVS     r0,#0
00002a  9004              STR      r0,[sp,#0x10]
;;;160      gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
00002c  2003              MOVS     r0,#3
00002e  9005              STR      r0,[sp,#0x14]
;;;161      
;;;162      HAL_GPIO_Init(LED_PORT[Led], &gpioinitstruct);
000030  4e09              LDR      r6,|L10.88|
000032  a902              ADD      r1,sp,#8
000034  f8560024          LDR      r0,[r6,r4,LSL #2]
000038  f7fffffe          BL       HAL_GPIO_Init
;;;163    
;;;164      /* Reset PIN to switch off the LED */
;;;165      HAL_GPIO_WritePin(LED_PORT[Led],LED_PIN[Led], GPIO_PIN_RESET);
00003c  f8351014          LDRH     r1,[r5,r4,LSL #1]
000040  f8560024          LDR      r0,[r6,r4,LSL #2]
000044  2200              MOVS     r2,#0
000046  f7fffffe          BL       HAL_GPIO_WritePin
;;;166    }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd70              POP      {r4-r6,pc}
;;;167    
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      0x40021000
                  |L10.84|
                          DCD      ||.constdata||+0x2
                  |L10.88|
                          DCD      ||.data||

                          AREA ||i.BSP_LED_Off||, CODE, READONLY, ALIGN=2

                  BSP_LED_Off PROC
;;;202      */
;;;203    void BSP_LED_Off(Led_TypeDef Led)
000000  4904              LDR      r1,|L11.20|
;;;204    {
;;;205      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
000002  4a05              LDR      r2,|L11.24|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  2200              MOVS     r2,#0
00000e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;206    }
;;;207    
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      ||.constdata||+0x2
                  |L11.24|
                          DCD      ||.data||

                          AREA ||i.BSP_LED_On||, CODE, READONLY, ALIGN=2

                  BSP_LED_On PROC
;;;191      */
;;;192    void BSP_LED_On(Led_TypeDef Led)
000000  4904              LDR      r1,|L12.20|
;;;193    {
;;;194      HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
000002  4a05              LDR      r2,|L12.24|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  2201              MOVS     r2,#1
00000e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;195    }
;;;196    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      ||.constdata||+0x2
                  |L12.24|
                          DCD      ||.data||

                          AREA ||i.BSP_LED_Toggle||, CODE, READONLY, ALIGN=2

                  BSP_LED_Toggle PROC
;;;213      */
;;;214    void BSP_LED_Toggle(Led_TypeDef Led)
000000  4903              LDR      r1,|L13.16|
;;;215    {
;;;216      HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
000002  4a04              LDR      r2,|L13.20|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  f7ffbffe          B.W      HAL_GPIO_TogglePin
;;;217    }
;;;218    
                          ENDP

                  |L13.16|
                          DCD      ||.constdata||+0x2
                  |L13.20|
                          DCD      ||.data||

                          AREA ||i.BSP_PB_DeInit||, CODE, READONLY, ALIGN=2

                  BSP_PB_DeInit PROC
;;;273      */
;;;274    void BSP_PB_DeInit(Button_TypeDef Button)
000000  b51f              PUSH     {r0-r4,lr}
;;;275    {
000002  4604              MOV      r4,r0
;;;276      GPIO_InitTypeDef gpio_init_structure;
;;;277    
;;;278      gpio_init_structure.Pin = BUTTON_PIN[Button];
000004  4808              LDR      r0,|L14.40|
000006  f8300014          LDRH     r0,[r0,r4,LSL #1]
00000a  9000              STR      r0,[sp,#0]
;;;279      HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
00000c  4806              LDR      r0,|L14.40|
00000e  1f00              SUBS     r0,r0,#4
000010  5700              LDRSB    r0,[r0,r4]
000012  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;280      HAL_GPIO_DeInit(BUTTON_PORT[Button], gpio_init_structure.Pin);
000016  4805              LDR      r0,|L14.44|
000018  9900              LDR      r1,[sp,#0]
00001a  f8500024          LDR      r0,[r0,r4,LSL #2]
00001e  b004              ADD      sp,sp,#0x10
000020  e8bd4010          POP      {r4,lr}
000024  f7ffbffe          B.W      HAL_GPIO_DeInit
;;;281    }
;;;282    
                          ENDP

                  |L14.40|
                          DCD      ||.constdata||+0x4
                  |L14.44|
                          DCD      ||.data||+0x4

                          AREA ||i.BSP_PB_GetState||, CODE, READONLY, ALIGN=2

                  BSP_PB_GetState PROC
;;;288      */
;;;289    uint32_t BSP_PB_GetState(Button_TypeDef Button)
000000  4903              LDR      r1,|L15.16|
;;;290      {
;;;291      return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
000002  4a04              LDR      r2,|L15.20|
000004  f8311010          LDRH     r1,[r1,r0,LSL #1]
000008  f8520020          LDR      r0,[r2,r0,LSL #2]
00000c  f7ffbffe          B.W      HAL_GPIO_ReadPin
;;;292      }
;;;293    /**
                          ENDP

                  |L15.16|
                          DCD      ||.constdata||+0x4
                  |L15.20|
                          DCD      ||.data||+0x4

                          AREA ||i.BSP_PB_Init||, CODE, READONLY, ALIGN=2

                  BSP_PB_Init PROC
;;;236      */
;;;237    void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;239      GPIO_InitTypeDef gpioinitstruct;
;;;240    
;;;241      /* Enable the BUTTON Clock */
;;;242      BUTTONx_GPIO_CLK_ENABLE(Button);
000008  2c00              CMP      r4,#0
00000a  d108              BNE      |L16.30|
00000c  4816              LDR      r0,|L16.104|
00000e  6981              LDR      r1,[r0,#0x18]
000010  f0410104          ORR      r1,r1,#4
000014  6181              STR      r1,[r0,#0x18]
000016  6980              LDR      r0,[r0,#0x18]
000018  f0000004          AND      r0,r0,#4
00001c  9001              STR      r0,[sp,#4]
                  |L16.30|
;;;243    
;;;244      gpioinitstruct.Pin = BUTTON_PIN[Button];
00001e  4813              LDR      r0,|L16.108|
000020  f8300014          LDRH     r0,[r0,r4,LSL #1]
000024  9002              STR      r0,[sp,#8]
;;;245      gpioinitstruct.Pull = GPIO_PULLUP;
000026  2001              MOVS     r0,#1
000028  9004              STR      r0,[sp,#0x10]
;;;246      gpioinitstruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
00002a  9005              STR      r0,[sp,#0x14]
;;;247    
;;;248      if (ButtonMode == BUTTON_MODE_GPIO)
;;;249      {
;;;250        /* Configure Button pin as input */
;;;251        gpioinitstruct.Mode   = GPIO_MODE_INPUT;
;;;252      
;;;253        HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
00002c  4e10              LDR      r6,|L16.112|
00002e  b935              CBNZ     r5,|L16.62|
000030  2000              MOVS     r0,#0                 ;251
000032  9003              STR      r0,[sp,#0xc]          ;251
000034  f8560024          LDR      r0,[r6,r4,LSL #2]
000038  a902              ADD      r1,sp,#8
00003a  f7fffffe          BL       HAL_GPIO_Init
                  |L16.62|
;;;254      }
;;;255     
;;;256      if (ButtonMode == BUTTON_MODE_EXTI)
00003e  2d01              CMP      r5,#1
000040  d110              BNE      |L16.100|
;;;257      {
;;;258        /* Configure Button pin as input with External interrupt */
;;;259        gpioinitstruct.Mode   = GPIO_MODE_IT_FALLING; 
000042  480c              LDR      r0,|L16.116|
000044  9003              STR      r0,[sp,#0xc]
;;;260        HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
000046  f8560024          LDR      r0,[r6,r4,LSL #2]
00004a  a902              ADD      r1,sp,#8
00004c  f7fffffe          BL       HAL_GPIO_Init
;;;261    
;;;262        /* Enable and set Button EXTI Interrupt to the lowest priority */
;;;263        HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0);
000050  4d06              LDR      r5,|L16.108|
000052  2200              MOVS     r2,#0
000054  1f2d              SUBS     r5,r5,#4
000056  210f              MOVS     r1,#0xf
000058  5728              LDRSB    r0,[r5,r4]
00005a  f7fffffe          BL       HAL_NVIC_SetPriority
;;;264        HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
00005e  5728              LDRSB    r0,[r5,r4]
000060  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L16.100|
;;;265      }
;;;266    }
000064  b006              ADD      sp,sp,#0x18
000066  bd70              POP      {r4-r6,pc}
;;;267    
                          ENDP

                  |L16.104|
                          DCD      0x40021000
                  |L16.108|
                          DCD      ||.constdata||+0x4
                  |L16.112|
                          DCD      ||.data||+0x4
                  |L16.116|
                          DCD      0x10210000

                          AREA ||i.LCD_Delay||, CODE, READONLY, ALIGN=1

                  LCD_Delay PROC
;;;662      */
;;;663    void LCD_Delay(uint32_t Delay)
000000  f7ffbffe          B.W      HAL_Delay
;;;664    {
;;;665      HAL_Delay(Delay);
;;;666    }
;;;667    
                          ENDP


                          AREA ||i.LCD_IO_Init||, CODE, READONLY, ALIGN=2

                  LCD_IO_Init PROC
;;;556      */
;;;557    void LCD_IO_Init(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;558    {
000002  b085              SUB      sp,sp,#0x14
;;;559      GPIO_InitTypeDef  gpioinitstruct;
;;;560    
;;;561      /* LCD_CS_GPIO and LCD_DC_GPIO Periph clock enable */
;;;562      LCD_CS_GPIO_CLK_ENABLE(); //PB12 CLK
000004  481e              LDR      r0,|L18.128|
000006  6981              LDR      r1,[r0,#0x18]
000008  f0410108          ORR      r1,r1,#8
00000c  6181              STR      r1,[r0,#0x18]
00000e  6981              LDR      r1,[r0,#0x18]
000010  f0010108          AND      r1,r1,#8
000014  9100              STR      r1,[sp,#0]
;;;563      LCD_DC_GPIO_CLK_ENABLE(); //PB1 CLK
000016  6981              LDR      r1,[r0,#0x18]
000018  f0410108          ORR      r1,r1,#8
00001c  6181              STR      r1,[r0,#0x18]
00001e  6981              LDR      r1,[r0,#0x18]
000020  f0010108          AND      r1,r1,#8
000024  9100              STR      r1,[sp,#0]
;;;564      LCD_RST_GPIO_CLK_ENABLE(); //PB11 CLK
000026  6981              LDR      r1,[r0,#0x18]
000028  f0410104          ORR      r1,r1,#4
00002c  6181              STR      r1,[r0,#0x18]
00002e  6980              LDR      r0,[r0,#0x18]
000030  f0000004          AND      r0,r0,#4
000034  9000              STR      r0,[sp,#0]
;;;565    	
;;;566      /* Configure типу роботи піна PB12: LCD_CS_PIN pin : LCD Card CS pin */
;;;567      gpioinitstruct.Pin    = LCD_CS_PIN; //PB12
000036  f44f5480          MOV      r4,#0x1000
00003a  9401              STR      r4,[sp,#4]
;;;568      gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
00003c  2601              MOVS     r6,#1
00003e  9602              STR      r6,[sp,#8]
;;;569      gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
000040  2003              MOVS     r0,#3
000042  9004              STR      r0,[sp,#0x10]
;;;570      HAL_GPIO_Init(LCD_CS_GPIO_PORT, &gpioinitstruct); 
000044  4f0f              LDR      r7,|L18.132|
000046  a901              ADD      r1,sp,#4
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       HAL_GPIO_Init
;;;571          
;;;572      /* Configure типу роботи піна PB1: LCD_DC_PIN pin: LCD Card DC pin */
;;;573      gpioinitstruct.Pin    = LCD_DC_PIN; //PB1
00004e  2102              MOVS     r1,#2
000050  9101              STR      r1,[sp,#4]
;;;574      HAL_GPIO_Init(LCD_DC_GPIO_PORT, &gpioinitstruct); 
000052  a901              ADD      r1,sp,#4
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       HAL_GPIO_Init
;;;575    	
;;;576    	/* Configure типу роботи піна PB11 LCD_RST_PIN pin */
;;;577      gpioinitstruct.Pin    = LCD_RST_PIN; //PB11
00005a  1065              ASRS     r5,r4,#1
00005c  9501              STR      r5,[sp,#4]
;;;578    	gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
00005e  9602              STR      r6,[sp,#8]
;;;579      HAL_GPIO_Init(LCD_RST_GPIO_PORT, &gpioinitstruct); 
000060  a901              ADD      r1,sp,#4
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       HAL_GPIO_Init
;;;580    
;;;581    	/* LCD chip select high */
;;;582      LCD_CS_HIGH(); //Використовую PB12. В платі не використовується
000068  2201              MOVS     r2,#1
00006a  4621              MOV      r1,r4
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       HAL_GPIO_WritePin
;;;583    	
;;;584    	LCD_RST_HIGH(); //Піднімаю RST
000072  2201              MOVS     r2,#1
000074  4629              MOV      r1,r5
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       HAL_GPIO_WritePin
;;;585    }
00007c  b005              ADD      sp,sp,#0x14
00007e  bdf0              POP      {r4-r7,pc}
;;;586    
                          ENDP

                  |L18.128|
                          DCD      0x40021000
                  |L18.132|
                          DCD      0x40010c00

                          AREA ||i.LCD_IO_WriteMultipleData||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteMultipleData PROC
;;;611    */
;;;612    void LCD_IO_WriteMultipleData(uint8_t *pData, uint32_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;613    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;614      uint32_t counter = 0;
;;;615      
;;;616      /* Reset LCD control line CS */
;;;617      LCD_CS_LOW();
000008  4e17              LDR      r6,|L19.104|
00000a  f44f5780          MOV      r7,#0x1000
00000e  2200              MOVS     r2,#0
000010  4639              MOV      r1,r7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       HAL_GPIO_WritePin
;;;618      
;;;619      /* Set LCD data/command line DC to High */
;;;620      LCD_DC_HIGH();
000018  2201              MOVS     r2,#1
00001a  2102              MOVS     r1,#2
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       HAL_GPIO_WritePin
;;;621    
;;;622      if (Size == 1)
000022  2d01              CMP      r5,#1
000024  d01c              BEQ      |L19.96|
;;;623      {
;;;624        /* Only 1 byte to be sent to LCD - general interface can be used */
;;;625        /* Send Data */
;;;626        SPIx_Write(*pData);
;;;627      }
;;;628      else
;;;629    {
;;;630        /* Several data should be sent in a raw */
;;;631        /* Direct SPI accesses for optimization */
;;;632        for (counter = Size; counter != 0; counter--)
;;;633      {
;;;634          while(((SpiHandle.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
000026  4a11              LDR      r2,|L19.108|
000028  b17d              CBZ      r5,|L19.74|
                  |L19.42|
00002a  6810              LDR      r0,[r2,#0]
                  |L19.44|
00002c  6881              LDR      r1,[r0,#8]
00002e  0789              LSLS     r1,r1,#30
000030  d5fc              BPL      |L19.44|
;;;635      {
;;;636    }
;;;637          /* Need to invert bytes for LCD*/
;;;638          *((__IO uint8_t*)&SpiHandle.Instance->DR) = *(pData+1);
000032  7861              LDRB     r1,[r4,#1]
000034  7301              STRB     r1,[r0,#0xc]
000036  6810              LDR      r0,[r2,#0]            ;634
                  |L19.56|
;;;639    
;;;640          while(((SpiHandle.Instance->SR) & SPI_FLAG_TXE) != SPI_FLAG_TXE)
000038  6881              LDR      r1,[r0,#8]
00003a  0789              LSLS     r1,r1,#30
00003c  d5fc              BPL      |L19.56|
;;;641    {
;;;642    }
;;;643          *((__IO uint8_t*)&SpiHandle.Instance->DR) = *pData;
00003e  f8141b02          LDRB     r1,[r4],#2
000042  7301              STRB     r1,[r0,#0xc]
000044  1ead              SUBS     r5,r5,#2              ;632
000046  2d00              CMP      r5,#0                 ;632
000048  d1ef              BNE      |L19.42|
                  |L19.74|
00004a  6810              LDR      r0,[r2,#0]            ;634
                  |L19.76|
;;;644          counter--;
;;;645          pData += 2;
;;;646      }  
;;;647      
;;;648        /* Wait until the bus is ready before releasing Chip select */ 
;;;649        while(((SpiHandle.Instance->SR) & SPI_FLAG_BSY) != RESET)
00004c  6881              LDR      r1,[r0,#8]
00004e  0609              LSLS     r1,r1,#24
000050  d4fc              BMI      |L19.76|
                  |L19.82|
;;;650      {
;;;651      } 
;;;652      } 
;;;653      
;;;654      /* Deselect : Chip Select high */
;;;655      LCD_CS_HIGH();
000052  4639              MOV      r1,r7
000054  4630              MOV      r0,r6
000056  e8bd41f0          POP      {r4-r8,lr}
00005a  2201              MOVS     r2,#1
00005c  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L19.96|
000060  7820              LDRB     r0,[r4,#0]            ;626
000062  f7fffffe          BL       SPIx_Write
000066  e7f4              B        |L19.82|
;;;656    }
;;;657    
                          ENDP

                  |L19.104|
                          DCD      0x40010c00
                  |L19.108|
                          DCD      SpiHandle

                          AREA ||i.LCD_IO_WriteReg||, CODE, READONLY, ALIGN=2

                  LCD_IO_WriteReg PROC
;;;591      */
;;;592    void LCD_IO_WriteReg(uint8_t LCDReg)
000000  b570              PUSH     {r4-r6,lr}
;;;593    {
000002  4606              MOV      r6,r0
;;;594      /* Reset LCD control line CS */
;;;595      LCD_CS_LOW();
000004  4d0b              LDR      r5,|L20.52|
000006  f44f5480          MOV      r4,#0x1000
00000a  2200              MOVS     r2,#0
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       HAL_GPIO_WritePin
;;;596      
;;;597      /* Set LCD data/command line DC to Low */
;;;598      LCD_DC_LOW();
000014  2200              MOVS     r2,#0
000016  2102              MOVS     r1,#2
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       HAL_GPIO_WritePin
;;;599        
;;;600      /* Send Command */
;;;601      SPIx_Write(LCDReg);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       SPIx_Write
;;;602      
;;;603      /* Deselect : Chip Select high */
;;;604      LCD_CS_HIGH();
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  e8bd4070          POP      {r4-r6,lr}
00002c  2201              MOVS     r2,#1
00002e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;605    }
;;;606    
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      0x40010c00

                          AREA ||i.SD_IO_CSState||, CODE, READONLY, ALIGN=2

                  SD_IO_CSState PROC
;;;492      */
;;;493    void SD_IO_CSState(uint8_t val)
000000  4b06              LDR      r3,|L21.28|
;;;494    {
;;;495      if(val == 1) 
000002  2801              CMP      r0,#1
000004  d004              BEQ      |L21.16|
;;;496      {
;;;497        SD_CS_HIGH();
;;;498    }
;;;499      else
;;;500      {
;;;501        SD_CS_LOW();
000006  2200              MOVS     r2,#0
000008  2120              MOVS     r1,#0x20
00000a  4618              MOV      r0,r3
00000c  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L21.16|
000010  2201              MOVS     r2,#1                 ;497
000012  2120              MOVS     r1,#0x20              ;497
000014  4618              MOV      r0,r3                 ;497
000016  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;502      }
;;;503    }
;;;504     
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      0x40010c00

                          AREA ||i.SD_IO_Init||, CODE, READONLY, ALIGN=2

                  SD_IO_Init PROC
;;;450      */
;;;451    void SD_IO_Init(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;452    {
000004  b085              SUB      sp,sp,#0x14
;;;453      GPIO_InitTypeDef  gpioinitstruct = {0};
000006  2700              MOVS     r7,#0
;;;454      uint8_t counter = 0;
000008  2400              MOVS     r4,#0
;;;455    
;;;456      /* SD_CS_GPIO Periph clock enable */
;;;457      SD_CS_GPIO_CLK_ENABLE();
00000a  481c              LDR      r0,|L22.124|
00000c  6981              LDR      r1,[r0,#0x18]
00000e  f0410108          ORR      r1,r1,#8
000012  6181              STR      r1,[r0,#0x18]
000014  6980              LDR      r0,[r0,#0x18]
000016  f0000008          AND      r0,r0,#8
00001a  9000              STR      r0,[sp,#0]
;;;458    
;;;459      /* Configure SD_CS_PIN pin: SD Card CS pin */
;;;460      gpioinitstruct.Pin    = SD_CS_PIN;
00001c  2020              MOVS     r0,#0x20
00001e  9001              STR      r0,[sp,#4]
;;;461      gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
000020  2501              MOVS     r5,#1
000022  9502              STR      r5,[sp,#8]
;;;462      gpioinitstruct.Pull   = GPIO_PULLUP;
000024  9503              STR      r5,[sp,#0xc]
;;;463      gpioinitstruct.Speed  = GPIO_SPEED_FREQ_HIGH;
000026  f04f0803          MOV      r8,#3
00002a  f8cd8010          STR      r8,[sp,#0x10]
;;;464      HAL_GPIO_Init(SD_CS_GPIO_PORT, &gpioinitstruct);
00002e  f8df9050          LDR      r9,|L22.128|
000032  a901              ADD      r1,sp,#4
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       HAL_GPIO_Init
;;;465    
;;;466      /* Configure LCD_CS_PIN pin: LCD Card CS pin */
;;;467      gpioinitstruct.Pin   = LCD_CS_PIN;
00003a  032e              LSLS     r6,r5,#12
00003c  9601              STR      r6,[sp,#4]
;;;468      gpioinitstruct.Mode  = GPIO_MODE_OUTPUT_PP;
00003e  9502              STR      r5,[sp,#8]
;;;469      gpioinitstruct.Pull  = GPIO_NOPULL;
000040  9703              STR      r7,[sp,#0xc]
;;;470      gpioinitstruct.Speed = GPIO_SPEED_FREQ_HIGH;
000042  f8cd8010          STR      r8,[sp,#0x10]
;;;471      HAL_GPIO_Init(SD_CS_GPIO_PORT, &gpioinitstruct);
000046  a901              ADD      r1,sp,#4
000048  4648              MOV      r0,r9
00004a  f7fffffe          BL       HAL_GPIO_Init
;;;472      LCD_CS_HIGH();
00004e  2201              MOVS     r2,#1
000050  4631              MOV      r1,r6
000052  4648              MOV      r0,r9
000054  f7fffffe          BL       HAL_GPIO_WritePin
;;;473      /*------------Put SD in SPI mode--------------*/
;;;474      /* SD SPI Config */
;;;475      SPIx_Init();
000058  f7fffffe          BL       SPIx_Init
;;;476    
;;;477      /* SD chip select high */
;;;478      SD_CS_HIGH();
00005c  2201              MOVS     r2,#1
00005e  2120              MOVS     r1,#0x20
000060  4648              MOV      r0,r9
000062  f7fffffe          BL       HAL_GPIO_WritePin
                  |L22.102|
;;;479      
;;;480      /* Send dummy byte 0xFF, 10 times with CS high */
;;;481      /* Rise CS and MOSI for 80 clocks cycles */
;;;482      for (counter = 0; counter <= 9; counter++)
;;;483      {
;;;484        /* Send dummy byte 0xFF */
;;;485        SD_IO_WriteByte(SD_DUMMY_BYTE);
000066  20ff              MOVS     r0,#0xff
000068  f7fffffe          BL       SD_IO_WriteByte
00006c  1c64              ADDS     r4,r4,#1              ;482
00006e  b2e4              UXTB     r4,r4                 ;482
000070  2c09              CMP      r4,#9                 ;482
000072  d9f8              BLS      |L22.102|
;;;486      }
;;;487    }
000074  b005              ADD      sp,sp,#0x14
000076  e8bd83f0          POP      {r4-r9,pc}
;;;488    
                          ENDP

00007a  0000              DCW      0x0000
                  |L22.124|
                          DCD      0x40021000
                  |L22.128|
                          DCD      0x40010c00

                          AREA ||i.SD_IO_ReadData||, CODE, READONLY, ALIGN=1

                  SD_IO_ReadData PROC
;;;535      */
;;;536    void SD_IO_ReadData(uint8_t *DataOut, uint16_t DataLength)
000000  460a              MOV      r2,r1
;;;537    {
;;;538      /* Send the byte */
;;;539      SD_IO_WriteReadData(DataOut, DataOut, DataLength);
000002  4601              MOV      r1,r0
000004  f7ffbffe          B.W      SD_IO_WriteReadData
;;;540      }   
;;;541     
                          ENDP


                          AREA ||i.SD_IO_WriteByte||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteByte PROC
;;;521      */
;;;522    uint8_t SD_IO_WriteByte(uint8_t Data)
000000  b501              PUSH     {r0,lr}
;;;523    {
000002  b082              SUB      sp,sp,#8
;;;524      uint8_t tmp;
;;;525    
;;;526      /* Send the byte */
;;;527      SPIx_WriteReadData(&Data,&tmp,1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  a802              ADD      r0,sp,#8
00000a  f7fffffe          BL       SPIx_WriteReadData
;;;528      return tmp;
00000e  f89d0004          LDRB     r0,[sp,#4]
;;;529    }
000012  bd0e              POP      {r1-r3,pc}
;;;530    
                          ENDP


                          AREA ||i.SD_IO_WriteData||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteData PROC
;;;546      */
;;;547    void SD_IO_WriteData(const uint8_t *Data, uint16_t DataLength)
000000  f7ffbffe          B.W      SPIx_WriteData
;;;548    {
;;;549      /* Send the byte */
;;;550      SPIx_WriteData((uint8_t *)Data, DataLength);
;;;551    }
;;;552    
                          ENDP


                          AREA ||i.SD_IO_WriteReadData||, CODE, READONLY, ALIGN=1

                  SD_IO_WriteReadData PROC
;;;510      */
;;;511    void SD_IO_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
000000  f7ffbffe          B.W      SPIx_WriteReadData
;;;512      {
;;;513      /* Send the byte */
;;;514      SPIx_WriteReadData(DataIn, DataOut, DataLength);
;;;515    }
;;;516    
                          ENDP


                          AREA ||i.SPIx_Error||, CODE, READONLY, ALIGN=2

                  SPIx_Error PROC
;;;432      */
;;;433    void SPIx_Error (void)
000000  b510              PUSH     {r4,lr}
;;;434    {
;;;435      /* De-initialize the SPI communication BUS */
;;;436      HAL_SPI_DeInit(&SpiHandle);
000002  4803              LDR      r0,|L27.16|
000004  f7fffffe          BL       HAL_SPI_DeInit
;;;437    
;;;438      /* Re-Initiaize the SPI communication BUS */
;;;439      SPIx_Init();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      SPIx_Init
;;;440    }
;;;441    
                          ENDP

                  |L27.16|
                          DCD      SpiHandle

                          AREA ||i.SPIx_Init||, CODE, READONLY, ALIGN=2

                  SPIx_Init PROC
;;;341      */
;;;342    void SPIx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344      if(HAL_SPI_GetState(&SpiHandle) == HAL_SPI_STATE_RESET)
000002  4810              LDR      r0,|L28.68|
000004  f7fffffe          BL       HAL_SPI_GetState
000008  2800              CMP      r0,#0
00000a  d119              BNE      |L28.64|
;;;345      {
;;;346    		
;;;347        SpiHandle.Instance = NUCLEO_SPIx;
00000c  480d              LDR      r0,|L28.68|
00000e  490e              LDR      r1,|L28.72|
000010  6001              STR      r1,[r0,#0]  ; SpiHandle
;;;348          /* SPI baudrate is set to 8 MHz maximum (PCLK2/SPI_BaudRatePrescaler = 64/8 = 8 MHz) 
;;;349           to verify these constraints:
;;;350              - ST7735 LCD SPI interface max baudrate is 15MHz for write and 6.66MHz for read
;;;351                Since the provided driver doesn't use read capability from LCD, only constraint 
;;;352                on write baudrate is considered.
;;;353              - SD card SPI interface max baudrate is 25MHz for write/read
;;;354              - PCLK2 max frequency is 32 MHz 
;;;355           */
;;;356        SpiHandle.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_2;
000012  2100              MOVS     r1,#0
000014  61c1              STR      r1,[r0,#0x1c]  ; SpiHandle
;;;357        SpiHandle.Init.Direction          = SPI_DIRECTION_2LINES;
000016  6081              STR      r1,[r0,#8]  ; SpiHandle
;;;358        SpiHandle.Init.CLKPhase           = SPI_PHASE_2EDGE; //ВАЖЛИВО!!! при SPI_PHASE_1EDGE виникають збої
000018  2201              MOVS     r2,#1
00001a  6142              STR      r2,[r0,#0x14]  ; SpiHandle
;;;359        SpiHandle.Init.CLKPolarity        = SPI_POLARITY_HIGH;
00001c  2202              MOVS     r2,#2
00001e  6102              STR      r2,[r0,#0x10]  ; SpiHandle
;;;360        SpiHandle.Init.CRCCalculation     = SPI_CRCCALCULATION_DISABLE;
000020  6281              STR      r1,[r0,#0x28]  ; SpiHandle
;;;361        SpiHandle.Init.CRCPolynomial      = 7;
000022  2207              MOVS     r2,#7
000024  62c2              STR      r2,[r0,#0x2c]  ; SpiHandle
;;;362        SpiHandle.Init.DataSize           = SPI_DATASIZE_8BIT;
000026  60c1              STR      r1,[r0,#0xc]  ; SpiHandle
;;;363        SpiHandle.Init.FirstBit           = SPI_FIRSTBIT_MSB;
000028  6201              STR      r1,[r0,#0x20]  ; SpiHandle
;;;364        SpiHandle.Init.NSS                = SPI_NSS_SOFT;
00002a  f44f7200          MOV      r2,#0x200
00002e  6182              STR      r2,[r0,#0x18]  ; SpiHandle
;;;365        SpiHandle.Init.TIMode             = SPI_TIMODE_DISABLE;
000030  6241              STR      r1,[r0,#0x24]  ; SpiHandle
;;;366        SpiHandle.Init.Mode               = SPI_MODE_MASTER;
000032  f44f7182          MOV      r1,#0x104
000036  6041              STR      r1,[r0,#4]  ; SpiHandle
;;;367        
;;;368    				
;;;369    		HAL_SPI_Init(&SpiHandle);
000038  e8bd4010          POP      {r4,lr}
00003c  f7ffbffe          B.W      HAL_SPI_Init
                  |L28.64|
;;;370    		//SPI_Cmd(SPI2, ENABLE);
;;;371      }
;;;372    }
000040  bd10              POP      {r4,pc}
;;;373    
                          ENDP

000042  0000              DCW      0x0000
                  |L28.68|
                          DCD      SpiHandle
                  |L28.72|
                          DCD      0x40003800

                          AREA ||i.SPIx_MspInit||, CODE, READONLY, ALIGN=2

                  SPIx_MspInit PROC
;;;310      */
;;;311    void SPIx_MspInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  b086              SUB      sp,sp,#0x18
;;;313      GPIO_InitTypeDef  gpioinitstruct = {0};
000004  2500              MOVS     r5,#0
000006  9504              STR      r5,[sp,#0x10]
;;;314      
;;;315      /*** Configure the GPIOs ***/  
;;;316      /* Enable GPIO clock */
;;;317      NUCLEO_SPIx_SCK_GPIO_CLK_ENABLE();
000008  4c1a              LDR      r4,|L29.116|
00000a  69a0              LDR      r0,[r4,#0x18]
00000c  f0400008          ORR      r0,r0,#8
000010  61a0              STR      r0,[r4,#0x18]
000012  69a0              LDR      r0,[r4,#0x18]
000014  f0000008          AND      r0,r0,#8
000018  9001              STR      r0,[sp,#4]
;;;318      NUCLEO_SPIx_MISO_MOSI_GPIO_CLK_ENABLE();
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  f0400008          ORR      r0,r0,#8
000020  61a0              STR      r0,[r4,#0x18]
000022  69a0              LDR      r0,[r4,#0x18]
000024  f0000008          AND      r0,r0,#8
000028  9001              STR      r0,[sp,#4]
;;;319    
;;;320      /* Configure SPI SCK */
;;;321      gpioinitstruct.Pin        = NUCLEO_SPIx_SCK_PIN;
00002a  f44f5000          MOV      r0,#0x2000
00002e  9002              STR      r0,[sp,#8]
;;;322      gpioinitstruct.Mode       = GPIO_MODE_AF_PP;
000030  2002              MOVS     r0,#2
000032  9003              STR      r0,[sp,#0xc]
;;;323      gpioinitstruct.Speed      = GPIO_SPEED_FREQ_HIGH;
000034  2003              MOVS     r0,#3
000036  9005              STR      r0,[sp,#0x14]
;;;324      HAL_GPIO_Init(NUCLEO_SPIx_SCK_GPIO_PORT, &gpioinitstruct);
000038  4e0f              LDR      r6,|L29.120|
00003a  a902              ADD      r1,sp,#8
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       HAL_GPIO_Init
;;;325    
;;;326      /* Configure SPI MISO and MOSI */ 
;;;327      gpioinitstruct.Pin        = NUCLEO_SPIx_MOSI_PIN;
000042  f44f4100          MOV      r1,#0x8000
000046  9102              STR      r1,[sp,#8]
;;;328      HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &gpioinitstruct);
000048  a902              ADD      r1,sp,#8
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       HAL_GPIO_Init
;;;329      
;;;330      gpioinitstruct.Pin        = NUCLEO_SPIx_MISO_PIN;
000050  f44f4180          MOV      r1,#0x4000
000054  9102              STR      r1,[sp,#8]
;;;331      gpioinitstruct.Mode       = GPIO_MODE_INPUT;
000056  9503              STR      r5,[sp,#0xc]
;;;332      HAL_GPIO_Init(NUCLEO_SPIx_MISO_MOSI_GPIO_PORT, &gpioinitstruct);
000058  a902              ADD      r1,sp,#8
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       HAL_GPIO_Init
;;;333    
;;;334      /*** Configure the SPI peripheral ***/ 
;;;335      /* Enable SPI clock */
;;;336      NUCLEO_SPIx_CLK_ENABLE();
000060  69e0              LDR      r0,[r4,#0x1c]
000062  f4404080          ORR      r0,r0,#0x4000
000066  61e0              STR      r0,[r4,#0x1c]
000068  69e0              LDR      r0,[r4,#0x1c]
00006a  f4004080          AND      r0,r0,#0x4000
00006e  9001              STR      r0,[sp,#4]
;;;337    }
000070  b006              ADD      sp,sp,#0x18
000072  bd70              POP      {r4-r6,pc}
;;;338    
                          ENDP

                  |L29.116|
                          DCD      0x40021000
                  |L29.120|
                          DCD      0x40010c00

                          AREA ||i.SPIx_Write||, CODE, READONLY, ALIGN=2

                  SPIx_Write PROC
;;;414      */
;;;415    void SPIx_Write(uint8_t Value)
000000  b501              PUSH     {r0,lr}
;;;416    {
000002  b082              SUB      sp,sp,#8
;;;417      HAL_StatusTypeDef status = HAL_OK;
;;;418      uint8_t data;
;;;419    
;;;420      status = HAL_SPI_TransmitReceive(&SpiHandle, (uint8_t*) &Value, &data, 1, SpixTimeout);
000004  4806              LDR      r0,|L30.32|
000006  2301              MOVS     r3,#1
000008  aa01              ADD      r2,sp,#4
00000a  6880              LDR      r0,[r0,#8]  ; SpixTimeout
00000c  9000              STR      r0,[sp,#0]
00000e  a902              ADD      r1,sp,#8
000010  4804              LDR      r0,|L30.36|
000012  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;421    
;;;422      /* Check the communication status */
;;;423      if(status != HAL_OK)
000016  2800              CMP      r0,#0
000018  d001              BEQ      |L30.30|
;;;424      {
;;;425        /* Execute user timeout callback */
;;;426        SPIx_Error();
00001a  f7fffffe          BL       SPIx_Error
                  |L30.30|
;;;427      }
;;;428    }
00001e  bd0e              POP      {r1-r3,pc}
;;;429    
                          ENDP

                  |L30.32|
                          DCD      ||.data||
                  |L30.36|
                          DCD      SpiHandle

                          AREA ||i.SPIx_WriteData||, CODE, READONLY, ALIGN=2

                  SPIx_WriteData PROC
;;;396      */
;;;397    void SPIx_WriteData(uint8_t *DataIn, uint16_t DataLength)
000000  b510              PUSH     {r4,lr}
;;;398    {
000002  460a              MOV      r2,r1
;;;399      HAL_StatusTypeDef status = HAL_OK;
;;;400    
;;;401      status = HAL_SPI_Transmit(&SpiHandle, DataIn, DataLength, SpixTimeout);
000004  4906              LDR      r1,|L31.32|
000006  688b              LDR      r3,[r1,#8]  ; SpixTimeout
000008  4601              MOV      r1,r0
00000a  4806              LDR      r0,|L31.36|
00000c  f7fffffe          BL       HAL_SPI_Transmit
;;;402      
;;;403      /* Check the communication status */
;;;404      if(status != HAL_OK)
000010  2800              CMP      r0,#0
000012  d003              BEQ      |L31.28|
;;;405      {
;;;406        /* Execute user timeout callback */
;;;407        SPIx_Error();
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      SPIx_Error
                  |L31.28|
;;;408      }
;;;409    }
00001c  bd10              POP      {r4,pc}
;;;410    
                          ENDP

00001e  0000              DCW      0x0000
                  |L31.32|
                          DCD      ||.data||
                  |L31.36|
                          DCD      SpiHandle

                          AREA ||i.SPIx_WriteReadData||, CODE, READONLY, ALIGN=2

                  SPIx_WriteReadData PROC
;;;377    */
;;;378    void SPIx_WriteReadData(const uint8_t *DataIn, uint8_t *DataOut, uint16_t DataLength)
000000  b538              PUSH     {r3-r5,lr}
;;;379    {
000002  460c              MOV      r4,r1
;;;380      HAL_StatusTypeDef status = HAL_OK;
;;;381      
;;;382      status = HAL_SPI_TransmitReceive(&SpiHandle, (uint8_t*) DataIn, DataOut, DataLength, SpixTimeout);
000004  4907              LDR      r1,|L32.36|
000006  4613              MOV      r3,r2
000008  4622              MOV      r2,r4
00000a  6889              LDR      r1,[r1,#8]  ; SpixTimeout
00000c  9100              STR      r1,[sp,#0]
00000e  4601              MOV      r1,r0
000010  4805              LDR      r0,|L32.40|
000012  f7fffffe          BL       HAL_SPI_TransmitReceive
;;;383      
;;;384      /* Check the communication status */
;;;385      if(status != HAL_OK)
000016  2800              CMP      r0,#0
000018  d003              BEQ      |L32.34|
;;;386      {
;;;387        /* Execute user timeout callback */
;;;388        SPIx_Error();
00001a  e8bd4038          POP      {r3-r5,lr}
00001e  f7ffbffe          B.W      SPIx_Error
                  |L32.34|
;;;389      }
;;;390    }
000022  bd38              POP      {r3-r5,pc}
;;;391    
                          ENDP

                  |L32.36|
                          DCD      ||.data||
                  |L32.40|
                          DCD      SpiHandle

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hnucleo_Adc
                          %        48
                  sConfig
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  BUTTON_IRQn
000000  0600              DCB      0x06,0x00
                  LED_PIN
000002  2000              DCW      0x2000
                  BUTTON_PIN
000004  0001              DCW      0x0001

                          AREA ||.data||, DATA, ALIGN=2

                  LED_PORT
                          DCD      0x40011000
                  BUTTON_PORT
                          DCD      0x40010800
                  SpixTimeout
                          DCD      0x000003e8

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\BSP\\STM32F1xx_Nucleo\\stm32f1xx_nucleo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f1xx_nucleo_c_LED_PORT____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f1xx_nucleo_c_LED_PORT____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f1xx_nucleo_c_LED_PORT____REVSH|
#line 478
|__asm___18_stm32f1xx_nucleo_c_LED_PORT____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f1xx_nucleo_c_LED_PORT____RRX|
#line 665
|__asm___18_stm32f1xx_nucleo_c_LED_PORT____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
